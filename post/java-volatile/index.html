<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="imarkofu的个人博客 Gallen">
<meta name="description" content="the most important thing is endurance.">
<meta name="theme-color" content="#222">
<title>java volatile 关键字理解 | imarkofu&#39;s blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1624117506622">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/tomorrow-night-eighties.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?12b3293398b51d8227d4915298f8c206";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

  <meta name="description" content="java volatile 关键字理解" />
  <meta name="keywords" content="Java,同步机制,volatile关键字" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>imarkofu&#39;s blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">the most important thing is endurance.</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Gallen</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">50</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">83</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">83</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://imarkofu.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#-more-volatile%E5%8F%98%E9%87%8F"><!-- more --><br>
volatile变量</a></li>
<li><a href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8volatile%E5%8F%98%E9%87%8F%E7%9A%84%E6%9D%A1%E4%BB%B6">正确使用volatile变量的条件</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%9C%BA%E6%99%AF">使用volatile关键字的场景</a>
<ul>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A0%87%E8%AE%B0%E9%87%8F">状态标记量</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83">一次性安全发布</a></li>
<li><a href="#%E5%BC%80%E9%94%80%E8%BE%83%E4%BD%8E%E7%9A%84%E8%AF%BB-%E5%86%99%E9%94%81%E7%AD%96%E7%95%A5">开销较低的读－写锁策略</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://imarkofu.github.io/post/java-volatile/">
      java volatile 关键字理解
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2017-03-19</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://imarkofu.github.io/tag/Cl0XnUa_Cdl/">
        <span>Java</span>
      </a>、
      
      
      
      <a href="https://imarkofu.github.io/tag/4yySEk_D-Kb/">
        <span>同步机制</span>
      </a>、
      
      
      
      <a href="https://imarkofu.github.io/tag/N0k2_CQy8le/">
        <span>volatile关键字</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>864<span class="pc-show">字数</span></span>
    </span>
    
    
    
    <span id="/post/java-volatile/" data-flag-title="java volatile 关键字理解" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span>浏览量：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p>Java语言包括两种同步机制：同步块和volatile变量，都是为了实现线程的安全性。其中volatile同步性相对弱一些，所以相对容易出错；</p>
<h1 id="-more-volatile变量"><!-- more --><br>
volatile变量</h1>
<p>volitile关键字用来修饰字段，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性；<br>
通过同步锁实现volatile效果示例理解：</p>
<pre><code class="language-java">class VolatileFeaturesExample {
	volatile long vl = 0L;
	public void set(long vl) {
		this.vl = vl;
	}
	public void getAndIncrement() {
		vl ++;
	}
	public long get() {
		return vl;
	}
}
class VolatileFeaturesExample {
	long vl = 0L;
	public synchronized void set(long vl) {
		this.vl = vl;
	}
	public void getAndIncrement() {
		long temp = get();
		temp += 1L;
		set(temp);
	}
	public synchronized long get() {
		return vl;
	}
}
</code></pre>
<h1 id="正确使用volatile变量的条件">正确使用volatile变量的条件</h1>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ul>
<p>综上所述：被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<h1 id="使用volatile关键字的场景">使用volatile关键字的场景</h1>
<h2 id="状态标记量">状态标记量</h2>
<pre><code class="language-java">volatile boolean flag;
public void setFlag(boolean flag) {
	this.flag = flag;
}
public void doWork() {
	while (!flag) {
		// do stuff
	}
}
</code></pre>
<h2 id="一次性安全发布">一次性安全发布</h2>
<p>在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。<br>
实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。示例清单如下：</p>
<pre><code class="language-java">class Singleton {
	private volatile static Singleton instance = null;
	private Singleton() { }
	public static Singleton getInstance() {
		if (null == instance) {
			synchronized (Singleton.class) {
				if (null == instance) 
					instance = new Singleton();
			}
		}
		return instance;
	}
}
</code></pre>
<p>这里为什么需要instance变量使用volatile关键字修饰，因为变量的创建分为两步：</p>
<ul>
<li>1、分配对象的内存空间</li>
<li>2、初始化对象</li>
<li>3、设置变量指向内存地址<br>
然而在一些JIT编译器上，上述流程中的2、3步可能会被重排序。<br>
根据Java语言规范，所有线程在执行Java程序时必须要遵守intra-thread semantics。<br>
intra-thread semantics 保证重排序不会改变单线程内的程序执行过程。换句话说，intra-thread semantics 允许哪些在单线程内，不会改变单线程程序执行结果的重排序。故上述流程的2和3之间虽然重排序了，但这个重排序不会违反intra-thread semantics 。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</li>
</ul>
<h2 id="开销较低的读-写锁策略">开销较低的读－写锁策略</h2>
<p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。<br>
然而，如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。代码清单如下：</p>
<pre><code class="language-java">class CheeysCounter {
	private volatile int value;
	public int getValue() {
		return value;
	}
	public synchronized int increment() {
		return value ++;
	}
}
</code></pre>
<p>因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器，所以必须使用锁。<br>
故可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。</p>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Gallen
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://imarkofu.github.io/post/java-volatile/" title="java volatile 关键字理解">https://imarkofu.github.io/post/java-volatile/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://imarkofu.github.io/tag/Cl0XnUa_Cdl/"># Java</a>
    
      <a href="https://imarkofu.github.io/tag/4yySEk_D-Kb/"># 同步机制</a>
    
      <a href="https://imarkofu.github.io/tag/N0k2_CQy8le/"># volatile关键字</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="java 单例模式" href="https://imarkofu.github.io/post/java-singleton/">java 单例模式</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="java 单例模式" href="https://imarkofu.github.io/post/java-singleton/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="批量删除Maven下载失败的文件夹" href="https://imarkofu.github.io/post/delete-maven-failure-jar/">批量删除Maven下载失败的文件夹</a>
        <a class="nav-mobile-next" title="批量删除Maven下载失败的文件夹" href="https://imarkofu.github.io/post/delete-maven-failure-jar/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'QhQ5bWwlgX3eklhFvc4nbaAb-gzGzoHsz',
    appKey: 'AMHb4keDrEUWxjRvsLBxL8d3',
    avatar: 'mp',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-5-7-34-winx64-install/"" data-c="
          &lt;h2 id=&#34;下载&#34;&gt;下载&lt;/h2&gt;
&lt;p&gt;官网[ https://dev.mysql.com/downloads/mysql/5.7.html ]下载mysql5.7.34，选择zip；&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imarkofu.github.io/post-images/1624116256763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imarkofu.github.io/post-images/1624116526129.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;解压配置&#34;&gt;解压配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;解压到[C:\Program Files\mysql]目录&lt;/li&gt;
&lt;li&gt;建立data文件夹&lt;/li&gt;
&lt;li&gt;新建my.ini文件&lt;br&gt;
&lt;img src=&#34;https://imarkofu.github.io/post-images/1624116734018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
my.ini文件内容如下&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[mysqld]
#设置3306端口
port = 3306
# 设置mysql的安装目录
basedir=C:\\Program Files\\mysql\\mysql-5.7.34-winx64
datadir=C:\\Program Files\\mysql\\mysql-5.7.34-winx64\\data
# 允许最大连接数
max_connections=200
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
innodb_flush_method=normal
 
[client]
#设置3306端口
port = 3306
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装并初始化&#34;&gt;安装并初始化&lt;/h2&gt;
&lt;p&gt;管理员身份打开cmd，进入[C:\Program Files\mysql\mysql-5.7.34-winx64\bin]目录；执行以下指令&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mysqld --install，生成mysql实例，打开服务：&lt;br&gt;
执行如下命令：net start MySQL&lt;br&gt;
或到电脑服务列表中找到MySQL服务，并启动&lt;br&gt;
&lt;img src=&#34;https://imarkofu.github.io/post-images/1624117086839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;mysqld --initialize --user=mysql --console，此时终端显示随机密码，需要记住，后面会使用到：&lt;br&gt;
&lt;img src=&#34;https://imarkofu.github.io/post-images/1624117374482.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;修改mysql密码：输入命令行mysql -uroot -p，输入临时密码即可登录数据库成功&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">mysql-5.7.34-winx64安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/debian-switch-source/"" data-c="
          &lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;
&lt;p&gt;debian操作系统，apt-get update 报错，采用更换源的方式解决问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;E: Release file for http://deb.debian.org/debian/dists/buster-updates/InRelease is not valid yet (invalid for another 7h 27min 25s). Updates for this repository will not be applied.
E: Release file for http://security.debian.org/debian-security/dists/buster/updates/InRelease is not valid yet (invalid for another 1h 35min 41s). Updates for this repository will not be applied.
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;p&gt;尝试更换源来解决，将 sources.list 文件复制到 /etc/apt/sources.list 下，更新即可。&lt;/p&gt;
&lt;h3 id=&#34;阿里云源&#34;&gt;阿里云源&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib
deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib
deb http://mirrors.aliyun.com/debian-security buster/updates main
deb-src http://mirrors.aliyun.com/debian-security buster/updates main
deb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib
deb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib
deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib
deb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;清华源&#34;&gt;清华源&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker示例&#34;&gt;Docker示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;amp;&amp;amp; \
    echo &amp;quot;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib&amp;quot; &amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb http://mirrors.aliyun.com/debian-security buster/updates main&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian-security buster/updates main&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list

RUN apt-get clean &amp;amp;&amp;amp; \
    apt-get update &amp;amp;&amp;amp; \
    apt-get install -y --no-install-recommends curl procps telnet net-tools &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/*
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意&lt;/h2&gt;
&lt;p&gt;不管是阿里云的源还是清华的源，http和https均可以，自行斟酌即可；&lt;br&gt;
如果遇到无法拉取 https 源的情况，请先使用 http 源并安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt install apt-transport-https ca-certificates
&lt;/code&gt;&lt;/pre&gt;
">Debian 官方源换为国内的源的操作方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/spring-boot-allowed-origins/"" data-c="
          &lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;
&lt;p&gt;目前应用开发前后端分离是大趋势，故而前后端部署在不同的两个域也是大概率事件，那么势必需要解决跨域请求的问题。&lt;/p&gt;
&lt;p&gt;本文描述spring-boot项目中如何解决请求跨域的三种解决方案，以及升级spring-boot 2.4后的跨域问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;h3 id=&#34;方案一&#34;&gt;方案一&lt;/h3&gt;
&lt;p&gt;通过实现WebMvcConfigurer接口的addCorsMappings方法解决跨域问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class WebMvcConfiguration implements WebMvcConfigurer {

	@Override
    public void addCorsMappings(CorsRegistry registry) {
        // 所有的当前站点的请求地址，都支持跨域访问。
        registry.addMapping(&amp;quot;/**&amp;quot;)
                // 所有的外部域都可跨域访问
                .allowedOrigins(&amp;quot;*&amp;quot;)
                // 是否支持跨域用户凭证
                .allowCredentials(true)
                // 当前站点支持的跨域请求类型是什么
                .allowedMethods(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;PUT&amp;quot;, &amp;quot;DELETE&amp;quot;)
                .maxAge(3600);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方案二&#34;&gt;方案二&lt;/h3&gt;
&lt;p&gt;使用@CrossOrigin注解实现跨域&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@CrossOrigin(origins = &amp;quot;*&amp;quot;, maxAge = 3600)
public class TestController {
    
    @GetMapping(&amp;quot;/test&amp;quot;)
    public ApiResult&amp;lt;String&amp;gt; test() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方案三&#34;&gt;方案三&lt;/h3&gt;
&lt;p&gt;使用Filter实现跨域&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@ConditionalOnProperty(name = &amp;quot;manage.api.cors&amp;quot;, havingValue = &amp;quot;true&amp;quot;)
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin(&amp;quot;*&amp;quot;);
        config.addAllowedHeader(&amp;quot;*&amp;quot;);
        config.addAllowedMethod(&amp;quot;*&amp;quot;);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&amp;quot;/**&amp;quot;, config);
        return new CorsFilter(source);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意&lt;/h2&gt;
&lt;p&gt;spring-boot升级到2.4版本以后，使用如下方案时会抛一下异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value &amp;quot;*&amp;quot; since that cannot be set on the &amp;quot;Access-Control-Allow-Origin&amp;quot; response header. To allow credentials to a set of origins, list them explicitly or consider using &amp;quot;allowedOriginPatterns&amp;quot; instead.

// 解决方法提示内容中也有香惜的说明
// 当allowCredentials设置为&#39;true&#39;时，allowedOrigins不能包含特殊值&#39;*&#39;
// 可以考虑使用allowedOriginPatterns代替

&lt;/code&gt;&lt;/pre&gt;
">spring boot跨域问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/maven-compiler-image-api-not-exist/"" data-c="
          &lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;
&lt;p&gt;maven编译项目提示&lt;br&gt;
程序包com.sun.image.codec.jpeg不存在&lt;br&gt;
然后这个类位于：jre/lib/rt.jar&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;h3 id=&#34;方案一&#34;&gt;方案一&lt;/h3&gt;
&lt;p&gt;java_home下面的lib/dt.jar中没有这个文件，导致编译失败。&lt;br&gt;
通过配置maven-compiler-plugin插件可以解决此问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;source&amp;gt;${maven.compiler.source}&amp;lt;/source&amp;gt;
                &amp;lt;target&amp;gt;${maven.compiler.target}&amp;lt;/target&amp;gt;
                &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                &amp;lt;compilerArguments&amp;gt;
                    &amp;lt;verbose /&amp;gt;
                    &amp;lt;bootclasspath&amp;gt;${java.home}/lib/rt.jar;${java.home}/lib/jce.jar&amp;lt;/bootclasspath&amp;gt;
                &amp;lt;/compilerArguments&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺陷：在windows下面用&#39;;&#39;分隔，linux下面用&#39;:&#39;分隔。&lt;/p&gt;
&lt;h3 id=&#34;方案二&#34;&gt;方案二&lt;/h3&gt;
&lt;p&gt;更换API&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;JPEGImageEncoder en = JPEGCodec.createJPEGEncoder(os);
en.encode(targetImage);

// 更换为
ImageIO.write(targetImage, &amp;quot;jpg&amp;quot;, os);
&lt;/code&gt;&lt;/pre&gt;
">maven项目编译：程序包com.sun.image.codec.jpeg不存在</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/git-bash-filename-too-long/"" data-c="
          &lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;
&lt;p&gt;从github克隆一个项目下发出现了错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cglong@cglong MINGW64 /c/Tools/workspace/idea/open
$ git clone git@github.com:imarkofu/shenyu.git
Cloning into &#39;shenyu&#39;...
Warning: Permanently added the RSA host key for IP address &#39;52.192.72.89&#39; to the list of known hosts.
remote: Enumerating objects: 53479, done.
remote: Counting objects: 100% (15170/15170), done.
remote: Compressing objects: 100% (4534/4534), done.
remote: Total 53479 (delta 4593), reused 14765 (delta 4365), pack-reused 38309
Receiving objects: 100% (53479/53479), 20.72 MiB | 128.00 KiB/s, done.
Resolving deltas: 100% (17773/17773), done.
error: unable to create file shenyu-spring-boot-starter/shenyu-spring-boot-starter-sync-data-center/shenyu-spring-boot-starter-sync-data-websocket/src/main/java/org/apache/shenyu/springboot/starter/sync/data/websocket/WebsocketSyncDataConfiguration.java: Filename too long
error: unable to create file shenyu-spring-boot-starter/shenyu-spring-boot-starter-sync-data-center/shenyu-spring-boot-starter-sync-data-websocket/src/test/java/org/apache/shenyu/springboot/starter/sync/data/websocket/WebsocketSyncDataConfigurationTest.java: Filename too long
Checking out files: 100% (1439/1439), done.
fatal: unable to checkout working tree
warning: Clone succeeded, but checkout failed.
You can inspect what was checked out with &#39;git status&#39;
and retry the checkout with &#39;git checkout -f HEAD&#39;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git可以创建4096长度的路径，然而Windows 默认不支持文件名或目录名长于260个字符，所以Git的Windows客户端默认是禁用长名称支持的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.longpaths true

&lt;/code&gt;&lt;/pre&gt;
">git bash下的Filename too long</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/CentOS-install-python3/"" data-c="
          &lt;p&gt;准备编译环境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install zlib-devel bzip2-devel openssl-devel ncurses-devel xz gcc-c++ gcc libffi-devel -y

&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;下载并解压&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz
tar xf Python-3.7.3.tar.xz -C /usr/local/src/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/src/Python-3.7.3
./configure --prefix=/usr/local/python3 --with-ssl --enable-optimizations
make -j 4 &amp;amp;&amp;amp; make install

最终提示如下，表示pip-9.0.1与setuptools-28.8.0同时安装成功
if test &amp;quot;x&amp;quot; != &amp;quot;x&amp;quot; ; then \
                rm -f /usr/local/python3/bin/python3-32; \
                (cd /usr/local/python3/bin; ln -s python3.7-32 python3-32) \
        fi
rm -f /usr/local/python3/share/man/man1/python3.1
(cd /usr/local/python3/share/man/man1; ln -s python3.7.1 python3.1)
if test &amp;quot;xupgrade&amp;quot; != &amp;quot;xno&amp;quot;  ; then \
                case upgrade in \
                        upgrade) ensurepip=&amp;quot;--upgrade&amp;quot; ;; \
                        install|*) ensurepip=&amp;quot;&amp;quot; ;; \
                esac; \
                 ./python -E -m ensurepip \
                        $ensurepip --root=/ ; \
        fi
Looking in links: /tmp/tmpnffpnbr9
Collecting setuptools
Collecting pip
Installing collected packages: setuptools, pip
Successfully installed pip-19.0.3 setuptools-40.8.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立软连接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ln -s /usr/local/python3/bin/python3.7 /usr/local/bin/python3 
ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;升级到最新的pip&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install --upgrade pip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改默认的Python&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv /usr/bin/python /usr/bin/python_bak
ln -s /usr/local/python3/bin/python3.7 /usr/bin/python

# 验证
python -V


&lt;/code&gt;&lt;/pre&gt;
">CentOS6编译安装Python3.7</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/CentOS-ekho-TTS/"" data-c="
          &lt;p&gt;Ekho（余音）是一个免费、开源的中文语音合成软件。它目前支持粤语、普通话（国语）、广东台山话、诏安客语、藏语、雅言（中国古代通用语）和韩语（试验中），英语则通过eSpeak或Festival间接实现。Ekho支持Linux、Windows和Android平台。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;源码下载页面：&lt;a href=&#34;https://sourceforge.net/projects/e-guidedog/files/Ekho/&#34; title=&#34;ekho源码下载&#34;&gt;ekho&lt;/a&gt;.&lt;br&gt;
项目主页：&lt;a href=&#34;http://www.eguidedog.net/ekho.php&#34; title=&#34;ekho主页&#34;&gt;ekho&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编译安装基于CentOS 6.10&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 添加 SCL 和 EPEL 软件仓库
yum install centos-release-scl epel-release

# 安装 GCC 5 和编译 ekho 的开发库
yum install devtoolset-6-gcc* libsndfile-devel.x86_64 pulseaudio-libs-devel.x86_64 ncurses-devel.x86_64 espeak-devel.x86_64 lame-devel.x86_64

# 使用 SCL 启动 shell 
scl enable devtoolset-6 bash

# 验证 GCC 版本 
# which gcc
# gcc --version

# [可选] 设置 GCC 编译器选项
export CFLAGS=&#39;-O2 -g -pipe -Wall -fexceptions -fno-strict-aliasing -fstack-protector -m64 -mtune=generic -fPIC&#39;

# 生成 MakeFile，编译，安装 
./configure --prefix=/opt/app/ekho &amp;amp;&amp;amp; make -j 8 &amp;amp;&amp;amp; make install

# 设置 ekho 相关环境变量 
cat &amp;gt; /etc/profile.d/ekho_env.sh &amp;lt;&amp;lt; EOF
#!/bin/bash
export PATH=\${PATH}:/opt/app/ekho/bin
export EKHO_DATA_PATH=/opt/app/ekho/share/ekho-data/
EOF

# 退出 SCL shell 
exit 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更换音频文件参考：&lt;a href=&#34;http://cto.eguidedog.net/node/809&#34; title=&#34;怎样替换Ekho的语音文件&#34;&gt;怎样替换Ekho的语音文件&lt;/a&gt;&lt;br&gt;
制作和添加新的语音声音参考：&lt;a href=&#34;http://www.eguidedog.net/doc/doc_make_new_voice_cn.php&#34; title=&#34;如何为Ekho添加新的声音&#34;&gt;如何为Ekho添加新的声音&lt;/a&gt;&lt;/p&gt;
">ekho中文TTS CentOS6编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-dynamic-programming/"" data-c="
          &lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划常常适用于&lt;strong&gt;有重叠子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构性质&lt;/strong&gt;的问题，动态规划方法所耗时间往往远少于朴素解法。&lt;/p&gt;
&lt;p&gt;动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。&lt;/p&gt;
&lt;p&gt;通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。&lt;/p&gt;
&lt;h1 id=&#34;-more-适用情况&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
适用情况&lt;/h1&gt;
&lt;p&gt;**最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。&lt;br&gt;
**无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。&lt;br&gt;
**子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。&lt;/p&gt;
&lt;h1 id=&#34;实例&#34;&gt;实例&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;求解的关键：第一步找到问题的“状态”， 第二步找到“状态转移方程”&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;示例一&#34;&gt;示例一&lt;/h2&gt;
&lt;p&gt;一个序列有N个数：A[1],A[2],…,A[N]，求出最长上升子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)&lt;/p&gt;
&lt;p&gt;示例：5，3，4，8，6，7&lt;br&gt;
**前1个数的LIS长度d(1)=1(序列：5)&lt;br&gt;
**前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)&lt;br&gt;
**前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)&lt;br&gt;
**前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)&lt;/p&gt;
&lt;p&gt;状态转移方程&lt;br&gt;
dp[i]=max{dp[j]}+1，j=[0,i-1]且a[j]&amp;lt;a[i]&lt;br&gt;
即为：到第i个元素的最长上升子序列=第0到i-1的元素的最长上升子序列+1&lt;br&gt;
时间复杂度=O(n^2)&lt;/p&gt;
&lt;p&gt;这个问题还有另一种更优化的解法，时间复杂度为O(nlog(n))&lt;br&gt;
参考：https://leetcode.com/problems/longest-increasing-subsequence/&lt;/p&gt;
&lt;h2 id=&#34;示例二&#34;&gt;示例二&lt;/h2&gt;
&lt;p&gt;平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始走到右下角， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。&lt;/p&gt;
&lt;p&gt;这个状态转移方程应该会更好理解&lt;br&gt;
dp[i][j]=A[i][j]+max(dp[i+1][j], dp[i][j+1])，当然这里没有将边界问题考虑进来，实际编程中需要注意。&lt;/p&gt;
&lt;p&gt;即为：从第i,j位置到走到左下角能收集的最大苹果数量=当前格子内苹果数量+向右走或向下走的两种方式的最大值&lt;/p&gt;
">算法学习-动态规划</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-greedy-algorithm/"" data-c="
          &lt;p&gt;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。&lt;/p&gt;
&lt;p&gt;贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。&lt;/p&gt;
&lt;p&gt;所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;基本思路&#34;&gt;基本思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;建立数学模型来描述问题。&lt;/li&gt;
&lt;li&gt;把求解的问题分成若干个子问题。&lt;/li&gt;
&lt;li&gt;对每一子问题求解，得到子问题的局部最优解。&lt;/li&gt;
&lt;li&gt;把子问题的解局部最优解合成原来解问题的一个解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;适用的问题&#34;&gt;适用的问题&lt;/h2&gt;
&lt;p&gt;前提：局部最优策略能导致产生全局最优解。&lt;/p&gt;
&lt;p&gt;贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。&lt;br&gt;
因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。&lt;br&gt;
示例参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/&lt;/p&gt;
">算法学习-贪心算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-recursion-and-division/"" data-c="
          &lt;h1 id=&#34;递归&#34;&gt;递归&lt;/h1&gt;
&lt;p&gt;直接或者间接不断反复调用自身来达到解决问题的方法。要求原始问题可以分解为相同问题的子问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先决条件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归边界&lt;/li&gt;
&lt;li&gt;自身调用&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;br&gt;
思路简单清晰，如果分析出将很快得到结果;递归将多次调用，使用到堆栈，算法效率低，费时费内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶乘&lt;/li&gt;
&lt;li&gt;斐波纳契数列&lt;/li&gt;
&lt;li&gt;汉诺塔问题&lt;/li&gt;
&lt;li&gt;整数划分&lt;/li&gt;
&lt;li&gt;枚举排列及二叉树&lt;/li&gt;
&lt;li&gt;图的搜索相关问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分治&#34;&gt;分治&lt;/h1&gt;
&lt;p&gt;把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;br&gt;
将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;br&gt;
对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题的规模缩小到一定的程度就可以容易地解决&lt;/li&gt;
&lt;li&gt;问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质&lt;/li&gt;
&lt;li&gt;问题分解出的子问题的解可以合并为该问题的解&lt;/li&gt;
&lt;li&gt;问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本操作步骤&lt;/strong&gt;&lt;br&gt;
分治法在每一层递归上都有三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题&lt;/li&gt;
&lt;li&gt;解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题&lt;/li&gt;
&lt;li&gt;合并：将各个子问题的解合并为原问题的解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二分搜索&lt;/li&gt;
&lt;li&gt;大整数乘法&lt;/li&gt;
&lt;li&gt;Strassen矩阵乘法&lt;/li&gt;
&lt;li&gt;棋盘覆盖&lt;/li&gt;
&lt;li&gt;合并排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;线性时间选择&lt;/li&gt;
&lt;li&gt;最接近点对问题&lt;/li&gt;
&lt;li&gt;循环赛日程表&lt;/li&gt;
&lt;li&gt;汉诺塔&lt;/li&gt;
&lt;/ul&gt;
">算法学习-递归和分治</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-tree/"" data-c="
          &lt;h1 id=&#34;树&#34;&gt;树&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;树(Tree)是元素的集合，每棵树由多个节点（node）组成，用以储存元素。某些节点之间存在着一定的关系，用连线表示，连线称为边（edge）或者链接。边的上端点成为父节点，下端称为子节点。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;/images/tree01.png&#34; alt=&#34;tree&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
每个节点可以有多个子节点，而该节点则是相应子节点的父节点。但是每个节点只能有一个父节点（只有一个例外，也就是根节点，它没有父节点），如图中第一棵树的 S 节点即为根节点。而没有子节点的节点则称为叶子节点或叶节点，如上图中第一棵树的 A、R、X 节点。E、X 的父节点是一个节点，所以它们被称为兄弟节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树是元素的集合&lt;/li&gt;
&lt;li&gt;该集合可以为空。此时树中没有元素，称之为空树（empty tree）。&lt;/li&gt;
&lt;li&gt;如果该集合不为空，那么该集合至少含有一个根节点以及 0 个或多个子树。根节点与它的子树的根节点用一个边（edge）或链接相连。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;特征&#34;&gt;特征&lt;/h2&gt;
&lt;p&gt;高度（Height）、深度（Depth）、层（Level）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的高度 = 节点到叶子结点的最长路径（边数）&lt;/li&gt;
&lt;li&gt;节点的深度 = 根节点到这个节点所经历的边的个数&lt;/li&gt;
&lt;li&gt;节点的层数 = 节点的深度 + 1&lt;/li&gt;
&lt;li&gt;树的高度 = 根节点的高度&lt;br&gt;
&lt;img src=&#34;/images/tree02.png&#34; alt=&#34;tree&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二叉树&#34;&gt;二叉树&lt;/h1&gt;
&lt;h2 id=&#34;定义-2&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;二叉树是一种特殊的数据结构，顾名思义，二叉树只有两个叉，也就是两个子节点：左子节点和右子节点。其中，左子节点是左子树的根节点，右子节点是右子树的根节点。当然，这并不是说，二叉树一定要求每个节点都必须有两个子节点，有的节点只有左子节点，而有的节点只有右子节点。&lt;/p&gt;
&lt;h2 id=&#34;二叉树的三种遍历方法&#34;&gt;二叉树的三种遍历方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历（也叫先序遍历）：若二叉树为空，则空操作，否则，对于二叉树中的任意节点，先访问这个节点，然后再访问它的左子树，最后打印它的右子树。&lt;/li&gt;
&lt;li&gt;中序遍历：若二叉树为空，则空操作，否则，对于二叉树中的任意节点，先访问它的左子树，然后再访问这个节点本身，最后访问它的右子树。&lt;/li&gt;
&lt;li&gt;后序遍历：若二叉树为空，则空操作，否则，对于二叉树中的任意节点，先访问它的左子树，然后访问它的右子树，最后访问这个节点本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /** 先序递归遍历 */
    void DLR(BiTree bt) {
        if (null != bt) {
            System.out.println(bt.data);
            DLR(bt.lchild);
            DLR(bt.rchild);
        }
    }
    /** 中序递归遍历 */
    void LDR(BiTree bt) {
        if (null != bt) {
            LDR(bt.lchild);
            System.out.println(bt.data);
            LDR(bt.rchild);
        }
    }
    /** 后序递归遍历 */
    void LRD(BiTree bt) {
        if (null != bt) {
            LRD(bt.lchild);
            LRD(bt.rchild);
            System.out.println(bt.data);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;树与二叉树的区别&#34;&gt;树与二叉树的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;二叉树的每个节点最多只能有两个节点，而树则无限制&lt;/li&gt;
&lt;li&gt;二叉树中节点的子树分为左子树和右子树，即使某个节点只有一棵树，也必须要指明这棵树是左子树还是右子树，也就是说，二叉树是有序的&lt;/li&gt;
&lt;li&gt;树不能为空，至少含有一个节点，而一棵二叉树可以为空&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h1&gt;
&lt;h2 id=&#34;定义-3&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;二叉查找树（Binary Search Tree，BST）是一种特殊的二叉树，一棵二叉搜索树（BST）是一棵二叉树，其中，每个节点的值都要大于其左子树中任意节点的值而小于右子树中任意节点的值。&lt;/p&gt;
&lt;h2 id=&#34;特征-2&#34;&gt;特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若它的左子树不为空，那么左子树上所有节点的key都小于根节点的key。&lt;/li&gt;
&lt;li&gt;若它的右子树不为空，那么右子树上所有节点的key都大于根节点的key。&lt;/li&gt;
&lt;li&gt;它的左右子树也分别为二叉排序树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果二叉查找树为空，则返回空操作，否则，执行一下操作；&lt;/li&gt;
&lt;li&gt;先取根节点，如果节点 X 等于根节点，则返回；&lt;/li&gt;
&lt;li&gt;如果节点小于根节点，则递归查找左子树；&lt;/li&gt;
&lt;li&gt;如果节点大于根节点，则递归查找右子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插入&#34;&gt;插入&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果树是空的，则直接将新节点插入，否则，执行下面步骤。&lt;/li&gt;
&lt;li&gt;要插入的数据比根节点数据大，则到右子树中插入新数据，如果右子树为空，则将新数据直接插入到右子节点的位置；不为空，则继续遍历右子树，查找插入位置。&lt;/li&gt;
&lt;li&gt;要插入的数据比根节点数据小，则到左子树中插入数据，如果左子树为空，则直接将新数据插入到左子节点的位置；不为空，则继续遍历左子树，查找插入的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;删除&#34;&gt;删除&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一种情况，如果要删除的节点没有子节点，直接将父节点指向要删除节点的指针指向 null。比如途中要删除的节点 55。&lt;/li&gt;
&lt;li&gt;第二种情况，如果要删除的节点只有一个节点，即只有左子节点或右子节点，则将父节点指向要删除节点的指针指向要删除节点的子节点即可。比如途中要删除的节点&lt;/li&gt;
&lt;li&gt;第三种情况，如果要删除的节点有两个子节点，则需要先找到这个节点右子树中的最小节点或者左子树中的最大节点，将其替换到要删除的节点上。然后删除这个右子树中的最小节点或左子树中的最大节点，这样就可以利用&lt;br&gt;
1、2 两条规则来删除了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查找最大-最小节点&#34;&gt;查找最大、最小节点&lt;/h2&gt;
&lt;p&gt;查找最大、最小节点比较简单，比如要查找二叉查找树的最大节点时，如果二叉查找树为空，则返回空操作，如果不为空，则判断是否只有一个节点（即只有根节点），如果是则返回根节点，否则到右子树中递归查找。同理，查找最小节点类似，只是到左子树中查找而已。&lt;/p&gt;
">算法学些-树、二叉树、二叉搜索树</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-hash-table/"" data-c="
          &lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;
&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。它通过把关键码映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数（哈希函数），存放记录的数组叫做散列表。&lt;/p&gt;
&lt;h1 id=&#34;-more-优缺点&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
优缺点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;优点：哈希表可以提供快速的操作。&lt;/li&gt;
&lt;li&gt;缺点：哈希表通常是基于数组的，数组创建后难于扩展。&lt;br&gt;
也没有一种简便的方法可以以任何一种顺序〔例如从小到大）遍历表中的数据项。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。&lt;/p&gt;
&lt;h1 id=&#34;哈希查找&#34;&gt;哈希查找&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用哈希函数将被查找的键转换为数组的索引。&lt;/li&gt;
&lt;li&gt;处理哈希碰撞冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;散列函数&#34;&gt;散列函数&lt;/h1&gt;
&lt;p&gt;若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。&lt;/p&gt;
&lt;p&gt;若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数(Uniform Hash function)，这就是使关键字经过散列函数得到一个&amp;quot;随机的地址&amp;quot;，从而减少碰撞。&lt;/p&gt;
&lt;p&gt;散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。&lt;/p&gt;
&lt;p&gt;一个好的散列函数一般应该考虑下列因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算简单，以便提高转换速度。&lt;/li&gt;
&lt;li&gt;关键词对应的地址空间分布均匀，以尽量减少冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;常见的散列函数&#34;&gt;常见的散列函数&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;直接定址法：取关键字key的某个线性函数为散列地址，如Hash(key) = key  或 Hash(key) = A*key+B；A,B为常数&lt;/li&gt;
&lt;li&gt;除留取余法：关键值除以比散列表长度小的素数所得的余数作为散列地址。Hash(key) = key % p;&lt;/li&gt;
&lt;li&gt;平均取中法：先计算构成关键码的标识符的内码的平方，然后按照散列表的大小取中间的若干位作为散列地址。&lt;/li&gt;
&lt;li&gt;折叠法：把关键码自左到右分为位数相等的几部分，每一部分的位数应与散列表地址位数相同，只有最后一部分的位数可以短一些。把这些部分的数据叠加起来，就可以得到具有关键码的记录的散列地址。分为移位法和分界法。&lt;/li&gt;
&lt;li&gt;随机数法：选择一个随机函数，取关键字的随机函数作为它的哈希地址。&lt;/li&gt;
&lt;li&gt;数学分析法：设有N个d位数，每一位可能有r种不同的符号。这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种符号出现的机会均等；在某些位上分布不均匀，只有某几种符号经常出现。可根据散列表的大小，选取其中各种符号分布均匀的若干位作为散列地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;处理冲突&#34;&gt;处理冲突&lt;/h1&gt;
&lt;p&gt;对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为碰撞(英语:Collision)。具有相同函数值的关键字对该散列函数来说称做同义词。&lt;/p&gt;
&lt;p&gt;通过构造性能良好的散列函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。&lt;/p&gt;
&lt;h2 id=&#34;开放定址法&#34;&gt;开放定址法&lt;/h2&gt;
&lt;p&gt;这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H(key)出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：Hi=(H(key)+di)%m   i=1，2，…，m-1,其中H（key）为哈希函数，m 为表长，di称为增量序列，i为碰撞次数。增量序列的取值方式不同，相应的再散列方式也不同。增量序列主要有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性探测再散列&lt;/strong&gt;&lt;br&gt;
di=1，2，3，…，m-1&lt;br&gt;
这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二次探测再散列&lt;/strong&gt;&lt;br&gt;
di=12，-12，22，-22，…，k2，-k2( k&amp;lt;=m/2 )&lt;br&gt;
这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;伪随机探测再散列&lt;/strong&gt;&lt;br&gt;
di=伪随机数序列。&lt;br&gt;
线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定。线性探测再散列容易产生“二次聚集”，即在处理同义词的冲突时又导致非同义词的冲突。&lt;/p&gt;
&lt;h2 id=&#34;再哈希法&#34;&gt;再哈希法&lt;/h2&gt;
&lt;p&gt;这种方法是同时构造多个不同的哈希函数：Hi=RHi（key），i=1，2,3，…,n。&lt;br&gt;
当哈希地址H1=RH1（key）发生冲突时，再计算H2=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。&lt;/p&gt;
&lt;h2 id=&#34;链地址法拉链法&#34;&gt;链地址法(拉链法)&lt;/h2&gt;
&lt;p&gt;这种方法的基本思想是将所有哈希地址相同的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表（数组）中，因而查找、插入和删除主要在同义词链中进行。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。链地址法适用于经常进行插入和删除的情况。&lt;/p&gt;
&lt;p&gt;与开放定址法相比，拉链法有如下几个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；&lt;/li&gt;
&lt;li&gt;由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；&lt;/li&gt;
&lt;li&gt;开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中理论上可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；（散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度）&lt;/li&gt;
&lt;li&gt;在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放定址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径。这是因为各种开放定址法中，空地址单元都被理解没有查找到元素。 因此在用开放定址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拉链法的缺点&lt;br&gt;
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，此时将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。&lt;/p&gt;
&lt;h2 id=&#34;建立公共溢出区&#34;&gt;建立公共溢出区&lt;/h2&gt;
&lt;p&gt;将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表(在这个方法里面是把元素分开两个表来存储)。&lt;/p&gt;
&lt;h1 id=&#34;查找性能&#34;&gt;查找性能&lt;/h1&gt;
&lt;p&gt;散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。&lt;/p&gt;
&lt;p&gt;查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;影响产生冲突多少有以下三个因素:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;散列函数是否均匀;&lt;/li&gt;
&lt;li&gt;处理冲突的方法;&lt;/li&gt;
&lt;li&gt;散列表的装填因子。&lt;/li&gt;
&lt;/ul&gt;
">算法学习-哈希表</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-priority-queue/"" data-c="
          &lt;p&gt;普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。&lt;/p&gt;
&lt;h1 id=&#34;-more-实现机制&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
实现机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Heap(Binary, Binomial, Fibonacci)&lt;/li&gt;
&lt;li&gt;Binary Search Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各种堆的时间复杂堆参考：https://en.wikipedia.org/wiki/Heap_(data_structure)&lt;br&gt;
&lt;img src=&#34;/images/heap01.png&#34; alt=&#34;各种堆的时间复杂度&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">算法学习-优先队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-stack-and-queue/"" data-c="
          &lt;p&gt;栈和队列都是动态集合，可以理解为线性表或线性表实现的数据结构。它可以由数组实现，也可以由链表实现。&lt;br&gt;
和数组链表等不一样的是，栈、队列添加、删除数据的位置都是预先设定的。在栈中，被删除的是最近被插入的元素，栈实现的是一种先进后出的策略。而队列中，被删去的总是在集合中存在时间最长的元素，队列实现的是一种先进先出的策略。&lt;br&gt;
栈和队列是非常有用的数据结构，在计算机中很多的地方使用了栈、队列的思想。函数执行的压栈及出栈，消息队列的使用等等。本文最后将介绍栈和队列的常见使用场景，递归转化。&lt;/p&gt;
&lt;h1 id=&#34;-more-堆栈&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
堆栈&lt;/h1&gt;
&lt;p&gt;一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。不含任何元素的栈称为空栈，栈又称为后进先出的线性表。&lt;br&gt;
&lt;img src=&#34;/images/stack01.jpeg&#34; alt=&#34;堆栈&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;队列&#34;&gt;队列&lt;/h1&gt;
&lt;p&gt;只允许在一端进行插入数据操作，在另一端进行删除操作的特殊线性表。插入的叫队尾，删除的叫队头，对列具有先进先出的特性。&lt;br&gt;
&lt;img src=&#34;/images/queue01.jpeg&#34; alt=&#34;队列&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;时间复杂度对比参考：http://www.bigocheatsheet.com/&lt;br&gt;
&lt;img src=&#34;/images/bigocheatsheet.png&#34; alt=&#34;时间复杂度对比&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">算法学习-堆栈和队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/algorithm-array-and-linkedlist/"" data-c="
          &lt;p&gt;数组和链表是数据结构中最基本的部分，也是其余众多数据结构的基础。即使在Java中，这两种结构使用的也很普遍。&lt;/p&gt;
&lt;h1 id=&#34;-more-数组&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
数组&lt;/h1&gt;
&lt;p&gt;在java中，数组定义为一种基本类型，其可以通过下标获取到对应位置的数据。那么这种结构的数据，在内存中是怎么存放的呢？&lt;br&gt;
&lt;img src=&#34;/images/array01.png&#34; alt=&#34;array01&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
正如上图所示，数组在内存中是一段连续的存储单元，每个数据依次放在每个单元中。分析这种结构，我们可以得出以下几个结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个数组，必须声明其长度，以在内存中寻找合适的一段连续存储单元。这也意味着数组的大小是固定的，我们无法动态调整其大小。&lt;/li&gt;
&lt;li&gt;想要获取数组中第i个元素，其时间复杂度是 O(1)，因为可以根据其地址直接找到它。同理修改也是。&lt;/li&gt;
&lt;li&gt;数组对查询表现一般，要想查找一个元素，需要遍历，时间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;因为地址连续，想要在数组中插入一个元素是复杂的，因为从插入位置起，后边的所有元素都需要向后移动一位。同理删除也是，只是移动方向为向前。并且，当数组存满时，就无法继续插入了。&lt;/li&gt;
&lt;li&gt;因为数组要占据一整块内存，有可能产生许多的碎片，也可能因为找不到合适的内存块，而导致存储失败。&lt;br&gt;
故：数组大小固定，查找迅速，增删复杂，需要完整的内存块，容易产生碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;链表&#34;&gt;链表&lt;/h1&gt;
&lt;p&gt;链表是一种离散存储结构，其在内存中存储不是连续的，每个数据元素都通过一个指针指向其下一个元素的地址。根据指针域的不同，链表又分为单链表、双向链表、循环链表等，这里我们只分析单链表。示意图如下所示：&lt;br&gt;
&lt;img src=&#34;/images/linkedlist.png&#34; alt=&#34;linkedlist&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;分析这种结构，我们可以得出以下几个结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明一个链表时，不需要知道其长度，也不需要连续的内存块，所以其大小可以动态调整。&lt;/li&gt;
&lt;li&gt;链表的每个元素都分为数据域和指针域，前者是实际存储的数据，后者则指向下一个元素的地址。和数组相比，每个元素需要占用的内存更大了。&lt;/li&gt;
&lt;li&gt;要获取链表的第 i 个元素变得复杂，因为其地址存放在它上一个元素的指针域里，所以只能从第一个元素起，进行 i 次操作。同理修改也是。&lt;/li&gt;
&lt;li&gt;链表对查询表现也一般，需要遍历，时间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;增加与删除一个元素更方便了，因为没有对内存地址的限制，我们只需要在对应节点合理处理下指针域的值，就可以把一个元素插入链表或者从链表删除。&lt;/li&gt;
&lt;li&gt;链表对内存的要求很小，只要能够存储下一个数据元素的内存块都可以使用，因此不会造成碎片化。&lt;br&gt;
故：大小可以动态调整，增删迅速，查找较慢，数据元素所占内存略多，不需要整块内存块，不会造成碎片化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;对比&#34;&gt;对比&lt;/h1&gt;
&lt;p&gt;数组按位置查找迅速，链表增删方便&lt;br&gt;
数组是固定大小，链表可以随时扩充与缩减&lt;br&gt;
链表每个元素占据内存略多于数组&lt;br&gt;
数组和链表在查询方面表现都比较一般，耗时较长&lt;br&gt;
时间复杂度参考：http://www.bigocheatsheet.com/&lt;br&gt;
&lt;img src=&#34;/images/time.png&#34; alt=&#34;time&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">算法学习-数组与链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/ExecutorService/"" data-c="
          &lt;p&gt;ExecutorService中有很多工具方法，在前面的文章中提过一些，这里将对剩余方法的功能进行介绍。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;invokeyAny()和invokeAll()具有阻塞特性&lt;/p&gt;
&lt;h1 id=&#34;invokeanycollection-extends-callablet-tasks&#34;&gt;invokeAny(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks)&lt;/h1&gt;
&lt;p&gt;取得第一个完成任务的结果值，当第一个任务执行完成后，会调用interrupt()方法将其他任务中断，所以在这些任务中可以结果if(Thread.currentThread().isInterrupted()==true)代码来决定任务是否继续&lt;br&gt;
1、其他线程无if(Thread.currentThread().isInterrupted()==true)代码，已经获得第一个运行的结果值后，其他线程继续运行&lt;br&gt;
2、其他线程有if(Thread.currentThread().isInterrupted()==true)代码，已经获得第一个运行的结果值后，其他线程用throw new InterruptedException()代码则这些线程中断，虽然throw 抛出了异常。但在主线程中并不能捕获到异常，如果想捕获异常，则需要在Callable中使用try-catch显示进行捕获。&lt;/p&gt;
&lt;p&gt;如果invokeyAny()执行慢的任务发生异常，默认情况下在主线程中捕获不到异常信息，只能在当前任务中显示的使用try-catch进行捕获&lt;br&gt;
如果invokeyAny()执行快的任务发生异常，默认情况下在主线程中捕获不到异常信息，除非在当前任务中显示的使用try-catch进行捕获，该方法还会等待执行慢的任务返回结果值。&lt;br&gt;
【先出现异常而不影响后面的任务取值的原理在源码中一直判断没有正确的返回值，如果直到最后都没有获得返回值则抛出ExecutionException，这个异常的内容是最后出现的异常。比如A、B、C这三个任务一起被执行，都出现了异常，则最终的异常就是在最后出现的异常】&lt;/p&gt;
&lt;h1 id=&#34;invokeanycollection-extends-callablet-tasks-long-timeout-timeunit-unit&#34;&gt;invokeAny(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks, long timeout, TimeUnit unit)&lt;/h1&gt;
&lt;p&gt;指定时间内取得第一个先执行完任务的结果值&lt;br&gt;
在出现超时异常时，可以将if(Thread.currentThread().isInterrupted()==true)判断和throw new InterruptedException()结合以使线程中断执行&lt;/p&gt;
&lt;h1 id=&#34;invokeallcollection-extends-callablet-tasks&#34;&gt;invokeAll(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks)&lt;/h1&gt;
&lt;p&gt;等待全部线程执行完毕后，取得全部完成任务的结果值。&lt;br&gt;
如果有任务执行时异常，则在对应的get()方法时抛出&lt;/p&gt;
&lt;h1 id=&#34;invokeallcollection-extends-callablet-tasks-long-timeout-timeunit-unit&#34;&gt;invokeAll(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks, long timeout, TimeUnit unit)&lt;/h1&gt;
&lt;p&gt;如果全部任务在指定时间内没有完成，则出现异常(CancallationException)&lt;br&gt;
如果正常执行完成的任务，可以通过对应的get()方法获取到返回值，没有在指定时间内执行完的任务则抛出CancallationException异常。&lt;/p&gt;
">ExecutorService接口的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/CompletionService/"" data-c="
          &lt;p&gt;接口CompletionService的功能是以异步的方式一边生产新任务，一边处理已完成任务的结果，这样可以将执行任务与处理任务分离开来进行处理。使用submit()执行任务，使用take()取得已完成的任务，并按照完成这些任务的时间顺序处理它们。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;上一篇文章讲到Future具有阻塞同步性，这样的代码运行效率大打折扣，接口CompletionService可以很好的解决这个问题。&lt;/p&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) {
        try {
            ThreadPoolExecutor pool = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;());
            CompletionService cs = new ExecutorCompletionService(pool);
            List&amp;lt;Callable&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            list.add(() -&amp;gt; { System.out.println(&amp;quot;username1&amp;quot;);Thread.sleep(5000);return &amp;quot;return username1&amp;quot;; });
            list.add(() -&amp;gt; { System.out.println(&amp;quot;username2&amp;quot;);Thread.sleep(4000);return &amp;quot;return username2&amp;quot;; });
            list.add(() -&amp;gt; { System.out.println(&amp;quot;username3&amp;quot;);Thread.sleep(3000);return &amp;quot;return username3&amp;quot;; });
            list.add(() -&amp;gt; { System.out.println(&amp;quot;username4&amp;quot;);Thread.sleep(2000);return &amp;quot;return username4&amp;quot;; });
            list.add(() -&amp;gt; { System.out.println(&amp;quot;username5&amp;quot;);Thread.sleep(1000);return &amp;quot;return username5&amp;quot;; });

            list.forEach(cs::submit);

            for (int i = 1; i &amp;lt;= 5; i ++) {
                System.out.println(&amp;quot;等待第&amp;quot; + i + &amp;quot;个的返回值&amp;quot;);
                System.out.println(cs.take().get());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;username1
username2
username3
username4
等待第1个的返回值
username5
return username5
等待第2个的返回值
return username4
等待第3个的返回值
return username3
等待第4个的返回值
return username2
等待第5个的返回值
return username1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果来看，CompletionService解决Future阻塞的特性，也就是谁先执行完成，就先处理谁的结果。&lt;br&gt;
当然如果当前没有任务被执行完，cs.take().get()也是呈阻塞特性的&lt;/p&gt;
&lt;p&gt;CompletionService执行任务时的各种异常：&lt;br&gt;
如果任务执行异常，则通过对应的Future对象的get()方法抛出，如果不执行Future对象的get()方法，则该异常不抛出&lt;/p&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;take()取得最先完成任务的Future对象
pool()获取并移除表示下一个已经完成任务的Future对象，如果不存在这样的任务，则返回null，此方法无阻塞的效果
poll(long timeout, TimeUnit unit)等带指定的时间，在指定的时间内获取到值时立即向下继续执行，如果超时也立即执行
submit(Callable&amp;lt;V&amp;gt; task)
submit(Runnable task, V result)参数V是对应的返回值

&lt;/code&gt;&lt;/pre&gt;
">CompletionService的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/Future-And-Callable/"" data-c="
          &lt;p&gt;在默认情况下，线程Thread对象不具有返回值的功能，如果在需要取得返回值的情况下是极为不方便的，但在JDK1.5的并发包中可以使用Future和Callable来使线程具有返回值的功能。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;接口Callable和Runnable的区别&lt;br&gt;
1、Callable接口的call()方法可以有返回值，而Runnable接口的run()方法没有返回值。&lt;br&gt;
2、Callable()接口的call()方法可以声明抛出异常，而Runnable接口的run()方法不可以声明异常。&lt;/p&gt;
&lt;p&gt;执行完Callable接口中的任务后，返回值是通过Future接口进行获取；&lt;br&gt;
Callable示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(2, 3, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;());
        Future&amp;lt;String&amp;gt; future = pool.submit(() -&amp;gt; {
            Thread.sleep(5000);
            return &amp;quot;Finished&amp;quot;;
        });
        System.out.println(&amp;quot;main A:&amp;quot; + System.currentTimeMillis());
        System.out.println(future.get());
        System.out.println(&amp;quot;main B:&amp;quot; + System.currentTimeMillis());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;main A:1525698162505
Finished
main B:1525698167510
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果看出，get()方法具有阻塞的特性&lt;/p&gt;
&lt;p&gt;Runnable示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(2, 3, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;());
        Future&amp;lt;?&amp;gt; future = pool.submit(() -&amp;gt; {
            try {
                System.out.println(&amp;quot;运行开始：&amp;quot; + System.currentTimeMillis());
                Thread.sleep(5000);
                System.out.println(&amp;quot;运行结束：&amp;quot; + System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(&amp;quot;main A:&amp;quot; + System.currentTimeMillis());
        System.out.println(future.get() + &amp;quot; | &amp;quot; + future.isDone());
        System.out.println(&amp;quot;main B:&amp;quot; + System.currentTimeMillis());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;main A:1525698748640
运行开始：1525698748640
运行结束：1525698753643
null | true
main B:1525698753643
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果看出Runnable是没有返回值的，所以get()方法打印null，且也具有阻塞的特性，而isDone()方法无阻塞特性&lt;br&gt;
Callable接口相对于Runnable接口的优点在于Callable接口可以通过Future获取返回值，但需要注意的是，Future接口调用get()方法时，是呈阻塞性的，也就是如果任务尚未完成，则调用get()方法时一直阻塞到此任务完成为止&lt;/p&gt;
&lt;p&gt;异常处理&lt;br&gt;
Callable任务如果执行过程中抛出来异常，会在对应的Future的get()方法中抛出&lt;/p&gt;
&lt;p&gt;方法execute()与submit()的区别&lt;br&gt;
1、execute()没有返回值，submit()可以有返回值&lt;br&gt;
2、execute()默认情况下异常直接抛出，不能捕获，但可以通过自定义ThreadFactory的方式进行捕获(Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler eh))，&lt;br&gt;
submit()方法在默认情况下，可以在对应的Future.get方法处捕获异常&lt;/p&gt;
&lt;p&gt;Future的缺点:get()方法呈阻塞性，影响效率&lt;/p&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ExecutorService接口的
submit(Callable callable)
submit(Runnable runnable)
submit(Runnable runnable, T result)第二个参数可作为执行结果返回，而不需要使用get()方法来进行获取

Future
cancel(boolean mayInterruptIfRunning)参数的作用是：如果线程正在运行则是否中断中断正在运行的线程，在代码中需要使用if(Thread.currentThread().isInterrupted())进行配合。返回值代表发送取消任务的命令是否成功完成
get()
get(long timeout, TimeUnit unit)指定的最大时间内等待获取返回值
&lt;/code&gt;&lt;/pre&gt;
">Future和Callable的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/Executor-ThreadPoolExecutor/"" data-c="
          &lt;p&gt;在开发服务端软件项目时，经常需要处理时间很短而数目却非常巨大的请求，如果为每一个请求创建一个新的线程，会导致性能上的瓶颈，因为线程对象的创建和销毁需要JVM频繁的处理，如果执行时间很短，可能花在创建和销毁线程对象上的时间将大于真正执行任务的时间，若这样，系统性能将大大降低。&lt;br&gt;
因此JDK5起提供了线程池的支持，主要作用则时支持高并发的访问处理，并且可以将线程对象进行复用。&lt;/p&gt;
&lt;h1 id=&#34;-more-executors&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
Executors&lt;/h1&gt;
&lt;p&gt;Exwcutor仅仅时一种规范，是一种声明和定义，并没有实现任何的功能，所以需要使用接口的实现类来完成指定的功能，比如ThreadPoolExecutor。ThreadPoolExecutor使用上并不是很方便，实例化时需要传入很多个参数，还要考虑线程并发数等与线程运行效率相关的参数，所以官方建议使用Executors工厂类来创建线程池对象。&lt;/p&gt;
&lt;h2 id=&#34;newcachedthreadpool&#34;&gt;newCachedThreadPool()&lt;/h2&gt;
&lt;p&gt;创建无界线程池，可以进行线程自动回收&lt;br&gt;
所谓“无界”就是指理论上的Integer.MAX_VALUE&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;newcachedthreadpoolthreadfactory-threadfactory&#34;&gt;newCachedThreadPool(ThreadFactory threadFactory)&lt;/h2&gt;
&lt;p&gt;可通过ThreadFactory定制无界线程池中的线程对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyThreadFactory implements ThreadFactory {
    int i = 0;
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, &amp;quot;定制线程对象-&amp;quot; + ++ i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;newfixedthreadpoolint-nthreads&#34;&gt;newFixedThreadPool(int nThreads)&lt;/h2&gt;
&lt;p&gt;创建有界线程池，也就是线程池中的线程数可以指定最大值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;newfixedthreadpoolint-nthreads-threadfactory-threadfactory&#34;&gt;newFixedThreadPool(int nThreads, ThreadFactory threadFactory)&lt;/h2&gt;
&lt;h2 id=&#34;增加定制线程功能的有界线程池newsinglethreadexecutor&#34;&gt;增加定制线程功能的有界线程池&lt;br&gt;
newSingleThreadExecutor()&lt;/h2&gt;
&lt;p&gt;单一线程的线程池，实现队列的方式来执行任务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;newsinglethreadexecutorthreadfactory-threadfactory&#34;&gt;newSingleThreadExecutor(ThreadFactory threadFactory)&lt;/h2&gt;
&lt;p&gt;定制线程功能的单一线程池&lt;/p&gt;
&lt;h1 id=&#34;threadpoolexecutor的使用&#34;&gt;ThreadPoolExecutor的使用&lt;/h1&gt;
&lt;p&gt;常用构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)
corePoolSize：池中保存的线程数，包括空闲线程数
maximumPoolSize：池中允许的最大线程数
keepAliveTime：线程数数量大于corePoolSize时，在没有超过指定时间内时不会从线程池中将空闲线程删除，超过此时间单位，则删除
unit：keepAliveTime的时间单位
workQueue：执行前用于保存任务的队列。此队列仅保持由execute方法提交的Runnable任务
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例注释：&lt;br&gt;
A：execute提交的Runnable任务数量&lt;br&gt;
B：核心线程数corePoolSize&lt;br&gt;
C：最大线程数maximumPoolSize&lt;br&gt;
D：A-B（假设A&amp;gt;=B）&lt;br&gt;
E：new LinkedBlockingDeque&lt;Runnable&gt;();队列，无构造参数&lt;br&gt;
F：new SynchronousQueue&lt;Runnable&gt;();队列&lt;br&gt;
G：keepAliveTime&lt;br&gt;
注：这里E和F时两种类型的队列，指定线程池仅可选择一种&lt;/p&gt;
&lt;p&gt;1、如果A&amp;lt;=B，那么马上创建线程运行这个任务，并不放入扩展队列Queue中，其他参数功能忽略&lt;br&gt;
2、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;lt;=C&amp;amp;&amp;amp;E，那么C和G参数忽略，并把D放入E中等待被执行&lt;br&gt;
3、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;lt;=C&amp;amp;&amp;amp;F，那么C和G参数有效，并马上创建线程运行这些任务，而不把D放入F中，D执行完成后在执行时间后放生超时将D进行清除&lt;br&gt;
4、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;gt;C&amp;amp;&amp;amp;E，那么C和G参数忽略，并把D放入E中等待被执行&lt;br&gt;
5、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;gt;C&amp;amp;&amp;amp;F，那么处理C的任务，其他任务则不再处理抛出异常&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor常见的队列&lt;br&gt;
A：ArrayBlockingQueue&lt;br&gt;
B：LinkedBlockingDeque&lt;br&gt;
C：SynchronousQueue&lt;br&gt;
A和B可指定队列存储元素的多少，C是为同步队列，不存储元素&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor拒绝策略&lt;br&gt;
AbortPolicy：当任务添加到线程池中被拒绝时，它将抛出RejectedExecutionException异常&lt;br&gt;
CallerRunsPolicy：当任务添加到线程池中被拒绝时，会使用调用线程池的Thread对象来处理该被决绝的任务&lt;br&gt;
// 也就是说谁发起来这个任务，谁就要负责该任务的执行&lt;br&gt;
DiscardOldestPolicy：当任务添加到线程池被拒绝时，线程池会放弃等待队列中最旧的未处理的任务，然后将被拒绝的任务添加到等待队列中&lt;br&gt;
DiscardPolicy：当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务&lt;/p&gt;
&lt;p&gt;注：线程池ThreadPoolExecutor的执行等待队列中的任务是安顺序去除，执行却是乱序的&lt;/p&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getCorePoolSize()获取核心线程数
getMaximunPoolSize()获取最大线程数
getPoolSize()当前池中线程数
getQueue().size()当前等待执行的线程数
getActiveCount()当前有多少个线程正在执行任务
getCompletedTaskCount()获取已经执行完成的任务数
getTaskCount()获取有多少个任务发送给了线程池
shutdown()当前未执行完的线程继续执行，而不再添加新的任务；方法不会阻塞
shutdownNow()中断所有的任务Task
// 并且抛出InterruptedException异常
// 前提时Runnable中使用if (Thread.currentThread().isInterrupted() == true)语句来判断当前线程的中断状态
// 而在队列中等待执行的线程不再执行，也就是从等待队列中清除
// 如果线程中没有if (Thread.currentThread().isInterrupted() == true)语句及抛出异常的代码，正在执行的线程会正常执行完毕
// 该方法还会返回被清除的线程列表
isShutdown()判断线程池是否已经关闭
isTerminating()可以理解为线程池是否正在关闭
// 当调用shutdown()或shutdownNow()之后处于正在终止但尚未完全终止的过程中时，该方法返回true
isTerminated()线程池是否已经关闭
awaitTermination(long timeout, TimeUnit unit)等待指定时间内，返回线程池是否已经终止工作，
setRejectedExecutionHandler(RejectedExecutionHandler handler)设置任务被拒绝执行时的策略
allowCoreThreadTimeOut(boolean value)设置核心线程数是否也有超时效果
prestartCoreThread()每调用一次就创建一个核心线程，返回是否创建成功
prestartAllCoreThreads()启用全部核心线程，返回实际启动的核心线程数量
// 线程池可重写以下两个方法对线程池中执行的线程对象实现监控
beforeExecute(Thread t, Runnable r)任务执行前
afterExecute(Runnable r, Throwable t)任务执行完成后
remove(Runnable task)删除尚未被执行的Runnable任务
// 但是这个方法需要注意的是，如果通过execute()方法进行提交的任务，且在等待队列中时，才可被删除
// 如果时通过submit()方法提交的任务，且在等待队列中时，不能被删除【原因时submit方法对任务进行了包装】
&lt;/code&gt;&lt;/pre&gt;
">Executor与ThreadPoolExecutor的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/Phaser/"" data-c="
          &lt;p&gt;Phaser提供动态增减parties(屏障点)计数，这点币CyclicBarrier类操作parties更加方便，通过若干个方法来控制多个线程之间同步运行的效果，还可以实现针对某一个线程取消同步运行的效果，而且支持在指定屏障处等待，在等待时还支持中断或非中断等功能。对线程并发进行分组同步控制时，它比CyclicBarrier类功能更加强大，更建议使用。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;简单示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) {
        final Phaser phaser = new Phaser(3);
        Runnable r1 = () -&amp;gt; {
            System.out.println(Thread.currentThread().getName() + &amp;quot; A1 begin=&amp;quot; + System.currentTimeMillis());
            phaser.arriveAndAwaitAdvance();
            System.out.println(Thread.currentThread().getName() + &amp;quot; A1 end=&amp;quot; + System.currentTimeMillis());
            System.out.println(Thread.currentThread().getName() + &amp;quot; A2 begin=&amp;quot; + System.currentTimeMillis());
            phaser.arriveAndAwaitAdvance();
            System.out.println(Thread.currentThread().getName() + &amp;quot; A2 end=&amp;quot; + System.currentTimeMillis());
        };
        Runnable r2 = () -&amp;gt; {
            try {
                System.out.println(Thread.currentThread().getName() + &amp;quot; A1 begin=&amp;quot; + System.currentTimeMillis());
                Thread.sleep(2000);
                phaser.arriveAndAwaitAdvance();
                System.out.println(Thread.currentThread().getName() + &amp;quot; A1 end=&amp;quot; + System.currentTimeMillis());
                System.out.println(Thread.currentThread().getName() + &amp;quot; A2 begin=&amp;quot; + System.currentTimeMillis());
                Thread.sleep(2000);
                phaser.arriveAndAwaitAdvance();
                System.out.println(Thread.currentThread().getName() + &amp;quot; A2 end=&amp;quot; + System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        new Thread(r1, &amp;quot;A&amp;quot;).start();
        new Thread(r1, &amp;quot;B&amp;quot;).start();
        new Thread(r2, &amp;quot;C&amp;quot;).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;A A1 begin=1525358412447
B A1 begin=1525358412447
C A1 begin=1525358412447
C A1 end=1525358414450
C A2 begin=1525358414451
B A1 end=1525358414451
A A1 end=1525358414451
B A2 begin=1525358414451
A A2 begin=1525358414451
C A2 end=1525358416456
B A2 end=1525358416456
A A2 end=1525358416456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移除代码中的18-21行的内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// System.out.println(Thread.currentThread().getName() + &amp;quot; A2 begin=&amp;quot; + System.currentTimeMillis());
// Thread.sleep(2000);
// phaser.arriveAndAwaitAdvance();
// System.out.println(Thread.currentThread().getName() + &amp;quot; A2 end=&amp;quot; + System.currentTimeMillis());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br&gt;
[image]&lt;br&gt;
&lt;img src=&#34;/images/image01.jpg&#34; alt=&#34;运行结果&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从运行结果看，因为某一个线程达到屏障点，导致另外两个线程一直等待。&lt;/p&gt;
&lt;p&gt;为了解决上面的问题，不再继续向下一个屏障点执行的线程调用&lt;br&gt;
arriveAndDeregister()，可以实现将当前线程退出该屏障，并且将屏障点(parties)值减1.&lt;br&gt;
将上述Runnable r2代码改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Runnable r2 = () -&amp;gt; {
    try {
        System.out.println(Thread.currentThread().getName() + &amp;quot; A1 begin=&amp;quot; + System.currentTimeMillis());
        Thread.sleep(2000);
        System.out.println(&amp;quot;A:&amp;quot; + phaser.getRegisteredParties());
        phaser.arriveAndDeregister();
        System.out.println(&amp;quot;B:&amp;quot; + phaser.getRegisteredParties());
        System.out.println(Thread.currentThread().getName() + &amp;quot; A1 end=&amp;quot; + System.currentTimeMillis());
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;A A1 begin=1525359548165
C A1 begin=1525359548165
B A1 begin=1525359548165
A:3
B:2
C A1 end=1525359550168
A A1 end=1525359550168
B A1 end=1525359550168
A A2 begin=1525359550169
B A2 begin=1525359550169
B A2 end=1525359550169
A A2 end=1525359550169
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;arriveAndAwaitAdvance()当前线程已经到达屏障，在此等待条件满足后继续向后执行
arriveAndDeregister()当前线程退出该屏障，并且将屏障点(parties)值减1
getRegisteredParties()当前phaser注册的屏障点数
register()没执行一次该方法就动态添加一个parties值
getPhase()获取已经到达第几个屏障
onAdvance()通过新的屏障时调用
// 该方法返回true表示不等待类，Phaser呈无效/销毁状态
// 该方法返回false表示Phaser继续工作
bulkRegister()批量增加parties值
getArrivedParties()获取已经被使用的parties个数
getUnarrivedParties()获取未被使用的parties个数
arrive()使到达屏障的线程数加1，且当前线程不在屏障处等待，直接向下面的代码继续运行，并且Phaser到达的线程达到parties时会重置计数
awaitAdvance(int phase)如果传入的phase值和当前getPhase()方法返回值一样，则在屏障处等待，否则继续向下运行。类似于旁观者的作用，当观察的条件满足了就等待(旁观)，如果条件不满足，则程序向下继续运行
awaitAdvance(int phase)不可中断
awaitAdvanceInterruptibly(int phase)可中断的
awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)指定最大的等待时间
forceTermination()是Phaser对象的屏障功能失效，并且处于屏障处等待的线程继续执行，并不抛出一场
isTerminated()判断Phaser对象是否已经呈销毁状态
&lt;/code&gt;&lt;/pre&gt;
">Phaser的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/CountDownLatch-And-CyclicBarrier/"" data-c="
          &lt;p&gt;CountDownLatch类可以实现两种角色的线程等待对方的效果；&lt;br&gt;
CyclicBarrier类可以使同类现成互相等待达到同步的效果；&lt;br&gt;
这两个类可以更加完善的实现现成对象之间的同步性，对线程对象执行的轨迹控制更加方便。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;countdownlatch的使用&#34;&gt;CountDownLatch的使用&lt;/h1&gt;
&lt;p&gt;它所提供的功能是判断count计数不为0时则当前线程呈wait状态，也就是屏障处等待。&lt;br&gt;
它也是一个同步功能的辅助类，使用效果是给定一个计数，当使用这个CountDownLatch类的线程计数不为0时，则呈wait状态，如果为0时则继续运行。&lt;br&gt;
实现等待与继续运行的效果分别需要使用await()和countDown()方法来进行。调用await()方法时判断计数是否为0，如果不为0则呈等待状态，其他线程可以调用countDown()方法将计数减1，当计数减到0时，呈等待状态的线程继续运行。&lt;br&gt;
这里还有一个问题是它的计数是无法被重置的，仅仅是减法操作。&lt;/p&gt;
&lt;p&gt;简单示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) throws Exception {
        CountDownLatch latch = new CountDownLatch(1);
        new TestThread(latch).start();
        Thread.sleep(2000);
        System.out.println(&amp;quot;XX&amp;quot;);
        latch.countDown();
    }
}
class TestThread extends Thread {
    private CountDownLatch latch;
    public TestThread(CountDownLatch latch) {
        this.latch = latch;
    }
    @Override
    public void run() {
        try {
            System.out.println(&amp;quot;A&amp;quot;);
            latch.await();
            System.out.println(&amp;quot;B&amp;quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;A
XX
B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;await(long timeout, TimeUnit unit)可设置最大等待时间
getCount()获取当前的计数个数
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;cyclicbarrier的使用&#34;&gt;CyclicBarrier的使用&lt;/h1&gt;
&lt;p&gt;它不进有CountDownLatch所具有的功能，还可以实现屏障等待的功能，也就是阶段性同步，它在使用上的意义在于可以循环的实现线程要一起做任务的目标，而不是像CountDownLatch一样，仅仅支持一次线程与同步点阻塞的特性。&lt;br&gt;
它也是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点，这些线程必须实时的互相等待，同时它的公共屏障点可以重用，所以类名中包含Cyclic一词。&lt;/p&gt;
&lt;p&gt;简单示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) throws Exception {
        CyclicBarrier cb = new CyclicBarrier(5, new Runnable() {
            @Override public void run() {
                System.out.println(&amp;quot;都到了&amp;quot;);
            }
        });
        for (int i = 0; i &amp;lt; 5; i ++) {
            new TestThread(cb).start();
        }
    }
}
class TestThread extends Thread {
    private CyclicBarrier cb;
    public TestThread(CyclicBarrier cb) {
        this.cb = cb;
    }
    @Override
    public void run() {
        try {
            Thread.sleep(((int) Math.random()) * 1000);
            System.out.println(Thread.currentThread().getName() + &amp;quot;到了，time=&amp;quot; + System.currentTimeMillis());
            cb.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread-0到了，time=1525274424626
Thread-4到了，time=1525274424627
Thread-2到了，time=1525274424626
Thread-1到了，time=1525274424627
Thread-3到了，time=1525274424627
都到了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里演示的时线程个数等于屏障个数的情况，&lt;br&gt;
下面示例线程数大于屏障个数时，分批处理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) throws Exception {
        CyclicBarrier cb = new CyclicBarrier(2, new Runnable() {
            @Override public void run() {
                System.out.println(&amp;quot;都到了&amp;quot;);
            }
        });
        for (int i = 0; i &amp;lt; 4; i ++) {
            new TestThread(cb).start();
            Thread.sleep(500);
        }
    }
}
class TestThread extends Thread {
    private CyclicBarrier cb;
    public TestThread(CyclicBarrier cb) {
        this.cb = cb;
    }
    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + &amp;quot;到了，等待凑齐两个，time=&amp;quot; + System.currentTimeMillis());
            cb.await();
            System.out.println(Thread.currentThread().getName() + &amp;quot;已经凑齐两个，time=&amp;quot; + System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread-0到了，等待凑齐两个，time=1525274766393
Thread-1到了，等待凑齐两个，time=1525274766895
都到了
Thread-1已经凑齐两个，time=1525274766896
Thread-0已经凑齐两个，time=1525274766896
Thread-2到了，等待凑齐两个，time=1525274767398
Thread-3到了，等待凑齐两个，time=1525274767901
都到了
Thread-3已经凑齐两个，time=1525274767901
Thread-2已经凑齐两个，time=1525274767902
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getParties()取得屏障点个数
getNumberWaiting()获取当前有几个线程已经达到屏障点
isBroken()查询此屏障是否处于损坏状态
这里需要注意的是CyclicBarrier对于线程的中断interrupte处理会使用全有或者全无的破坏模型
意思是如果一个线程处于中断或超时提前离开屏障点，其他所有屏障点等待的线程均会跑出BrokenBarrierException或者InterruptedException，并且离开屏障点。
await(long timeout, TimeUnit unit)指定在屏障点的最大等待时间，超时将抛出TimeoutException
reset()重置屏障
处于屏障点等待的线程将抛出BrokenBarrierException
&lt;/code&gt;&lt;/pre&gt;
">CountDownLatch和CyclicBarrier</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/Semaphore-and-Exchanger/"" data-c="
          &lt;p&gt;类Semaphore的主要作用是限制并发执行的线程数，它具有synchronized所不具有的强大功能，比如等待获取许可的同时可以加入等待时间，还有尝试是否可以持有锁等这类扩展功能，可以说它是强有力的控制并发线程个数的解决方案之一。&lt;br&gt;
Exchanger是线程间传输数据的方式之一，而且在传输数据类型上没有任何限制。&lt;/p&gt;
&lt;h1 id=&#34;-more-semaphore&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
Semaphore&lt;/h1&gt;
&lt;p&gt;Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。&lt;/p&gt;
&lt;p&gt;构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Semaphore(int permits)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中permits指同时运行的线程数量&lt;br&gt;
可通过控制构造函数的permits，控制并发执行的线程数。&lt;/p&gt;
&lt;p&gt;单线程示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(1);
        Single single = new Single(semaphore);
        for (int i = 0; i &amp;lt; 3; i ++) {
            new TestThread(&amp;quot;Test-&amp;quot; + i, single).start();;
        }
    }
}
class TestThread extends Thread {
    private Single single;
    public TestThread(String name, Single single) {
        super(name);
        this.single = single;
    }
    @Override
    public void run() {
        single.test();
    }
    
}
class Single {
    private Semaphore semaphore;
    public Single(Semaphore semaphore) {
        this.semaphore = semaphore;
    }
    public void test() {
        try {
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName() + &amp;quot; start at &amp;quot; + System.currentTimeMillis());
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &amp;quot; stop at &amp;quot; + System.currentTimeMillis());
            semaphore.release();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Test-0 start at 1524806263164
Test-0 stop at 1524806264166
Test-2 start at 1524806264166
Test-2 stop at 1524806265167
Test-1 start at 1524806265167
Test-1 stop at 1524806266167
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;acquire(int permits)还可以每次调用获取permits个许可。
acquireUninterruptibly()方法的作用是使进入等待许可的线程，不允许被中断。
availablePermits()返回当前可用的许可数量
drainPermits()获取并返回当前可用的许可数量，并将可用许可数置0
getQueueLength()获取等待许可的线程数
hasQueuedThreads()判断是否还有线程在等待这个许可
tryAcquire()尝试获取一个许可，无阻塞
tryAcquire(int permits)尝试获取permits个许可，无阻塞
tryAcquire(long timeout, TimeUnit unit)在指定时间内尝试获取一个许可以
tryAcquire(int permits, long timeout, TimeUnit unit)在指定时间内尝试获取permits个许可以
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该类还支持公平和非公平许可：默认非公平&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Semaphore(int permits, boolean fair)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：Semaphore并不能保证线程安全性，因此还是有可能会出现多个线程共同访问实例变量，导致出现脏数据的情况。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;exchanger&#34;&gt;Exchanger&lt;/h1&gt;
&lt;p&gt;Exchanger的功能可以使2个线程之间传输数据，它比生产者/消费者模式产生的wait/notify要更加方便。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App {
    public static void main(String[] args) {
        Exchanger&amp;lt;String&amp;gt; exchanger = new Exchanger&amp;lt;&amp;gt;();
        Single single = new Single(exchanger);
        for (int i = 0; i &amp;lt; 2; i ++) {
            new TestThread(&amp;quot;Test-&amp;quot; + i, single).start();;
        }
    }
}
class TestThread extends Thread {
    private Single single;
    public TestThread(String name, Single single) {
        super(name);
        this.single = single;
    }
    @Override
    public void run() {
        single.test(Thread.currentThread().getName());
    }
    
}
class Single {
    private Exchanger&amp;lt;String&amp;gt; exchanger;
    public Single(Exchanger&amp;lt;String&amp;gt; exchanger) {
        this.exchanger = exchanger;
    }
    public void test(String s) {
        try {
            System.out.println(&amp;quot;send=&amp;quot; + s + &amp;quot; and receive=&amp;quot; + exchanger.exchange(s));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;send=Test-0 and receive=Test-1
send=Test-1 and receive=Test-0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法介绍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;exchange(V x, long timeout, TimeUnit unit) 指定时间内没有其他线程获取数据，则出现超时异常
&lt;/code&gt;&lt;/pre&gt;
">Semaphore和Exchanger</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/idea-keywords/"" data-c="
          &lt;p&gt;IDEA快捷键，Mac、Windows和Linux对照&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Remember these Shortcuts&lt;br&gt;
记住这些快捷键&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Smart code completion&lt;/td&gt;
&lt;td&gt;智能代码补全&lt;/td&gt;
&lt;td&gt;⌃⇧Space&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search everywhere&lt;/td&gt;
&lt;td&gt;搜索所有文件&lt;/td&gt;
&lt;td&gt;Double⇧&lt;/td&gt;
&lt;td&gt;Double Shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show intention actions and quick-fixes&lt;/td&gt;
&lt;td&gt;显示意向操作和快捷修复&lt;/td&gt;
&lt;td&gt;⌘↩︎&lt;/td&gt;
&lt;td&gt;Alt + Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generate code&lt;/td&gt;
&lt;td&gt;生成代码&lt;/td&gt;
&lt;td&gt;⌘N,⌃↩︎&lt;/td&gt;
&lt;td&gt;Alt + Ins&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extend selection&lt;/td&gt;
&lt;td&gt;展开选择&lt;/td&gt;
&lt;td&gt;⌥⌘↑&lt;/td&gt;
&lt;td&gt;Ctrl + W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shrink selection&lt;/td&gt;
&lt;td&gt;收起选择&lt;/td&gt;
&lt;td&gt;⌥⌘↓&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Recent files popup&lt;/td&gt;
&lt;td&gt;最近打开的文件&lt;/td&gt;
&lt;td&gt;⌘E&lt;/td&gt;
&lt;td&gt;Ctrl + E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rename&lt;/td&gt;
&lt;td&gt;重命名&lt;/td&gt;
&lt;td&gt;⇧F6&lt;/td&gt;
&lt;td&gt;Shift + F6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;General&lt;br&gt;
常规&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Open corresponding tool window&lt;/td&gt;
&lt;td&gt;打开相应的工具窗口&lt;/td&gt;
&lt;td&gt;⌘0…⌘9&lt;/td&gt;
&lt;td&gt;Alt + #[0-9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Save all&lt;/td&gt;
&lt;td&gt;保存所有&lt;/td&gt;
&lt;td&gt;⌘S&lt;/td&gt;
&lt;td&gt;Ctrl+S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Synchronize&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;⌘⌥Y&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Toggle maximizing editor&lt;/td&gt;
&lt;td&gt;切换最大化编辑窗口&lt;/td&gt;
&lt;td&gt;⌘⇧F12&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + F12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Inspect current file with current profile&lt;/td&gt;
&lt;td&gt;用当前配置文件检查当前文件&lt;/td&gt;
&lt;td&gt;⌥⇧I&lt;/td&gt;
&lt;td&gt;Alt+Shift+I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quick switch current scheme&lt;/td&gt;
&lt;td&gt;快速切换当前方案&lt;/td&gt;
&lt;td&gt;⌃§,⌃&lt;code&gt;| Ctrl + BackQuote (&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Open Settings dialog&lt;/td&gt;
&lt;td&gt;打开设置弹框&lt;/td&gt;
&lt;td&gt;⌘,&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Open Project Structure dialog&lt;/td&gt;
&lt;td&gt;打开项目结构弹框&lt;/td&gt;
&lt;td&gt;⌘;&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + Shift + S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Find Action&lt;/td&gt;
&lt;td&gt;找到行动&lt;/td&gt;
&lt;td&gt;⌘⇧A&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Debugging&lt;br&gt;
调试&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Step over / into&lt;/td&gt;
&lt;td&gt;单步退出或进入&lt;/td&gt;
&lt;td&gt;F8 / F7&lt;/td&gt;
&lt;td&gt;F8/F7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart step into / Step out&lt;/td&gt;
&lt;td&gt;智能单步进入或退出&lt;/td&gt;
&lt;td&gt;⇧F7/⇧F8&lt;/td&gt;
&lt;td&gt;Shift+F7/Shift+ F8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Run to cursor&lt;/td&gt;
&lt;td&gt;运行到下一行&lt;/td&gt;
&lt;td&gt;⌥F9&lt;/td&gt;
&lt;td&gt;Alt+F9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Evaluate expression&lt;/td&gt;
&lt;td&gt;计算表达式&lt;/td&gt;
&lt;td&gt;⌥F8&lt;/td&gt;
&lt;td&gt;Alt+F8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Toggle breakpoint&lt;/td&gt;
&lt;td&gt;执行到下一个断点&lt;/td&gt;
&lt;td&gt;⌘F8&lt;/td&gt;
&lt;td&gt;Ctrl + F8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;View breakpoints&lt;/td&gt;
&lt;td&gt;查看所有断点&lt;/td&gt;
&lt;td&gt;⌘⇧F8&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + F8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Search / Replace&lt;br&gt;
查找/替换&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Search everywhere&lt;/td&gt;
&lt;td&gt;搜索所有文件&lt;/td&gt;
&lt;td&gt;Double⇧&lt;/td&gt;
&lt;td&gt;Double Shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Find&lt;/td&gt;
&lt;td&gt;查找&lt;/td&gt;
&lt;td&gt;⌘F&lt;/td&gt;
&lt;td&gt;Ctrl + F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Find next / previous&lt;/td&gt;
&lt;td&gt;查找下一个/上一个&lt;/td&gt;
&lt;td&gt;⌘G/⌘⇧G&lt;/td&gt;
&lt;td&gt;F3/Shift+F3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace&lt;/td&gt;
&lt;td&gt;替换&lt;/td&gt;
&lt;td&gt;⌘R&lt;/td&gt;
&lt;td&gt;Ctrl+R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Find in path&lt;/td&gt;
&lt;td&gt;在指定路径查找&lt;/td&gt;
&lt;td&gt;⌘⇧F&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace in path&lt;/td&gt;
&lt;td&gt;在指定路径替换&lt;/td&gt;
&lt;td&gt;⌘⇧R&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Select next occurrence&lt;/td&gt;
&lt;td&gt;选择下一个发生&lt;/td&gt;
&lt;td&gt;⌃G&lt;/td&gt;
&lt;td&gt;Alt+J&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Select all occurrences&lt;/td&gt;
&lt;td&gt;选择所有的发生&lt;/td&gt;
&lt;td&gt;⌃⇧G&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+Shift+J&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unselect occurrence&lt;/td&gt;
&lt;td&gt;取消选择&lt;/td&gt;
&lt;td&gt;⌃G&lt;/td&gt;
&lt;td&gt;Alt+Shift+J&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Editing&lt;br&gt;
编辑&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Basic code completion&lt;/td&gt;
&lt;td&gt;基本代码补全&lt;/td&gt;
&lt;td&gt;⌃Space&lt;/td&gt;
&lt;td&gt;Ctrl + Space&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart code completion&lt;/td&gt;
&lt;td&gt;智能代码补全&lt;/td&gt;
&lt;td&gt;⌃⇧Space&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Complete statement&lt;/td&gt;
&lt;td&gt;完整的声明&lt;/td&gt;
&lt;td&gt;⌘⇧↩︎&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parameter info (within method call arguments)&lt;/td&gt;
&lt;td&gt;参数说明-在方法调用参数中&lt;/td&gt;
&lt;td&gt;⌘P&lt;/td&gt;
&lt;td&gt;Ctrl+P&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quick documentation lookup&lt;/td&gt;
&lt;td&gt;快速查找文档&lt;/td&gt;
&lt;td&gt;⌃J,&lt;/td&gt;
&lt;td&gt;Ctrl+Q&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;External Doc&lt;/td&gt;
&lt;td&gt;外部文档&lt;/td&gt;
&lt;td&gt;⌘F1&lt;/td&gt;
&lt;td&gt;Shift + F1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Brief Info&lt;/td&gt;
&lt;td&gt;简要信息&lt;/td&gt;
&lt;td&gt;⌘+mouse&lt;/td&gt;
&lt;td&gt;Ctrl + mouse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show descriptions of error at caret&lt;/td&gt;
&lt;td&gt;在插入符号处显示错误的描述&lt;/td&gt;
&lt;td&gt;⌘F1&lt;/td&gt;
&lt;td&gt;Ctrl + F1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generate code...&lt;/td&gt;
&lt;td&gt;生成代码&lt;/td&gt;
&lt;td&gt;⌘N,⌃↩︎&lt;/td&gt;
&lt;td&gt;Alt + Insert&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Override methods&lt;/td&gt;
&lt;td&gt;覆盖方法&lt;/td&gt;
&lt;td&gt;⌃O&lt;/td&gt;
&lt;td&gt;Ctrl + O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Implement methods&lt;/td&gt;
&lt;td&gt;实现方法&lt;/td&gt;
&lt;td&gt;⌃I&lt;/td&gt;
&lt;td&gt;Ctrl + I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Surround with...&lt;/td&gt;
&lt;td&gt;被XXX包含&lt;/td&gt;
&lt;td&gt;⌘⌥T&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Comment / uncomment with line comment&lt;/td&gt;
&lt;td&gt;注释/取消行注释&lt;/td&gt;
&lt;td&gt;⌘/&lt;/td&gt;
&lt;td&gt;Ctrl + /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Comment / uncomment with block comment&lt;/td&gt;
&lt;td&gt;注释/取消块注释&lt;/td&gt;
&lt;td&gt;⌘⌥/&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extend selection&lt;/td&gt;
&lt;td&gt;展开选择&lt;/td&gt;
&lt;td&gt;⌥↑&lt;/td&gt;
&lt;td&gt;Ctrl + W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shrink selection&lt;/td&gt;
&lt;td&gt;收起选择&lt;/td&gt;
&lt;td&gt;⌥↓&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Context info&lt;/td&gt;
&lt;td&gt;上下文信息&lt;/td&gt;
&lt;td&gt;⌃⇧Q&lt;/td&gt;
&lt;td&gt;Alt + Q&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show intention actions and quick-fixes&lt;/td&gt;
&lt;td&gt;显示意向操作和快捷修复&lt;/td&gt;
&lt;td&gt;⌘↩︎&lt;/td&gt;
&lt;td&gt;Alt + Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reformat code&lt;/td&gt;
&lt;td&gt;重新格式化代码&lt;/td&gt;
&lt;td&gt;⌘⌥L&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Optimize imports&lt;/td&gt;
&lt;td&gt;优化导入&lt;/td&gt;
&lt;td&gt;⌃⌥O&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Auto-indent line(s)&lt;/td&gt;
&lt;td&gt;自动缩进&lt;/td&gt;
&lt;td&gt;⌃⌥I&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Indent / unindent selected lines&lt;/td&gt;
&lt;td&gt;增加/减小缩进&lt;/td&gt;
&lt;td&gt;⇥/⇧⇥&lt;/td&gt;
&lt;td&gt;Tab / Shift + Tab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cut current line to clipboard&lt;/td&gt;
&lt;td&gt;剪切当前行&lt;/td&gt;
&lt;td&gt;⌘X&lt;/td&gt;
&lt;td&gt;Ctrl + X , Shift + Delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Copy current line to clipboard&lt;/td&gt;
&lt;td&gt;复制当前行&lt;/td&gt;
&lt;td&gt;⌘C&lt;/td&gt;
&lt;td&gt;Ctrl + C , Ctrl + Insert&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Paste from clipboard&lt;/td&gt;
&lt;td&gt;粘贴&lt;/td&gt;
&lt;td&gt;⌘V&lt;/td&gt;
&lt;td&gt;Ctrl + V , Shift + Insert&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Paste from recent buffers...&lt;/td&gt;
&lt;td&gt;从最近的缓冲区粘贴&lt;/td&gt;
&lt;td&gt;⌘⇧V&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + V&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Duplicate current line&lt;/td&gt;
&lt;td&gt;快速复制并粘贴当前行&lt;/td&gt;
&lt;td&gt;⌘D&lt;/td&gt;
&lt;td&gt;Ctrl + D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete line at caret&lt;/td&gt;
&lt;td&gt;删除选中的行&lt;/td&gt;
&lt;td&gt;⌘⌫&lt;/td&gt;
&lt;td&gt;Ctrl + Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart line join&lt;/td&gt;
&lt;td&gt;智能组合行&lt;/td&gt;
&lt;td&gt;⌃⇧J&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + J&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Smart line split&lt;/td&gt;
&lt;td&gt;智能拆分行&lt;/td&gt;
&lt;td&gt;⌘↩︎&lt;/td&gt;
&lt;td&gt;Ctrl + Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Start new line&lt;/td&gt;
&lt;td&gt;开始新的一行&lt;/td&gt;
&lt;td&gt;⇧↩︎&lt;/td&gt;
&lt;td&gt;Shift + Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Toggle case for word at caret or selected block&lt;/td&gt;
&lt;td&gt;在插入符号或选择块上切换单词大小写&lt;/td&gt;
&lt;td&gt;⌘⇧U&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+U&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Select till code block end / start&lt;/td&gt;
&lt;td&gt;选择直到代码块的结束/开始&lt;/td&gt;
&lt;td&gt;⌘⇧]/⌘⇧[&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+]/[&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete to word end&lt;/td&gt;
&lt;td&gt;删除到单词的结尾&lt;/td&gt;
&lt;td&gt;⌥⌦&lt;/td&gt;
&lt;td&gt;Ctrl + Delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete to word start&lt;/td&gt;
&lt;td&gt;删除到单词的开始&lt;/td&gt;
&lt;td&gt;⌥⌫&lt;/td&gt;
&lt;td&gt;Ctrl + Backspace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expand / collapse code block&lt;/td&gt;
&lt;td&gt;展开/折叠代码块&lt;/td&gt;
&lt;td&gt;⌘+/⌘-&lt;/td&gt;
&lt;td&gt;Ctrl + NumPad+ / -&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expand all&lt;/td&gt;
&lt;td&gt;展开所有&lt;/td&gt;
&lt;td&gt;⌘⇧+&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + NumPad+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Collapse all&lt;/td&gt;
&lt;td&gt;折叠所有&lt;/td&gt;
&lt;td&gt;⌘⇧-&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + NumPad-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Close active editor tab&lt;/td&gt;
&lt;td&gt;关闭活动编辑页&lt;/td&gt;
&lt;td&gt;⌘W&lt;/td&gt;
&lt;td&gt;Ctrl + F4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Refactoring&lt;br&gt;
重构&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Copy&lt;/td&gt;
&lt;td&gt;复制&lt;/td&gt;
&lt;td&gt;F5&lt;/td&gt;
&lt;td&gt;F5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Move&lt;/td&gt;
&lt;td&gt;移动&lt;/td&gt;
&lt;td&gt;F6&lt;/td&gt;
&lt;td&gt;F6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Safe Delete&lt;/td&gt;
&lt;td&gt;安全删除&lt;/td&gt;
&lt;td&gt;⌘⌫&lt;/td&gt;
&lt;td&gt;Alt + Delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rename&lt;/td&gt;
&lt;td&gt;重命名&lt;/td&gt;
&lt;td&gt;⇧F6&lt;/td&gt;
&lt;td&gt;Shift + F6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Refactor this&lt;/td&gt;
&lt;td&gt;重构当前&lt;/td&gt;
&lt;td&gt;⌃T&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+Shift+T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Change Signature&lt;/td&gt;
&lt;td&gt;更改签名&lt;/td&gt;
&lt;td&gt;⌘F6&lt;/td&gt;
&lt;td&gt;Ctrl + F6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Inline&lt;/td&gt;
&lt;td&gt;内联&lt;/td&gt;
&lt;td&gt;⌘⌥N&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract Method&lt;/td&gt;
&lt;td&gt;提取方法&lt;/td&gt;
&lt;td&gt;⌘⌥M&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + M&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract Variable&lt;/td&gt;
&lt;td&gt;提取变量&lt;/td&gt;
&lt;td&gt;⌘⌥V&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + V&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract Field&lt;/td&gt;
&lt;td&gt;提取自断&lt;/td&gt;
&lt;td&gt;⌘⌥F&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract Constant&lt;/td&gt;
&lt;td&gt;提取常量&lt;/td&gt;
&lt;td&gt;⌘⌥C&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extract Parameter&lt;/td&gt;
&lt;td&gt;提取参数&lt;/td&gt;
&lt;td&gt;⌘⌥P&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+P&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Navigation&lt;br&gt;
导航&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Go to class&lt;/td&gt;
&lt;td&gt;去到到某个类&lt;/td&gt;
&lt;td&gt;⌘O&lt;/td&gt;
&lt;td&gt;Ctrl + N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to file&lt;/td&gt;
&lt;td&gt;去到到某个文件&lt;/td&gt;
&lt;td&gt;⌘⇧O&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to symbol&lt;/td&gt;
&lt;td&gt;去到某个符号&lt;/td&gt;
&lt;td&gt;⌘⌥O&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+Shift+N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to next / previous editor tab&lt;/td&gt;
&lt;td&gt;去到前/后一个标签页&lt;/td&gt;
&lt;td&gt;⌃←/⌃→&lt;/td&gt;
&lt;td&gt;Alt + Right/Left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go back to previous tool window&lt;/td&gt;
&lt;td&gt;返回前一个工具窗口&lt;/td&gt;
&lt;td&gt;F12&lt;/td&gt;
&lt;td&gt;Alt + Right/Left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to editor (from tool window)&lt;/td&gt;
&lt;td&gt;转到编辑器（从工具窗口）&lt;/td&gt;
&lt;td&gt;⎋&lt;/td&gt;
&lt;td&gt;Esc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hide active or last active window&lt;/td&gt;
&lt;td&gt;隐藏活动或上一个活动窗口&lt;/td&gt;
&lt;td&gt;⇧⎋&lt;/td&gt;
&lt;td&gt;Shift + Esc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to line&lt;/td&gt;
&lt;td&gt;去到某一个行&lt;/td&gt;
&lt;td&gt;⌘L&lt;/td&gt;
&lt;td&gt;Ctrl + G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Recent files popup&lt;/td&gt;
&lt;td&gt;最近打开的文件&lt;/td&gt;
&lt;td&gt;⌘E&lt;/td&gt;
&lt;td&gt;Ctrl + E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Navigate back / forward&lt;/td&gt;
&lt;td&gt;导航后退/前进&lt;/td&gt;
&lt;td&gt;⌘⌥←/→&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + Left/Right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Navigate to last edit location&lt;/td&gt;
&lt;td&gt;导航到最后一个编辑的位置&lt;/td&gt;
&lt;td&gt;⌘⇧⌫&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + Backspace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Select current file or symbol in any view&lt;/td&gt;
&lt;td&gt;在任何视图中选择当前文件或符号&lt;/td&gt;
&lt;td&gt;⌥F1&lt;/td&gt;
&lt;td&gt;Alt + F1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to declaration&lt;/td&gt;
&lt;td&gt;去到声明的位置&lt;/td&gt;
&lt;td&gt;⌘B/⌘Click&lt;/td&gt;
&lt;td&gt;Ctrl + B , Ctrl + Click&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to implementation(s)&lt;/td&gt;
&lt;td&gt;去到实现的类&lt;/td&gt;
&lt;td&gt;⌘⌥B&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Open quick definition lookup&lt;/td&gt;
&lt;td&gt;打开快速定义查找&lt;/td&gt;
&lt;td&gt;⌥Space/⌘Y&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to type declaration&lt;/td&gt;
&lt;td&gt;去到类型声明&lt;/td&gt;
&lt;td&gt;⌃⇧B&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to super-method / super-class&lt;/td&gt;
&lt;td&gt;去到父方法/类&lt;/td&gt;
&lt;td&gt;⌘U&lt;/td&gt;
&lt;td&gt;Ctrl+U&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to previous / next method&lt;/td&gt;
&lt;td&gt;去到下一个/上一个方法&lt;/td&gt;
&lt;td&gt;⌃↑/↓&lt;/td&gt;
&lt;td&gt;Alt + Up/Down&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Move to code block end / start&lt;/td&gt;
&lt;td&gt;移动到代码块结束/开始&lt;/td&gt;
&lt;td&gt;⌘]/⌘[&lt;/td&gt;
&lt;td&gt;Ctrl + ]/[&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;File structure popup&lt;/td&gt;
&lt;td&gt;弹出文件结构&lt;/td&gt;
&lt;td&gt;⌘F12&lt;/td&gt;
&lt;td&gt;Ctrl + F12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type hierarchy&lt;/td&gt;
&lt;td&gt;类型层次&lt;/td&gt;
&lt;td&gt;⌃H&lt;/td&gt;
&lt;td&gt;Ctrl+H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Method hierarchy&lt;/td&gt;
&lt;td&gt;方法层次&lt;/td&gt;
&lt;td&gt;⌘⇧H&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Call hierarchy&lt;/td&gt;
&lt;td&gt;调用层次&lt;/td&gt;
&lt;td&gt;⌃⌥H&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Next / previous highlighted error&lt;/td&gt;
&lt;td&gt;下一个/上一个高亮错误&lt;/td&gt;
&lt;td&gt;F2/⇧F2&lt;/td&gt;
&lt;td&gt;F2/Shift+F2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edit source / View source&lt;/td&gt;
&lt;td&gt;编辑/查看源文件&lt;/td&gt;
&lt;td&gt;F4/⌘↓&lt;/td&gt;
&lt;td&gt;F4 / Ctrl + Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show navigation bar&lt;/td&gt;
&lt;td&gt;显示导航栏&lt;/td&gt;
&lt;td&gt;⌥Home&lt;/td&gt;
&lt;td&gt;Alt + Home&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Toggle bookmark&lt;/td&gt;
&lt;td&gt;切换书签&lt;/td&gt;
&lt;td&gt;F3&lt;/td&gt;
&lt;td&gt;F11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Toggle bookmark with mnemonic&lt;/td&gt;
&lt;td&gt;用助记符切换书签&lt;/td&gt;
&lt;td&gt;⌥F3&lt;/td&gt;
&lt;td&gt;Ctrl + F11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go to numbered bookmark&lt;/td&gt;
&lt;td&gt;转到对应编号书签&lt;/td&gt;
&lt;td&gt;⌃0…⌃9&lt;/td&gt;
&lt;td&gt;Ctrl + #[0-9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show bookmarks&lt;/td&gt;
&lt;td&gt;显示书签&lt;/td&gt;
&lt;td&gt;⌘F3&lt;/td&gt;
&lt;td&gt;Shift + F11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Compile and Run&lt;br&gt;
编译和运行&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Make project&lt;/td&gt;
&lt;td&gt;编译项目&lt;/td&gt;
&lt;td&gt;⌘F9&lt;/td&gt;
&lt;td&gt;Ctrl + F9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compile selected file, package or module&lt;/td&gt;
&lt;td&gt;编译选中的文件/包/模块&lt;/td&gt;
&lt;td&gt;⌘⇧F9&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + F9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Select configuration and run / debug&lt;/td&gt;
&lt;td&gt;选中配置并运行/调试&lt;/td&gt;
&lt;td&gt;⌃⌥R/D&lt;/td&gt;
&lt;td&gt;Alt + Shift + F10/F9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Run/Debug&lt;/td&gt;
&lt;td&gt;运行/调试&lt;/td&gt;
&lt;td&gt;⌃R/D&lt;/td&gt;
&lt;td&gt;Shift+F10/F9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Run context configuration from editor&lt;/td&gt;
&lt;td&gt;从编辑器运行上下文配置&lt;/td&gt;
&lt;td&gt;⌃⇧R/D&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + F10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Usage Search&lt;br&gt;
用法搜索&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Find usages / Find usages in file&lt;/td&gt;
&lt;td&gt;查找用法/查找文件中的用法&lt;/td&gt;
&lt;td&gt;⌥F7/⌘F7&lt;/td&gt;
&lt;td&gt;Alt + F7 / Ctrl + F7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Highlight usages in file&lt;/td&gt;
&lt;td&gt;高亮使用的文件&lt;/td&gt;
&lt;td&gt;⌘⇧F7&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + F7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Show usages&lt;/td&gt;
&lt;td&gt;显示用法&lt;/td&gt;
&lt;td&gt;⌘⌥F7&lt;/td&gt;
&lt;td&gt;Ctrl + Alt + F7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;VCS / Local History&lt;br&gt;
版本控制/本地历史&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Commit project to VCS&lt;/td&gt;
&lt;td&gt;提交项目到版本控制&lt;/td&gt;
&lt;td&gt;⌘K&lt;/td&gt;
&lt;td&gt;Ctrl + K&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Update project from VCS&lt;/td&gt;
&lt;td&gt;从版本控制更新项目&lt;/td&gt;
&lt;td&gt;⌘T&lt;/td&gt;
&lt;td&gt;Ctrl + T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Push commits&lt;/td&gt;
&lt;td&gt;推送提交&lt;/td&gt;
&lt;td&gt;⌘⇧K&lt;/td&gt;
&lt;td&gt;Ctrl + Shift + K&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;‘VCS’ quick popup&lt;/td&gt;
&lt;td&gt;快速弹出版本控制&lt;/td&gt;
&lt;td&gt;⌃V&lt;/td&gt;
&lt;td&gt;Alt + BackQuote (`)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Live Templates&lt;br&gt;
实时模版&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En&lt;/th&gt;
&lt;th&gt;CN&lt;/th&gt;
&lt;th&gt;MAC&lt;/th&gt;
&lt;th&gt;Win,Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Surround with Live Template&lt;/td&gt;
&lt;td&gt;环绕实时模版&lt;/td&gt;
&lt;td&gt;⌘⌥J&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+J&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Insert Live Template&lt;/td&gt;
&lt;td&gt;插入实时模版&lt;/td&gt;
&lt;td&gt;⌘J&lt;/td&gt;
&lt;td&gt;Ctrl+J&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">idea快捷键</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/use-solr-to-achieve-MySQL-based-query/"" data-c="
          &lt;p&gt;随着业务的数据量的不断增大，MySQL数据库的查询统计压力不断增加，不得不将数据的查询和统计功能转移到类似搜索引擎的应用服务器中。&lt;br&gt;
将数据转存到SolrCloud中，以前将介绍怎么使用Solr实现类似MySQL的基础查询功能。&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;设计如下数据结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; desc call_record;
+-------------+-------------+------+-----+---------+----------------+
| Field       | Type        | Null | Key | Default | Extra          |
+-------------+-------------+------+-----+---------+----------------+
| id          | int(11)     | NO   | PRI | NULL    | auto_increment |
| fm          | varchar(64) | YES  |     | NULL    |                |
| vm          | varchar(11) | YES  | MUL | NULL    |                |
| tm          | varchar(64) | YES  |     | NULL    |                |
| status      | int(11)     | YES  |     | NULL    |                |
| startTime   | datetime    | YES  |     | NULL    |                |
| endTime     | datetime    | YES  |     | NULL    |                |
| callMinutes | int(11)     | YES  |     | 0       |                |
+-------------+-------------+------+-----+---------+----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面通过给出相关SQL查询统计语句，然后对方翻译成Solr查询语句。&lt;/p&gt;
&lt;h1 id=&#34;普通查询&#34;&gt;普通查询&lt;/h1&gt;
&lt;p&gt;SQL查询语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select id,fm,vm,tm,callMinutes from call_record where 
    status=0 and startTime&amp;gt;=&#39;2017-03-31&#39; order by id desc limit 0,10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询URL：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?
    q=status:0&amp;amp;fq=startTime[2017-03-31T00:00:00 TO *]&amp;amp;fl=id,fm,vm,tm,callMinutes
    &amp;amp;sort=id desc&amp;amp;start=0&amp;amp;rows=10&amp;amp;wt=xml&amp;amp;indent=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;统计&#34;&gt;统计&lt;/h1&gt;
&lt;p&gt;SQL查询语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select sum(callMinutes),avg(callMinutes),max(callMinutes),min(callMinutes) 
    from call_record where status=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询URL：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?
    q=status:0&amp;amp;rows=0&amp;amp;wt=xml&amp;amp;indent=true&amp;amp;stats=on&amp;amp;stats.field=callMinutes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询的结果包括以下统计数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;min             最小值
max             最大值
sum             总和
count           记录数，也就是多少行记录
missing         结果集中，有多少条记录是空值
sumOfSquares    平方和（x1^2 + x2^2+xn^2）
mean            平均数（x1+x2+xn）/n
stddev          标准差
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;in查询&#34;&gt;IN查询&lt;/h1&gt;
&lt;p&gt;SQL查询语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select * from call_record where status in (0,1) order by id desc limit 0,10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询URL：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?
    q=(status:0 OR status:1)&amp;amp;fl=id,fm,vm,tm,callMinutes
    &amp;amp;sort=id desc&amp;amp;start=0&amp;amp;rows=10&amp;amp;wt=xml&amp;amp;indent=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;字段分组统计次数&#34;&gt;字段分组统计次数&lt;/h1&gt;
&lt;p&gt;SQL查询语句:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select fm,count(callMinutes) from call_record where status=0 group by fm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询URL-01：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?
    q=status:0&amp;amp;rows=0&amp;amp;wt=json&amp;amp;indent=true&amp;amp;facet=on&amp;amp;facet.field=fm&amp;amp;facet.limit=-1

注：
    facet.limit=-1表示查询出所有的记录
    这个查询查询比较耗费资源不建议键facet.limit设置为-1
    这里的结果集默认按照count降序排列，还可设置facet.solr=index表示按照fm进行自然排序
    当然Solr还支持只查询出次数大于10次的记录facet.mincount=10
    需要查询fm的数量时会相对比较麻烦，只能将所有的结果查询出来；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询URL-02&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?
    q=status:0&amp;amp;rows=10&amp;amp;wt=json&amp;amp;indent=true&amp;amp;group=true&amp;amp;group.field=fm&amp;amp;group.limit=1

注：
    如果对于集群应用时，不能使用group进行查询，结果集会不准确
    如果自行控制，将需要group的数据存放在同一个分片中时才能使用；
    不支持结果集排序
    不支持查询出次数大于10次的记录
    需要查询fm的数量时比较方便，增加group.ngrouops=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;字段分组统计&#34;&gt;字段分组统计&lt;/h1&gt;
&lt;p&gt;SQL查询语句:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select fm,count(callMinutes),sum(callMinutes),avg(callMinutes),
    max(callMinutes),min(callMinutes) from call_record where status=0 group by fm

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solr查询URL：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?
    q=status:0&amp;amp;rows=0&amp;amp;wt=json&amp;amp;indent=true&amp;amp;stats=on
    &amp;amp;stats.field={!tag=piv1}callMinutes
    &amp;amp;facet=on&amp;amp;facet.pivot={!stats=piv1}fm&amp;amp;facet.mincount=1&amp;amp;facet.limit=10

注：
    不支持排序
    需要查询出fm的数量只能查询出全量数据
&lt;/code&gt;&lt;/pre&gt;
">使用Solr实现MySQL基础查询</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/java-singleton/"" data-c="
          &lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是容易不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对Java中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;懒汉式-非线程安全&#34;&gt;懒汉式-非线程安全&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Singleton {
	private static Singleton instance = null;
	private Singleton() { }
	public static Singleton getInstance() {
		if (null == instance)
			instance = new Singleton();
		return instance;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法可以实现延时加载，但是有一个致命弱点：&lt;strong&gt;线程不安全&lt;/strong&gt;。如果有两条线程同时调用getInstance()方法，就有很大可能导致重复创建对象。&lt;/p&gt;
&lt;p&gt;懒汉式-线程安全&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Singleton {
	private volatile static Singleton instance = null;
	private Singleton() { }
	public staitc Singleton getInstance() {
		if (null == instance) {
			synchronized (Singleton.class) {
				if (null == instance) {
					instance = new Singleton();
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;饿汉式&#34;&gt;饿汉式&lt;/h1&gt;
&lt;p&gt;顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Singleton {
	private static instance = new Singleton();
	private Singleton() { }
	public static Singleton getInstance() {
		return instance;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载就需要懒汉式单例模式。&lt;/p&gt;
&lt;h1 id=&#34;饿汉式-static-final&#34;&gt;饿汉式-static final&lt;/h1&gt;
&lt;p&gt;这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Singleton {
	private static final Singleton instance = new Singleton();
	private Singleton() { }
	public static Singleton getInstance() {
		return instance;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式，单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。&lt;br&gt;
饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。&lt;/p&gt;
&lt;h1 id=&#34;静态内部类&#34;&gt;静态内部类&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Singleton {
	private Singleton() { }
	private static class Holder {
		private static Singleton instance = new Singleton();
	}
	public static Singleton getInstance() {
		return Holder.instance;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;
&lt;h1 id=&#34;枚举&#34;&gt;枚举&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Singleton {
	INSTANCE;
	private String name;
	public String getName() {
		return name;
	}
	public void setName() {
		this.name = name;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，推荐尽可能地使用枚举来实现单例。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;除枚举外其他的实现都有两个共同的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都需要额外的工作来实现序列化，否则反序列化时都会创建一个新的实例&lt;/li&gt;
&lt;li&gt;可能会有人使用反射强行调用我们的私有构造器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般程序而言，一般直接使用饿汉式(静态常量)即可，如果需要懒加载倾向使用静态内部类，如果确实需要反序列化时可以试着使用枚举来实现；&lt;/p&gt;
">java 单例模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/java-volatile/"" data-c="
          &lt;p&gt;Java语言包括两种同步机制：同步块和volatile变量，都是为了实现线程的安全性。其中volatile同步性相对弱一些，所以相对容易出错；&lt;/p&gt;
&lt;h1 id=&#34;-more-volatile变量&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
volatile变量&lt;/h1&gt;
&lt;p&gt;volitile关键字用来修饰字段，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性；&lt;br&gt;
通过同步锁实现volatile效果示例理解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class VolatileFeaturesExample {
	volatile long vl = 0L;
	public void set(long vl) {
		this.vl = vl;
	}
	public void getAndIncrement() {
		vl ++;
	}
	public long get() {
		return vl;
	}
}
class VolatileFeaturesExample {
	long vl = 0L;
	public synchronized void set(long vl) {
		this.vl = vl;
	}
	public void getAndIncrement() {
		long temp = get();
		temp += 1L;
		set(temp);
	}
	public synchronized long get() {
		return vl;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;正确使用volatile变量的条件&#34;&gt;正确使用volatile变量的条件&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;对变量的写操作不依赖于当前值&lt;/li&gt;
&lt;li&gt;该变量没有包含在具有其他变量的不变式中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述：被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。&lt;/p&gt;
&lt;h1 id=&#34;使用volatile关键字的场景&#34;&gt;使用volatile关键字的场景&lt;/h1&gt;
&lt;h2 id=&#34;状态标记量&#34;&gt;状态标记量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;volatile boolean flag;
public void setFlag(boolean flag) {
	this.flag = flag;
}
public void doWork() {
	while (!flag) {
		// do stuff
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一次性安全发布&#34;&gt;一次性安全发布&lt;/h2&gt;
&lt;p&gt;在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。&lt;br&gt;
实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。示例清单如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Singleton {
	private volatile static Singleton instance = null;
	private Singleton() { }
	public static Singleton getInstance() {
		if (null == instance) {
			synchronized (Singleton.class) {
				if (null == instance) 
					instance = new Singleton();
			}
		}
		return instance;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里为什么需要instance变量使用volatile关键字修饰，因为变量的创建分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、分配对象的内存空间&lt;/li&gt;
&lt;li&gt;2、初始化对象&lt;/li&gt;
&lt;li&gt;3、设置变量指向内存地址&lt;br&gt;
然而在一些JIT编译器上，上述流程中的2、3步可能会被重排序。&lt;br&gt;
根据Java语言规范，所有线程在执行Java程序时必须要遵守intra-thread semantics。&lt;br&gt;
intra-thread semantics 保证重排序不会改变单线程内的程序执行过程。换句话说，intra-thread semantics 允许哪些在单线程内，不会改变单线程程序执行结果的重排序。故上述流程的2和3之间虽然重排序了，但这个重排序不会违反intra-thread semantics 。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开销较低的读-写锁策略&#34;&gt;开销较低的读－写锁策略&lt;/h2&gt;
&lt;p&gt;volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。&lt;br&gt;
然而，如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。代码清单如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class CheeysCounter {
	private volatile int value;
	public int getValue() {
		return value;
	}
	public synchronized int increment() {
		return value ++;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器，所以必须使用锁。&lt;br&gt;
故可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。&lt;/p&gt;
">java volatile 关键字理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/delete-maven-failure-jar/"" data-c="
          &lt;p&gt;用过Maven的应该都遇到过，当网速不好或者源有问题的时候，Maven的依赖包经常下载失败。 下载失败后在本地仓库对应的文件夹中有一个以.lastUpdated结尾的文件，如果不手动删除这个文件，就不能重新更新依赖，重新下载对应的jar包。&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;一般情况下遇到的时候可能直接手动找到目录删除。&lt;/p&gt;
&lt;p&gt;当出现很多这样的情况时，一个个找起来也很麻烦。&lt;/p&gt;
&lt;p&gt;因此本文提供一个小工具，就是一段Java代码，通过这段代码来删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;

public class CleanMvnFailure {

	public static void main(String[] args) {
		if (args.length != 1) {
			System.out.println(&amp;quot;please input maven factory path:&amp;quot;);
		}
		findAndDelete(new File(args[0]));
	}

	private static boolean findAndDelete(File file) {
		if (!file.exists()) {
		} else if (file.isFile()) {
			if (file.getName().endsWith(&amp;quot;lastUpdated&amp;quot;)) {
				deleteFile(file.getParentFile());
				return true;
			}
		} else if (file.isDirectory()) {
			File[] files = file.listFiles();
			for (File f : files) {
				if (findAndDelete(f)) {
					break;
				}
			}
		}
		return false;
	}

	private static void deleteFile(File file) {
		if (!file.exists()) {
		} else if (file.isFile()) {
			print(&amp;quot;删除文件:&amp;quot; + file.getAbsolutePath());
			file.delete();
		} else if (file.isDirectory()) {
			File[] files = file.listFiles();
			for (File f : files) {
				deleteFile(f);
			}
			print(&amp;quot;删除文件夹:&amp;quot; + file.getAbsolutePath());
			print(&amp;quot;====================================&amp;quot;);
			file.delete();
		}
	}

	private static void print(String msg) {
		System.out.println(msg);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在工具上运行该段代码，则自行修改传入本地仓库路径的方法；&lt;/p&gt;
&lt;p&gt;如果在命令行下运行则：&lt;br&gt;
首先编译java文件：javac CleanMvnFailure.java&lt;br&gt;
再运行对应的class文件：java CleanMvnFailure &amp;quot;D:\Program Files\maven_factory&amp;quot;&lt;br&gt;
因为路径中带空格，须用引号引起来&lt;/p&gt;
">批量删除Maven下载失败的文件夹</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/zookeeper-install/"" data-c="
          &lt;h2 id=&#34;单机安装zookeeper&#34;&gt;单机安装zookeeper&lt;/h2&gt;
&lt;p&gt;1、下载响应版本的zookeeper&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、解压安装文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -xzvf zookeeper-3.4.6.tar.gz
mv zookeeper-3.4.6 zookeeper
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;3、配置zoo.cfg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd zookeeper/conf
cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
	tickTime=2000 
	dataDir=/opt/server/zookeeper/data 
	clientPort=2181
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**tickTime：**这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。&lt;br&gt;
**dataDir：**Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。&lt;br&gt;
**clientPort：**这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。&lt;/p&gt;
&lt;h2 id=&#34;集群安装zookeeper&#34;&gt;集群安装zookeeper&lt;/h2&gt;
&lt;p&gt;1、下载响应版本的zookeeper&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、解压安装文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -xzvf zookeeper-3.4.6.tar.gz
mv zookeeper-3.4.6 zookeeper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、配置zoo.cfg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd zookeeper/conf
cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
	tickTime=2000 
	initLimit=5
	syncLimit=2
	dataDir=/opt/server/zookeeper/data
	clientPort=2181
	server.1=192.168.1.111:2888:3888
	server.2=192.168.1.112:2888:3888
	server.3=192.168.1.113:2888:3888
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中tickTime，dataDir，clientPort参数与单机模式一致；&lt;br&gt;
**initLimit：**这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5&lt;em&gt;2000=10 秒。&lt;br&gt;
**syncLimit：**这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个tickTime的时间长度，总的时间长度就是 2&lt;/em&gt;2000=4 秒。&lt;br&gt;
&lt;strong&gt;server.A=B：C：D&lt;/strong&gt;，其中：&lt;br&gt;
A 是一个数字，表示第几号服务器；&lt;br&gt;
B 该服务器IP地址；&lt;br&gt;
C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口&lt;br&gt;
D表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：如果是伪集群的配置方式，由于 B 都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、在dataDir对应的目录下建立名为myid的文件，内容值为A值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /opt/server/zookeeper/data/myid
	1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有参与集群的主机按照上面配置，唯一不同即myid的值，与zoo.cfg中A值对应即可。&lt;br&gt;
&lt;strong&gt;注意：这里的A值与之前配置的server.x对应，各个节点对应各自的myid&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;zookeeper配置jvm&#34;&gt;zookeeper配置JVM&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vim /opt/server/zookeeper/bin/zkServer.sh 
	start)
	    echo  -n &amp;quot;Starting zookeeper ... &amp;quot;
	    if [ -f &amp;quot;$ZOOPIDFILE&amp;quot; ]; then
	      if kill -0 `cat &amp;quot;$ZOOPIDFILE&amp;quot;` &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then
	         echo $command already running as process `cat &amp;quot;$ZOOPIDFILE&amp;quot;`.
	         exit 0
	      fi
	    fi
	    nohup &amp;quot;$JAVA&amp;quot; &amp;quot;-Dzookeeper.log.dir=${ZOO_LOG_DIR}&amp;quot; &amp;quot;-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}&amp;quot; \
	    -cp &amp;quot;$CLASSPATH&amp;quot; -server -Xms128m -Xmx256m -Xmn64m -XX:PermSize=65m $ZOOMAIN &amp;quot;$ZOOCFG&amp;quot; &amp;gt; &amp;quot;$_ZOO_DAEMON_OUT&amp;quot; 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;
	    #-cp &amp;quot;$CLASSPATH&amp;quot; $JVMFLAGS $ZOOMAIN &amp;quot;$ZOOCFG&amp;quot; &amp;gt; &amp;quot;$_ZOO_DAEMON_OUT&amp;quot; 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;
	    #对应修改以上两行，注意这里不能在-cp之前使用注释之类的行，它对前一行一起作为命令执行
	    if [ $? -eq 0 ]
	    then
	      if /bin/echo -n $! &amp;gt; &amp;quot;$ZOOPIDFILE&amp;quot;
	      then
	        sleep 1
	        echo STARTED
	      else
	        echo FAILED TO WRITE PID
	        exit 1
	      fi
	    else
	      echo SERVER DID NOT START
	      exit 1
	    fi
	    ;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动zookeeper后可使用jmap -heap [pid]命令查看当前进程内存使用情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps -ef | grep zookeeper
找到对应的[pid]
jmap -heap 8761
	Attaching to process ID 8761, please wait...
	Debugger attached successfully.
	Server compiler detected.
	JVM version is 24.79-b02

	using thread-local object allocation.
	Parallel GC with 4 thread(s)

	Heap Configuration:
	   MinHeapFreeRatio = 0
	   MaxHeapFreeRatio = 100
	   MaxHeapSize      = 268435456 (256.0MB)
	   NewSize          = 67108864 (64.0MB)
	   MaxNewSize       = 67108864 (64.0MB)
	   OldSize          = 5439488 (5.1875MB)
	   NewRatio         = 2
	   SurvivorRatio    = 8
	   PermSize         = 68157440 (65.0MB)
	   MaxPermSize      = 85983232 (82.0MB)
	   G1HeapRegionSize = 0 (0.0MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;启动并测试zookeeper&#34;&gt;启动并测试zookeeper&lt;/h2&gt;
&lt;p&gt;1、启动zookeeper服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /opt/server/zookeeper/bin
./zkServer.sh start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、查看zookeeper服务状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./zkServer.sh status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、停止zookeeper服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./zkServer.sh stop
&lt;/code&gt;&lt;/pre&gt;
">zookeeper 安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-other-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;DEFAULT(col_name)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;
函数使用说明：将数字 X 的格式写为 &#39;#,###,###.##&#39;, 以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若   D 为 0, 则返回结果不带有小数点，或不含小数部分。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;GET_LOCK(str ,timeout)&lt;/strong&gt;&lt;br&gt;
函数使用说明：设法使用字符串 str 给定的名字得到一个锁， 超时为 timeout 秒。若成功得到锁，则返回 1 ，若操作超时则返回 0 ( 例如 , 由于另一个客户端已提前封锁了这个名字 ), 若发生错误则返回 NULL ( 诸如缺乏记忆或线程 mysqladmin kill 被断开 ) 。假如你有一个用 GET_LOCK() 得到的锁，当你执行 RELEASE_LOCK() 或你的连接断开 ( 正常或非正常 ) 时，这个锁就会解除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INET_ATON(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是 4 或 8 比特地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INET_NTOA(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：给定一个数字网络地址 (4 或 8 比特 ), 返回作为字符串的该地址的电地址表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IS_FREE_LOCK(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：检查名为 str 的锁是否可以使用 ( 换言之 , 没有被封锁 ) 。若锁可以使用，则返回   1 ( 没有人在用这个锁 ), 若这个锁正在被使用，则返回 0 ，出现错误则返回 NULL ( 诸如不正确的参数 ) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IS_USED_LOCK(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：检查名为 str 的锁是否正在被使用 ( 换言之 , 被封锁 ) 。若被封锁，则返回使用该锁的客户端的连接标识符。否则返回 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MASTER_POS_WAIT(log_name ,log_pos [,timeout ])&lt;/strong&gt;&lt;br&gt;
函数使用说明：该函数对于控制主从同步很有用处。它会持续封锁，直到从设备阅读和应用主机记录中所有补充资料到指定的位置。返回值是其为到达指定位置而必须等待的记录事件的数目。若从设备 SQL 线程没有被启动、从设备主机信息尚未初始化、参数不正确或出现任何错误，则该函数返回 NULL 。若超时时间被超过，则返回 -1 。若在 MASTER_POS_WAIT() 等待期间，从设备 SQL 线程中止，则该函数返回 NULL 。若从设备由指定位置通过，则函数会立即返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAME_CONST(name ,value)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回给定值。 当用来产生一个结果集合列时 , NAME_CONST() 促使该列使用给定名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RELEASE_LOCK(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：解开被 GET_LOCK() 获取的，用字符串 str 所命名的锁。若锁被解开，则返回   1 ，若改线程尚未创建锁，则返回 0 ( 此时锁没有被解开 ), 若命名的锁不存在，则返回 NULL 。若该锁从未被对 GET_LOCK() 的调用获取，或锁已经被提前解开，则该锁不存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SLEEP(duration)&lt;/strong&gt;&lt;br&gt;
函数使用说明：睡眠 ( 暂停 ) 时间为 duration 参数给定的秒数，然后返回 0 。若 SLEEP() 被中断 , 它会返回 1 。 duration 或许或包括一个给定的以微秒为单位的分数部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UUID()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个通用唯一标识符 (UUID) ， UUID 被设计成一个在时间和空间上都独一无二的数字。 2 个对 UUID() 的调用应产生 2 个不同的值，即使这些调用的执行是在两个互不相连的单独电脑上进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VALUES(col_name)&lt;/strong&gt;&lt;br&gt;
函数使用说明：在一个 INSERT … ON DUPLICATE KEY UPDATE … 语句中，你可以在 UPDATE 子句中使用 VALUES(col_name ) 函数，用来访问来自该语句的 INSERT 部分的列值。换言之， UPDATE 子句中的 VALUES(col_name ) 访问需要被插入的 col_name 的值 , 并不会发生重复键冲突。这个函数在多行插入中特别有用。   VALUES() 函数只在 INSERT ... UPDATE 语句中有意义，而在其它情况下只会返回 NULL&lt;/p&gt;
">mysql 其他函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-aggregate-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;AVG([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIT_AND(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 中所有比特的 bitwise AND 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则这个函数返回18446744073709551615 。( 这是无符号 BIGINT 值，所有比特被设置为 1 ）。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;BIT_OR(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 中所有比特的bitwise OR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIT_XOR(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 中所有比特的bitwise XOR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COUNT(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回SELECT 语句检索到的行中非NULL 值的数目。若找不到匹配的行，则COUNT() 返回 0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COUNT(DISTINCT expr ,[expr ...])&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回不同的非NULL 值数目。若找不到匹配的项，则COUNT(DISTINCT) 返回 0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GROUP_CONCAT(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：该函数返回带有来自一个组的连接的非NULL 值的字符串结果。其完整的语法如下所示：&lt;br&gt;
GROUP_CONCAT([DISTINCT] expr [,expr ...] [ORDER BY {unsigned_integer | col_name | expr } [ASC | DESC] [,col_name ...]] [SEPARATOR str_val ])&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MIN([DISTINCT] expr), MAX([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 expr 的最小值和最大值。 MIN() 和 MAX() 的取值可以是一个字符串参数；在这些情况下， 它们返回最小或最大字符串值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STD(expr) STDDEV(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 expr 的总体标准偏差。这是标准 SQL 的延伸。这个函数的 STDDEV() 形式用来提供和 Oracle 的兼容性。可使用标准 SQL 函数 STDDEV_POP() 进行代替&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STDDEV_POP(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 的总体标准偏差(VAR_POP() 的平方根) 。你也可以使用 STD() 或STDDEV(), 它们具有相同的意义，然而不是标准的 SQL 。若找不到匹配的行，则STDDEV_POP() 返回 NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STDDEV_SAMP(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 的样本标准差 ( VAR_SAMP() 的平方根) 。若找不到匹配的行，则STDDEV_SAMP() 返回 NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SUM([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 的总数。 若返回集合中无任何行，则 SUM() 返回NULL 。DISTINCT 关键词可用于 MySQL 5.1 中，求得expr 不同值的总和。 若找不到匹配的行，则SUM() 返回 NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VAR_POP(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 expr 总体标准方差。它将行视为总体，而不是一个样本， 所以它将行数作为分母。你也可以使用 VARIANCE(), 它具有相同的意义然而不是 标准的 SQL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VAR_SAMP(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 的样本方差。更确切的说，分母的数字是行数减去1 。若找不到匹配的行，则VAR_SAMP() 返回NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VARIANCE(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回expr 的总体标准方差。这是标准SQL 的延伸。可使用标准SQL 函数 VAR_POP() 进行代替。若找不到匹配的项，则VARIANCE() 返回NULL&lt;/p&gt;
">mysql 聚合函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-information-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;BENCHMARK(count ,expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算   MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户端内部 , 能够报告问询执行的次数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CHARSET(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串自变量的字符集。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;COERCIBILITY(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串自变量的整序可压缩性值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COLLATION(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串参数的排序方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONNECTION_ID()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回对于连接的连接 ID ( 线程 ID) 。每个连接都有各自的唯一 ID 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURRENT_USER, CURRENT_USER()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前话路被验证的用户名和主机名组合。这个值符合确定你的存取权限的 MySQL 账户。在被指定 SQL SECURITY DEFINER 特征的存储程序内， CURRENT_USER() 返回程序的创建者&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATABASE()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回使用 utf8 字符集的默认 ( 当前 ) 数据库名。在存储程序里，默认数据库是同该程序向关联的数据库，但并不一定与调用语境的默认数据库相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FOUND_ROWS()&lt;/strong&gt;&lt;br&gt;
函数使用说明： A SELECT 语句可能包括一个 LIMIT 子句，用来限制服务器返回客户端的行数。在有些情况下，需要不用再次运行该语句而得知在没有 LIMIT 时到底该语句返回了多少行。为了知道这个行数 , 包括在 SELECT 语句中选择   SQL_CALC_FOUND_ROWS ，随后调用 FOUND_ROWS()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LAST_INSERT_ID() LAST_INSERT_ID(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：自动返回最后一个 INSERT 或 UPDATE 问询为 AUTO_INCREMENT 列设置的第一个 发生的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ROW_COUNT()&lt;/strong&gt;&lt;br&gt;
函数使用说明： ROW_COUNT() 返回被前面语句升级的、插入的或删除的行数。 这个行数和 mysql 客户端显示的行数及 mysql_affected_rows() C API 函数返回的值相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SCHEMA()&lt;/strong&gt;&lt;br&gt;
函数使用说明：这个函数和 DATABASE() 具有相同的意义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SESSION_USER()&lt;/strong&gt;&lt;br&gt;
函数使用说明： SESSION_USER() 和 USER() 具有相同的意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYSTEM_USER()&lt;/strong&gt;&lt;br&gt;
函数使用说明： SYSTEM_USER() 合 USER() 具有相同的意义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USER()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前 MySQL 用户名和机主名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VERSION()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回指示 MySQL 服务器版本的字符串。这个字符串使用 utf8 字符集。&lt;/p&gt;
">mysql 信息函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-enctyption-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;AES_ENCRYPT(str ,key_str) , AES_DECRYPT(crypt_str ,key_str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “Rijndael” 。 保密关键字的长度为 128 比特，不过你可以通过改变源而将其延长到 256 比特。我们选择了 128 比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DECODE(crypt_str ,pass_str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：使用 pass_str 作为密码，解密加密字符串 crypt_str ， crypt_str 应该是由 ENCODE() 返回的字符串。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;ENCODE(str ,pass_str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：使用 pass_str 作为密码，解密 str 。 使用 DECODE() 解密结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DES_DECRYPT(crypt_str [,key_str ])&lt;/strong&gt;&lt;br&gt;
函数使用说明：使用 DES_ENCRYPT() 加密一个字符串。若出现错误，这个函数会返回 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DES_ENCRYPT(str [,(key_num |key_str )])&lt;/strong&gt;&lt;br&gt;
函数使用说明：用 Triple-DES 算法给出的关键字加密字符串。若出现错误，这个函数会返回 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENCRYPT(str [,salt ])&lt;/strong&gt;&lt;br&gt;
函数使用说明：使用 Unix crypt() 系统调用加密 str 。 salt 参数应为一个至少包含 2 个字符的字符串。若没有给出 salt 参数，则使用任意值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MD5(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：为字符串算出一个 MD5 128 比特检查和。该值以 32 位十六进制数字的二进制字符串的形式返回 , 若参数为 NULL 则会返回 NULL 。例如，返回值可被用作散列关键字&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OLD_PASSWORD(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：当 PASSWORD() 的执行变为改善安全性时， OLD_PASSWORD() 会被添加到 MySQL 。 OLD_PASSWORD() 返回从前的 PASSWORD() 执行值 ( 4.1 之前 ) ，同时允许你为任何 4.1 之前的需要连接到你的 5.1 版本 MySQL 服务器前客户端设置密码，从而不至于将它们切断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PASSWORD(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：从原文密码str 计算并返回密码字符串，当参数为 NULL 时返回 NULL 。这个函数用于用户授权表的Password 列中的加密MySQL 密码存储&lt;/p&gt;
">mysql 加密函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-full-text-search-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])&lt;/strong&gt;&lt;br&gt;
使用Mysql全文检索fulltext的先决条件&lt;br&gt;
表的类型必须是MyISAM&lt;br&gt;
建立全文检索的字段类型必须是char,varchar,text&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;建立全文检索先期配置&lt;br&gt;
ft_wordlist_charset 表示词典的字符集, 目前支持良好的有(UTF-8, gbk, gb2312, big5)&lt;br&gt;
ft_wordlist_file 是词表文件, 每行包括一个词及其词频(用若干制表符或空格分开,消岐专用)&lt;br&gt;
ft_stopword_file 表示过滤掉不索引的词表, 一行一个.&lt;br&gt;
ft_min_word_len     加入索引的词的最小长度, 缺省是 4, 为了支持中文单字故改为 2&lt;/p&gt;
&lt;p&gt;建立全文检索&lt;br&gt;
在建表中用FullText关键字标识字段,已存在的表用 ALTER TABLE (或 CREATE INDEX) 创建索引&lt;br&gt;
CREATE fulltext INDEX index_name ON table_name(colum_name);&lt;/p&gt;
&lt;p&gt;使用全文检索&lt;br&gt;
在SELECT的WHERE字句中用MATCH函数,索引的关键词用AGAINST标识,IN BOOLEAN MODE是只有含有关键字就行,不用在乎位置,是不是起启位置.&lt;br&gt;
SELECT * FROM articles WHERE MATCH (tags) AGAINST (&#39;旅游&#39; IN BOOLEAN MODE);&lt;/p&gt;
">mysql 全文检索函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-date-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;ADDDATE(date ,INTERVAL expr type) ADDDATE(expr ,days)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数 SUBDATE() 则是 DATE_SUB() 的同义词。对于 INTERVAL 参数上的信息 ，请参见关于 DATE_ADD() 的论述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ADDTIME(expr ,expr2)&lt;/strong&gt;&lt;br&gt;
函数使用说明： ADDTIME() 将 expr2 添加至 expr 然后返回结果。 expr 是一个时间或时间日期表达式，而 expr2 是一个时间表达式。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;CONVERT_TZ(dt ,from_tz ,to_tz)&lt;/strong&gt;&lt;br&gt;
函数使用说明： CONVERT_TZ() 将时间日期值 dt 从 from_tz 给出的时区转到 to_tz 给出的时区，然后返回结果值。关于可能指定的时区的详细论述，若自变量无效，则这个函数会返回 NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURDATE()&lt;/strong&gt;&lt;br&gt;
函数使用说明：将当前日期按照 &#39;YYYY-MM-DD&#39; 或 YYYYMMDD 格式的值返回，具体格式根据函数用在字符串或是数字语境中而定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURRENT_DATE CURRENT_DATE()&lt;/strong&gt;&lt;br&gt;
函数使用说明： CURRENT_DATE 和 CURRENT_DATE() 是的同义词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURTIME()&lt;/strong&gt;&lt;br&gt;
函数使用说明： 将当前时间以 &#39;HH:MM:SS&#39; 或 HHMMSS 的格式返回， 具体格式根据函数用在字符串或是数字语境中而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURRENT_TIME, CURRENT_TIME()&lt;/strong&gt;&lt;br&gt;
函数使用说明： CURRENT_TIME 和 CURRENT_TIME() 是 CURTIME() 的同义词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURRENT_TIMESTAMP, CURRENT_TIMESTAMP()&lt;/strong&gt;&lt;br&gt;
函数使用说明： CURRENT_TIMESTAMP 和 CURRENT_TIMESTAMP() 是 NOW() 的同义词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATE(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 提取日期或时间日期表达式 expr 中的日期部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATEDIFF(expr ,expr2)&lt;/strong&gt;&lt;br&gt;
函数使用说明： DATEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的天数。 Expr 和 expr2 为日期或 date-and-time 表达式。计算中只用到这些值的日期部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATE_ADD(date ,INTERVAL expr type) DATE_SUB(date ,INTERVAL expr type)&lt;/strong&gt;&lt;br&gt;
函数使用说明：这些函数执行日期运算。 date 是一个 DATETIME 或 DATE 值，用来指定起始时间。 expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。   Expr 是一个字符串 ; 对于负值的时间间隔，它可以以一个 ‘-’ 开头。 type 为关键词，它指示了表达式被解释的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATE_FORMAT(date ,format)&lt;/strong&gt;&lt;br&gt;
函数使用说明：根据 format 字符串安排 date 值的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAY(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明： DAY() 和 DAYOFMONTH() 的意义相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAYNAME(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date 对应的工作日名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAYOFMONTH(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date 对应的该月日期，范围是从 1 到 31&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAYOFWEEK(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date (1 = 周日 , 2 = 周一 , ..., 7 = 周六 ) 对应的工作日索引。这些索引值符合 ODBC 标准&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAYOFYEAR(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回date 对应的一年中的天数，范围是从 1 到366 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXTRACT(type FROM date)&lt;/strong&gt;&lt;br&gt;
函数使用说明： EXTRACT() 函数所使用的时间间隔类型说明符同 DATE_ADD() 或 DATE_SUB() 的相同 , 但它从日期中提取其部分，而不是执行日期运算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FROM_DAYS(N)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 给定一个天数N , 返回一个 DATE 值。&lt;/p&gt;
&lt;p&gt;** FROM_UNIXTIME(unix_timestamp )ROM_UNIXTIME(unix_timestamp ,format)**&lt;br&gt;
函数使用说明：返回&#39;YYYY-MM-DD HH:MM:SS&#39; 或YYYYMMDDHHMMSS 格式值的unix_timestamp 参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。 若format 已经给出，则结果的格式是根据format 字符串而定。 format 可以包含同DATE_FORMAT() 函数输入项列表中相同的说明符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET_FORMAT(DATE|TIME|DATETIME, &#39;EUR&#39;|&#39;USA&#39;|&#39;JIS&#39;|&#39;ISO&#39;|&#39;INTERNAL&#39;)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个格式字符串。这个函数在同 DATE_FORMAT() 及 STR_TO_DATE() 函数结合时很有用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HOUR(time)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 time 对应的小时数。对于日时值的返回值范围是从 0 到 23&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LAST_DAY(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCALTIME, LOCALTIME()&lt;/strong&gt;&lt;br&gt;
函数使用说明： LOCALTIME 及 LOCALTIME() 和 NOW() 具有相同意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCALTIMESTAMP, LOCALTIMESTAMP()&lt;/strong&gt;&lt;br&gt;
函数使用说明： LOCALTIMESTAMP 和 LOCALTIMESTAMP() 和 NOW() 具有相同意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAKEDATE(year ,dayofyear)&lt;/strong&gt;&lt;br&gt;
函数使用说明：给出年份值和一年中的天数值，返回一个日期。 dayofyear 必须大于 0 ，否则结果为 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAKETIME(hour ,minute ,second)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回由 hour 、 minute 和 second 参数计算得出的时间值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CROSECOND(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：从时间或日期时间表达式 expr 返回微秒值，其数字范围从 0 到 999999 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MINUTE(time)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 time 对应的分钟数 , 范围是从 0 到 59 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MONTH(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date 对应的月份，范围时从 1 到 12 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MONTHNAME(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回 date 对应月份的全名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOW()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前日期和时间值，其格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ， 具体格式取决于该函数是否用在字符串中或数字语境中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PERIOD_ADD(P ,N)&lt;/strong&gt;&lt;br&gt;
函数使用说明：添加 N 个月至周期 P ( 格式为 YYMM 或 YYYYMM) ，返回值的格式为 YYYYMM 。注意周期参数 P 不是 日期值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PERIOD_DIFF(P1 ,P2)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回周期 P1 和 P2 之间的月份数。 P1 和 P2 的格式应该为 YYMM 或 YYYYMM 。注意周期参数 P1 和 P2 不是 日期值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QUARTER(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date 对应的一年中的季度值，范围是从 1 到 4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SECOND(time)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 time 对应的秒数 , 范围是从 0 到 59 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SEC_TO_TIME(seconds)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回被转化为小时、 分钟和秒数的 seconds 参数值 , 其格式为 &#39;HH:MM:SS&#39; 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境中而定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STR_TO_DATE(str ,format)&lt;/strong&gt;&lt;br&gt;
函数使用说明：这是 DATE_FORMAT() 函数的倒转。它获取一个字符串 str 和一个格式字符串 format 。若格式字符串包含日期和时间部分，则 STR_TO_DATE() 返回一个 DATETIME 值， 若该字符串只包含日期部分或时间部分，则返回一个 DATE 或 TIME 值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SUBDATE(date ,INTERVAL expr type) SUBDATE(expr ,days)&lt;/strong&gt;&lt;br&gt;
函数使用说明：当被第二个参数的 INTERVAL 型式调用时 , SUBDATE() 和 DATE_SUB() 的意义相同。对于有关 INTERVAL 参数的信息， 见有关 DATE_ADD() 的讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SUBTIME(expr ,expr2)&lt;/strong&gt;&lt;br&gt;
函数使用说明： SUBTIME() 从 expr 中提取 expr2 ，然后返回结果。 expr 是一个时间或日期时间表达式，而 xpr2 是一个时间表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYSDATE()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前日期和时间值，格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ， 具体格式根据函数是否用在字符串或数字语境而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIME(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：提取一个时间或日期时间表达式的时间部分，并将其以字符串形式返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIMEDIFF(expr ,expr2)&lt;/strong&gt;&lt;br&gt;
函数使用说明： TIMEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的时间。 expr 和 expr2 为时间或 date-and-time 表达式 , 两个的类型必须一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIMESTAMP(expr) , TIMESTAMP(expr ,expr2)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 对于一个单参数 , 该函数将日期或日期时间表达式 expr 作为日期时间值返回 . 对于两个参数 , 它将时间表达式 expr2 添加到日期或日期时间表达式 expr 中，将 theresult 作为日期时间值返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIMESTAMPADD(interval ,int_expr ,datetime_expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：将整型表达式int_expr 添加到日期或日期时间表达式 datetime_expr 中。 int_expr 的单位被时间间隔参数给定，该参数必须是以下值的其中一个： FRAC_SECOND 、SECOND 、 MINUTE 、 HOUR 、 DAY 、 WEEK 、 MONTH 、 QUARTER 或 YEAR 。可使用所显示的关键词指定Interval 值，或使用SQL_TSI_ 前缀。例如, DAY 或SQL_TSI_DAY 都是正确的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIMESTAMPDIFF(interval ,datetime_expr1 ,datetime_expr2)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回日期或日期时间表达式 datetime_expr1 和 datetime_expr2 the 之间的整数差。其结果的单位由 interval 参数给出。 interval 的法定值同 TIMESTAMPADD() 函数说明中所列出的相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIME_FORMAT(time ,format)&lt;/strong&gt;&lt;br&gt;
函数使用说明：其使用和 DATE_FORMAT() 函数相同 , 然而 format 字符串可能仅会包含处理小时、分钟和秒的格式说明符。其它说明符产生一个 NULL 值或 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIME_TO_SEC(time)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回已转化为秒的 time 参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TO_DAYS(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：给定一个日期 date , 返回一个天数 ( 从年份 0 开始的天数 ) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：若无参数调用，则返回一个 Unix timestamp (&#39;1970-01-01 00:00:00&#39; GMT 之后的秒数 ) 作为无符号整数。若用 date 来调用 UNIX_TIMESTAMP() ，它会将参数值以 &#39;1970-01-01 00:00:00&#39; GMT 后的秒数的形式返回。 date 可以是一个 DATE 字符串、一个 DATETIME 字符串、一个 TIMESTAMP 或一个当地时间的 YYMMDD 或 YYYMMDD 格式的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTC_DATE, UTC_DATE()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前 UTC 日期值，其格式为 &#39;YYYY-MM-DD&#39; 或 YYYYMMDD ，具体格式取决于函数是否用在字符串或数字语境中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTC_TIME, UTC_TIME()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前 UTC 值，其格式为   &#39;HH:MM:SS&#39; 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTC_TIMESTAMP, UTC_TIMESTAMP()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回当前 UTC 日期及时间值，格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WEEK(date [,mode ])&lt;/strong&gt;&lt;br&gt;
函数使用说明：该函数返回 date 对应的星期数。 WEEK() 的双参数形式允许你指定该星期是否起始于周日或周一， 以及返回值的范围是否为从 0 到 53 或从 1 到 53 。若 mode 参数被省略，则使用 default_week_format 系统自变量的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WEEKDAY(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date (0 = 周一 , 1 = 周二 , ... 6 = 周日 ) 对应的工作日索引   weekday index for&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WEEKOFYEAR(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：将该日期的阳历周以数字形式返回，范围是从 1 到 53 。它是一个兼容度函数，相当于 WEEK(date ,3) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;YEAR(date)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 date 对应的年份 , 范围是从 1000 到 9999 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;YEARWEEK(date), YEARWEEK(date ,start)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个日期对应的年或周。 start 参数的工作同 start 参数对 WEEK() 的工作相同。结果中的年份可以和该年的第一周和最后一周对应的日期参数有所不同。&lt;/p&gt;
">mysql 日期函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-mathematical-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;ABS(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的绝对值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACOS(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASIN（X）&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回X 的反正弦，即，正弦为X 的值。若X   若X 不在-1 到 1 的范围之内，则返回 NULL 。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;ATAN(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的反正切，即，正切为 X 的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ATAN(Y ,X ) , ATAN2(Y ,X )&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回两个变量 X 及 Y 的反正切。 它类似于 Y 或 X 的反正切计算 , 除非两个参数的符号均用于确定结果所在象限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CEILING(X ) CEIL(X )&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回不小于 X 的最小整数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数COS(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的余弦，其中 X 在弧度上已知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COT(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的余切&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CRC32(expr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：计算循环冗余码校验值并返回一个 32 比特无符号值。若参数为 NULL ，则结果为 NULL 。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DEGREES(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回参数 X , 该参数由弧度被转化为度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXP(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 e 的 X 乘方后的值 ( 自然对数的底 ) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FLOOR(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回不大于 X 的最大整数值 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;
函数使用说明：将数字 X 的格式写成 &#39;#,###,###.##&#39; 格式 , 即保留小数点后 D 位，而第 D 位的保留方式为四舍五入，然后将结果以字符串的形式返回&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LN(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的自然对数 , 即 , X 相对于基数 e 的对数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOG(X) LOG(B ,X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：若用一个参数调用，这个函数就会返回 X 的自然对数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOG2(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的基数为 2 的对数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOG10(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的基数为 10 的对数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MOD(N ,M ) , N % M N MOD M&lt;/strong&gt;&lt;br&gt;
函数使用说明： 模操作。返回 N 被 M 除后的余数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PI()&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 ϖ (pi) 的值。默认的显示小数位数是 7 位 , 然而 MySQL 内部会使用完全双精度值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POW(X ,Y) , POWER(X ,Y)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 的 Y 乘方的结果值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RADIANS(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回由度转化为弧度的参数 X , ( 注意 ϖ 弧度等于 180 度）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RAND() RAND(N)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个随机浮点值 v ，范围在 0 到 1 之间 ( 即 , 其范围为 0 ≤ v ≤ 1.0) 。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ROUND(X) ROUND(X ,D)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回参数 X , 其值接近于最近似的整数。在有两个参数的情况下，返回 X ，其值保留到小数点后 D 位，而第 D 位的保留方式为四舍五入。若要接保留 X 值小数点左边的 D 位，可将 D 设为负值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIGN(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回参数作为 -1 、 0 或 1 的符号，该符号取决于 X 的值为负、零或正。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIN(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回 X 正弦，其中 X 在弧度中被给定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQRT(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回非负数 X 的二次方根。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TAN(X)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回 X 的正切，其中 X 在弧度中被给定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRUNCATE(X ,D)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回被舍去至小数点后 D 位的数字 X 。若 D 的值为 0, 则结果不带有小数点或不带有小数部分。可以将 D 设为负数 , 若要截去 ( 归零 ) X 小数点左起第 D 位开始后面所有低位的值&lt;/p&gt;
">mysql 数学函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-string-comparison-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;ascii(str)&lt;/strong&gt;&lt;br&gt;
函数用法说明：返回值为字符串 str 的最左字符的数值。&lt;br&gt;
假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIN(N)&lt;/strong&gt;&lt;br&gt;
函数用法说明：返回值为 N 的二进制值的字符串表示，其中N 为一个 longlong (BIGINT) 数字。这等同于 CONV(N ,10,2) 。假如 N 为 NULL ，则返回值为 NULL 。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;CHAR(N ,... [USING charset ])&lt;/strong&gt;&lt;br&gt;
函数用法说明： CHAR() 将每个参数 N 理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。 NULL 值被省略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CHAR_LENGTH(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回值为字符串 str 的长度，长度的单位为字符。&lt;br&gt;
一个多字节字符算作一个单字符。对于一个 包含五个二字节字符集 , LENGTH() 返回值为 10, 而 CHAR_LENGTH() 的返回值为 5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CHARACTER_LENGTH(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明： CHARACTER_LENGTH() 是 CHAR_LENGTH() 的同义词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COMPRESS(string_to_compress)&lt;/strong&gt;&lt;br&gt;
函数使用说明： COMPRESS( 压缩一个字符串。这个函数要求 MySQL 已经用一个诸如 zlib 的压缩库压缩过。否则，返回值始终是 NULL 。 UNCOMPRESS() 可将压缩过的字符串进行解压缩 ) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONCAT(str1 ,str2 ,...)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回结果为连接参数产生的字符串。&lt;br&gt;
如有任何一个参数为 NULL ，则返回值为 NULL 。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONCAT_WS(separator ,str1 ,str2 ,...)&lt;/strong&gt;&lt;br&gt;
函数使用说明： CONCAT_WS() 代表 CONCAT With Separator ，是 CONCAT() 的特殊形式。&lt;br&gt;
第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL ，则结果为 NULL 。函数会忽略任何分隔符参数后的 NULL 值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONV(N from_base, to_base)&lt;/strong&gt;&lt;br&gt;
函数使用说明：不同数基间转换数字。&lt;br&gt;
返回值为数字的 N 字符串表示，由 from_base 基转化为 to_base 基。如有任意一个参数为 NULL ，则返回值为 NULL 。自变量 N 被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为 2 ，而最大基数则为 36 。 If to_base 是一个负数，则 N 被看作一个带符号数。否则， N 被看作无符号数。 CONV() 的运行精确度为 64 比特。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ELT(N ,str1 ,str2 ,str3 ,...)&lt;/strong&gt;&lt;br&gt;
函数使用说明：若 N = 1 ，则返回值为   str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。&lt;br&gt;
若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是   FIELD() 的补数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXPORT_SET(bits ,on ,off [,separator [,number_of_bits ]])&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回值为一个字符串，其中对于 bits 值中的每个位组，可以得到一个 on 字符串，而对于每个清零比特位，可以得到一个 off 字符串。 bits 中的比特值按照从右到左的顺序接受检验 ( 由低位比特到高位比特 ) 。字符串被分隔字符串分开 ( 默认为逗号 ‘,’) ，按照从左到右的顺序被添加到结果中。 number_of_bits 会给出被检验的二进制位数 ( 默认为 64) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FIELD(str, str1, str2, str3, …...)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回值为 str1 , str2 , str3 ,…… 列表中的 str 指数。在找不到 str 的情况下，返回值为 0 。如果所有对于 FIELD() 的参数均为字符串，则所有参数均按照字符串进行比较。如果所有的参数均为数字，则按照数字进行比较。否则，参数按照双倍进行比较。如果 str 为 NULL ，则返回值为 0 ，原因是 NULL 不能同任何值进行同等比较。 FIELD() 是 ELT() 的补数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FIND_IN_SET(str, strlist)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 假如字符串 str 在由 N 子链组成的字符串列表 strlist 中， 则返回值的范围在 1 到 N 之间 。一个字符串列表就是一个由一些被 ‘,’ 符号分开的自链组成的字符串。如果第一个参数是一个常数字符串，而第二个是 type SET 列，则    FIND_IN_SET() 函数被优化，使用比特计算。如果 str 不在 strlist 或 strlist 为空字符串，则返回值为 0 。如任意一个参数为 NULL ，则返回值为 NULL 。 这个函数在第一个参数包含一个逗号 (‘,’) 时将无法正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 将 number X 设置为格式 &#39;#,###,###.##&#39;, 以四舍五入的方式保留到小数点后 D 位 , 而返回结果为一个字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HEX(N_or_S)&lt;/strong&gt;&lt;br&gt;
函数使用说明：如果N_OR_S 是一个数字，则返回一个 十六进制值 N 的 字符串表示&lt;br&gt;
如果N_OR_S 是一个longlong (BIGINT) 数。这相当于 CONV(N,10,16)&lt;br&gt;
如果N_OR_S 是一个字符串，则返回值为一个N_OR_S 的十六进制字符串表示，其中每个N_OR_S 里的每个字符被转化为两个十六进制数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INSTR(str,substr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str 中子字符串的第一个出现位置。这和LOCATE() 的双参数形式相同，除非参数的顺序被颠倒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LCASE(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：LCASE() 是 LOWER() 的同义词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LEFT(str,len)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回从字符串str 开始的len 最左字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LENGTH(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回值为字符串 str 的长度，单位为字节。一个多字节字符算作多字节。这意味着 对于一个包含 5 个 2 字节字符的字符串， LENGTH() 的返回值为 10, 而 CHAR_LENGTH() 的返回值则为5 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOAD_FILE(file_name)&lt;/strong&gt;&lt;br&gt;
函数使用说明：读取文件并将这一文件按照字符串的格式返回。 文件的位置必须在服务器上 , 你必须为文件制定路径全名，而且你还必须拥有 FILE 特许权。文件必须可读取，文件容量必须小于 max_allowed_packet 字节。若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为 NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCATE(substr ,str ) , LOCATE(substr ,str ,pos )&lt;/strong&gt;&lt;br&gt;
函数使用说明：第一个语法返回字符串 str 中子字符串substr 的第一个出现位置。第二个语法返回字符串 str 中子字符串substr 的第一个出现位置, 起始位置在pos 。如若substr 不在str 中，则返回值为0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOWER(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str 以及所有根据最新的字符集映射表变为小写字母的字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LPAD(str ,len ,padstr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str , 其左边由字符串padstr 填补到len 字符长度。假如str 的长度大于len , 则返回值被缩短至 len 字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LTRIM(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str ，其引导空格字符被删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAKE_SET(bits ,str1 ,str2 ,...)&lt;/strong&gt;&lt;br&gt;
数使用说明： 返回一个设定值 ( 一个包含被 ‘,’ 号分开的字字符串的字符串 ) ，由在 bits 组中具有相应的比特的字符串组成。 str1 对应比特 0, str2 对应比特 1, 以此类推。 str1 , str2 , ... 中的 NULL 值不会被添加到结果中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MID(str ,pos ,len)&lt;/strong&gt;&lt;br&gt;
函数使用说明： MID(str ,pos ,len ) 是 SUBSTRING(str ,pos ,len ) 的同义词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OCT(N)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个 N 的八进制值的字符串表示，其中 N 是一个 longlong (BIGINT) 数。这等同于 CONV(N,10,8) 。若 N 为 NULL ，则返回值为 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OCTET_LENGTH(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明： OCTET_LENGTH() 是 LENGTH() 的同义词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数ORD(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：若字符串str 的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出:&lt;br&gt;
(1st byte code) + (2nd byte code × 256) + (3rd byte code × 2562) ...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POSITION(substr IN str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：POSITION(substr IN str ) 是 LOCATE(substr ,str ) 同义词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QUOTE(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：引证一个字符串，由此产生一个在SQL 语句中可用作完全转义数据值的结果。 返回的字符串由单引号标注，每例都带有单引号 (‘&#39;’) 、 反斜线符号 (‘\’) 、 ASCII NUL 以及前面有反斜线符号的Control-Z 。如果自变量的值为NULL, 则返回不带单引号的单词 “NULL” 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REPEAT(str ,count)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个由重复的字符串str 组成的字符串，字符串str 的数目等于count 。 若 count &amp;lt;= 0, 则返回一个空字符串。若str 或 count 为 NULL ，则返回 NULL 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REPLACE(str ,from_str ,to_str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串str 以及所有被字符串to_str 替代的字符串from_str 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REVERSE(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str ，顺序和字符顺序相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RIGHT(str ,len)&lt;/strong&gt;&lt;br&gt;
函数使用说明：从字符串str 开始，返回最右len 字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RPAD(str ,len ,padstr)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串str , 其右边被字符串 padstr 填补至len 字符长度。假如字符串str 的长度大于 len , 则返回值被缩短到与 len 字符相同长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTRIM(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str ，结尾空格字符被删去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SOUNDEX(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：从str 返回一个soundex 字符串。 两个具有几乎同样探测的字符串应该具有同样的 soundex 字符串。一个标准的soundex 字符串的长度为4 个字符，然而SOUNDEX() 函数会返回一个人以长度的字符串。 可使用结果中的SUBSTRING() 来得到一个标准 soundex 字符串。在str 中， 会忽略所有未按照字母顺序排列的字符。所有不在A-Z 范围之内的国际字母符号被视为元音字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;expr1 SOUNDS LIKE expr2&lt;/strong&gt;&lt;br&gt;
函数使用说明： 这相当于SOUNDEX(expr1 ) = SOUNDEX(expr2 ) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPACE(N)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回一个由N 间隔符号组成的字符串&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SUBSTRING(str ,pos) , SUBSTRING(str FROM pos) SUBSTRING(str ,pos ,len) , SUBSTRING(str FROM pos FOR len)&lt;/strong&gt;&lt;br&gt;
函数使用说明：不带有len 参数的格式从字符串str 返回一个子字符串，起始于位置 pos 。带有len 参数的格式从字符串str 返回一个长度同len 字符相同的子字符串，起始于位置 pos 。 使用 FROM 的格式为标准 SQL 语法。也可能对pos 使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SUBSTRING_INDEX(str ,delim ,count)&lt;/strong&gt;&lt;br&gt;
函数使用说明：在定界符 delim 以及count 出现前，从字符串str 返回自字符串。若count 为正值, 则返回最终定界符( 从左边开始) 左边的一切内容。若count 为负值，则返回定界符（从右边开始）右边的一切内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRIM([{BOTH | LEADING | TRAILING} [remstr ] FROM] str) TRIM(remstr FROM] str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str ， 其中所有remstr 前缀和/ 或后缀都已被删除。若分类符BOTH 、LEADIN 或TRAILING 中没有一个是给定的, 则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UCASE(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：UCASE() 是UPPER() 的同义词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNCOMPRESS(string_to_uncompress)&lt;/strong&gt;&lt;br&gt;
函数使用说明：对经COMPRESS() 函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为 NULL 。这个函数要求 MySQL 已被诸如zlib 之类的压缩库编译过。否则, 返回值将始终是 NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNCOMPRESSED_LENGTH(compressed_string)&lt;/strong&gt;&lt;br&gt;
函数使用说明： 返回压缩字符串压缩前的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNHEX(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：执行从 HEX(str ) 的反向操作。就是说，它将参数中的每一对十六进制数字理解为一个数字，并将其转化为该数字代表的字符。结果字符以二进制字符串的形式返回&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPPER(str)&lt;/strong&gt;&lt;br&gt;
函数使用说明：返回字符串 str ， 以及根据最新字符集映射转化为大写字母的字符&lt;/p&gt;
">mysql 字符串比较函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-control-flow-function/"" data-c="
          &lt;p&gt;**CASE WHEN THEN **&lt;br&gt;
语法： CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ] END CASE WHEN [condition] THEN result [WHEN[condition] THEN result ……] [ELSE result] END ;&lt;br&gt;
函数用法说明：在第一个方案的返回结果中， value =compare-value 。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为 ELSE 后的结果，如果没有 ELSE 部分，则返回值为 NULL&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;**IF **&lt;br&gt;
语法： IF(expr1,expr2,expr3)&lt;br&gt;
函数用法说明：如果 expr1 是 TRUE (expr1 &amp;lt;&amp;gt; 0 and expr1 &amp;lt;&amp;gt; NULL) ，则 IF() 的返回值为 expr2 ; 否则返回值则为 expr3 。 IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定&lt;/p&gt;
&lt;p&gt;**IFNULL **&lt;br&gt;
语法： IFNULL(expr1,expr2)&lt;br&gt;
函数用法说明：假如 expr1 不为 NULL ，则 IFNULL() 的返回值为 expr1 ; 否则其返回值为 expr2 。 IFNULL() 的返回值是数字或是字符串，具体情况取决于其所使用的语境&lt;/p&gt;
">mysql 控制流程函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-time-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;DAYOFWEEK(date)&lt;/strong&gt;&lt;br&gt;
返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select DAYOFWEEK(&#39;2017-01-06&#39;);
+-------------------------+
| DAYOFWEEK(&#39;2017-01-06&#39;) |
+-------------------------+
|                       6 |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;WEEKDAY(date)&lt;/strong&gt;&lt;br&gt;
返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select WEEKDAY(&#39;2017-01-06&#39;);
+-----------------------+
| WEEKDAY(&#39;2017-01-06&#39;) |
+-----------------------+
|                     4 |
+-----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DAYOFMONTH(date)&lt;/strong&gt;&lt;br&gt;
返回date的月份中日期，在1到31范围内。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select DAYOFMONTH(&#39;2017-01-06&#39;);
+--------------------------+
| DAYOFMONTH(&#39;2017-01-06&#39;) |
+--------------------------+
|                        6 |
+--------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DAYOFYEAR(date)&lt;/strong&gt;&lt;br&gt;
返回date在一年中的日数, 在1到366范围内。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select DAYOFYEAR(&#39;2016-12-31&#39;);
+-------------------------+
| DAYOFYEAR(&#39;2016-12-31&#39;) |
+-------------------------+
|                     366 |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MONTH(date)&lt;/strong&gt;&lt;br&gt;
返回date的月份，范围1到12。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select MONTH(&#39;2017-01-06&#39;);
+---------------------+
| MONTH(&#39;2017-01-06&#39;) |
+---------------------+
|                   1 |
+---------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DAYNAME(date)&lt;/strong&gt;&lt;br&gt;
返回date的星期名字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select DAYNAME(&amp;quot;2017-01-06&amp;quot;);
+-----------------------+
| DAYNAME(&amp;quot;2017-01-06&amp;quot;) |
+-----------------------+
| Friday                |
+-----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MONTHNAME(date)&lt;/strong&gt;&lt;br&gt;
返回date的月份名字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select MONTHNAME(&amp;quot;2017-01-06&amp;quot;);
+-------------------------+
| MONTHNAME(&amp;quot;2017-01-06&amp;quot;) |
+-------------------------+
| January                 |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;QUARTER(date)&lt;/strong&gt;&lt;br&gt;
返回date一年中的季度，范围1到4。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select QUARTER(&#39;2016-12-31&#39;);
+-----------------------+
| QUARTER(&#39;2016-12-31&#39;) |
+-----------------------+
|                     4 |
+-----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;WEEK(date)、WEEK(date,first)&lt;/strong&gt;&lt;br&gt;
对于星期天是一周的第一天的地方，有一个单个参数，返回date的周数，范围在0到52。2个参数形式WEEK()允许你指定星期是否开始于星期天或星期一。如果第二个参数是0，星期从星期天开始，如果第二个参数是1，从星期一开始。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select WEEK(&#39;2017-01-08&#39;);  
+--------------------+
| WEEK(&#39;2017-01-08&#39;) |
+--------------------+
|                  2 |
+--------------------+
mysql&amp;gt; select WEEK(&#39;2017-01-08&#39;,0);
+----------------------+
| WEEK(&#39;2017-01-08&#39;,0) |
+----------------------+
|                    2 |
+----------------------+
mysql&amp;gt; select WEEK(&#39;2017-01-08&#39;,1);
+----------------------+
| WEEK(&#39;2017-01-08&#39;,1) |
+----------------------+
|                    1 |
+----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;YEAR(date)&lt;/strong&gt;&lt;br&gt;
返回date的年份，范围在1000到9999。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select YEAR(&#39;2017-01-06&#39;);
+--------------------+
| YEAR(&#39;2017-01-06&#39;) |
+--------------------+
|               2017 |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;HOUR(time)&lt;/strong&gt;&lt;br&gt;
返回time的小时，范围是0到23。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select HOUR(&#39;12:05:03&#39;);
+------------------+
| HOUR(&#39;12:05:03&#39;) |
+------------------+
|               12 |
+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MINUTE(time)&lt;/strong&gt;&lt;br&gt;
返回time的分钟，范围是0到59。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select MINUTE(&#39;2017-01-06 12:05:03&#39;);
+-------------------------------+
| MINUTE(&#39;2017-01-06 12:05:03&#39;) |
+-------------------------------+
|                             5 |
+-------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SECOND(time)&lt;/strong&gt;&lt;br&gt;
回来time的秒数，范围是0到59。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SECOND(&#39;12:05:03&#39;);
+--------------------+
| SECOND(&#39;12:05:03&#39;) |
+--------------------+
|                  3 |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PERIOD_ADD(P,N)&lt;/strong&gt;&lt;br&gt;
增加N个月到阶段P（以格式YYMM或YYYYMM)。以格式YYYYMM返回值。注意阶段参数P不是日期值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select PERIOD_ADD(201701,2); 
+----------------------+
| PERIOD_ADD(201701,2) |
+----------------------+
|               201703 |
+----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PERIOD_DIFF(P1,P2)&lt;/strong&gt;&lt;br&gt;
返回在时期P1和P2之间月数，P1和P2应该以格式YYMM或YYYYMM。注意，时期参数P1和P2不是日期值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select PERIOD_DIFF(1602,201701);
+--------------------------+
| PERIOD_DIFF(1602,201701) |
+--------------------------+
|                      -11 |
+--------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DATE_ADD(date,INTERVAL expr type)、DATE_SUB(date,INTERVAL expr type)、ADDDATE(date,INTERVAL expr type)、SUBDATE(date,INTERVAL expr type)&lt;/strong&gt;&lt;br&gt;
这些功能执行日期运算。对于MySQL 3.22，他们是新的。ADDDATE()和SUBDATE()是DATE_ADD()和DATE_SUB()的同义词。在MySQL 3.23中，你可以使用+和-而不是DATE_ADD()和DATE_SUB()。（见例子）date是一个指定开始日期的DATETIME或DATE值，expr是指定加到开始日期或从开始日期减去的间隔值一个表达式，expr是一个字符串；它可以以一个“-”开始表示负间隔。type是一个关键词，指明表达式应该如何被解释。EXTRACT(type FROM date)函数从日期中返回“type”间隔。下表显示了type和expr参数怎样被关联： type值 含义 期望的expr格式&lt;br&gt;
SECOND 秒 SECONDS&lt;br&gt;
MINUTE 分钟 MINUTES&lt;br&gt;
HOUR 时间 HOURS&lt;br&gt;
DAY 天 DAYS&lt;br&gt;
MONTH 月 MONTHS&lt;br&gt;
YEAR 年 YEARS&lt;br&gt;
MINUTE_SECOND 分钟和秒 &amp;quot;MINUTES:SECONDS&amp;quot;&lt;br&gt;
HOUR_MINUTE 小时和分钟 &amp;quot;HOURS:MINUTES&amp;quot;&lt;br&gt;
DAY_HOUR 天和小时 &amp;quot;DAYS HOURS&amp;quot;&lt;br&gt;
YEAR_MONTH 年和月 &amp;quot;YEARS-MONTHS&amp;quot;&lt;br&gt;
HOUR_SECOND 小时, 分钟， &amp;quot;HOURS:MINUTES:SECONDS&amp;quot;&lt;br&gt;
DAY_MINUTE 天, 小时, 分钟 &amp;quot;DAYS HOURS:MINUTES&amp;quot;&lt;br&gt;
DAY_SECOND 天, 小时, 分钟, 秒 &amp;quot;DAYS HOURS:MINUTES:SECONDS&amp;quot;&lt;br&gt;
MySQL在expr格式中允许任何标点分隔符。表示显示的是建议的分隔符。如果date参数是一个DATE值并且你的计算仅仅包含YEAR、MONTH和DAY部分(即，没有时间部分)，结果是一个DATE值。否则结果是一个DATETIME值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; SELECT &amp;quot;2017-01-06 12:05:03&amp;quot; + INTERVAL 1 SECOND;                 
+-------------------------------------------+
| &amp;quot;2017-01-06 12:05:03&amp;quot; + INTERVAL 1 SECOND |
+-------------------------------------------+
| 2017-01-06 12:05:04                       |
+-------------------------------------------+
mysql&amp;gt; SELECT INTERVAL 1 DAY + &amp;quot;2017-01-06&amp;quot;;
+-------------------------------+
| INTERVAL 1 DAY + &amp;quot;2017-01-06&amp;quot; |
+-------------------------------+
| 2017-01-07                    |
+-------------------------------+
mysql&amp;gt; SELECT &amp;quot;2017-01-06&amp;quot; - INTERVAL 1 SECOND;          
+----------------------------------+
| &amp;quot;2017-01-06&amp;quot; - INTERVAL 1 SECOND |
+----------------------------------+
| 2017-01-05 23:59:59              |
+----------------------------------+
mysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 SECOND);                   
+----------------------------------------------------+
| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 SECOND) |
+----------------------------------------------------+
| 2017-01-06 12:05:04                                |
+----------------------------------------------------+
mysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 DAY);                   
+-------------------------------------------------+
| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 DAY) |
+-------------------------------------------------+
| 2017-01-07 12:05:03                             |
+-------------------------------------------------+
mysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1:1&amp;quot; MINUTE_SECOND);                   
+---------------------------------------------------------------+
| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1:1&amp;quot; MINUTE_SECOND) |
+---------------------------------------------------------------+
| 2017-01-06 12:06:04                                           |
+---------------------------------------------------------------+
mysql&amp;gt; SELECT DATE_SUB(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1 1:1:1&amp;quot; DAY_SECOND);                   
+----------------------------------------------------------------+
| DATE_SUB(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1 1:1:1&amp;quot; DAY_SECOND) |
+----------------------------------------------------------------+
| 2017-01-05 11:04:02                                            |
+----------------------------------------------------------------+
mysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;-1 10&amp;quot; DAY_HOUR);                   
+------------------------------------------------------------+
| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;-1 10&amp;quot; DAY_HOUR) |
+------------------------------------------------------------+
| 2017-01-05 02:05:03                                        |
+------------------------------------------------------------+
mysql&amp;gt; SELECT DATE_SUB(&amp;quot;2017-01-06&amp;quot;, INTERVAL 31 DAY);          
+-----------------------------------------+
| DATE_SUB(&amp;quot;2017-01-06&amp;quot;, INTERVAL 31 DAY) |
+-----------------------------------------+
| 2016-12-06                              |
+-----------------------------------------+
mysql&amp;gt; SELECT EXTRACT(YEAR FROM &amp;quot;2017-01-06&amp;quot;);
+---------------------------------+
| EXTRACT(YEAR FROM &amp;quot;2017-01-06&amp;quot;) |
+---------------------------------+
|                            2017 |
+---------------------------------+
mysql&amp;gt; SELECT EXTRACT(YEAR_MONTH FROM &amp;quot;2017-01-06 12:05:03&amp;quot;);
+------------------------------------------------+
| EXTRACT(YEAR_MONTH FROM &amp;quot;2017-01-06 12:05:03&amp;quot;) |
+------------------------------------------------+
|                                         201701 |
+------------------------------------------------+
mysql&amp;gt; SELECT EXTRACT(DAY_MINUTE FROM &amp;quot;2017-01-06 12:05:03&amp;quot;);
+------------------------------------------------+
| EXTRACT(DAY_MINUTE FROM &amp;quot;2017-01-06 12:05:03&amp;quot;) |
+------------------------------------------------+
|                                          61205 |
+------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你指定太短的间隔值(不包括type关键词期望的间隔部分)，MySQL假设你省掉了间隔值的最左面部分。例如，如果你指定一个type是DAY_SECOND，值expr被希望有天、小时、分钟和秒部分。如果你象&amp;quot;1:10&amp;quot;这样指定值，MySQL假设日子和小时部分是丢失的并且值代表分钟和秒。换句话说，&amp;quot;1:10&amp;quot; DAY_SECOND以它等价于&amp;quot;1:10&amp;quot; MINUTE_SECOND的方式解释，这对那MySQL解释TIME值表示经过的时间而非作为一天的时间的方式有二义性。如果你使用确实不正确的日期，结果是NULL。如果你增加MONTH、YEAR_MONTH或YEAR并且结果日期大于新月份的最大值天数，日子在新月用最大的天调整。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select DATE_ADD(&#39;2017-01-06&#39;, Interval 1 month);          
+------------------------------------------+
| DATE_ADD(&#39;2017-01-06&#39;, Interval 1 month) |
+------------------------------------------+
| 2017-02-06                               |
+------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，从前面的例子中词INTERVAL和type关键词不是区分大小写的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TO_DAYS(date)&lt;/strong&gt;&lt;br&gt;
给出一个日期date，返回一个天数(从0年的天数)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select TO_DAYS(170106);
+-----------------+
| TO_DAYS(170106) |
+-----------------+
|          736700 |
+-----------------+
mysql&amp;gt; select TO_DAYS(&#39;2017-01-06&#39;);
+-----------------------+
| TO_DAYS(&#39;2017-01-06&#39;) |
+-----------------------+
|                736700 |
+-----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FROM_DAYS(N)&lt;/strong&gt;&lt;br&gt;
给出一个天数N，返回一个DATE值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select FROM_DAYS(736700);
+-------------------+
| FROM_DAYS(736700) |
+-------------------+
| 2017-01-06        |
+-------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DATE_FORMAT(date,format)&lt;/strong&gt;&lt;br&gt;
根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December)&lt;br&gt;
%W 星期名字(Sunday……Saturday)&lt;br&gt;
%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）&lt;br&gt;
%Y 年, 数字, 4 位&lt;br&gt;
%y 年, 数字, 2 位&lt;br&gt;
%a 缩写的星期名字(Sun……Sat)&lt;br&gt;
%d 月份中的天数, 数字(00……31)&lt;br&gt;
%e 月份中的天数, 数字(0……31)&lt;br&gt;
%m 月, 数字(01……12)&lt;br&gt;
%c 月, 数字(1……12)&lt;br&gt;
%b 缩写的月份名字(Jan……Dec)&lt;br&gt;
%j 一年中的天数(001……366)&lt;br&gt;
%H 小时(00……23)&lt;br&gt;
%k 小时(0……23)&lt;br&gt;
%h 小时(01……12)&lt;br&gt;
%I 小时(01……12)&lt;br&gt;
%l 小时(1……12)&lt;br&gt;
%i 分钟, 数字(00……59)&lt;br&gt;
%r 时间,12 小时(hh:mm:ss [AP]M)&lt;br&gt;
%T 时间,24 小时(hh:mm:ss)&lt;br&gt;
%S 秒(00……59)&lt;br&gt;
%s 秒(00……59)&lt;br&gt;
%p AM或PM&lt;br&gt;
%w 一个星期中的天数(0=Sunday ……6=Saturday ）&lt;br&gt;
%U 星期(0……52), 这里星期天是星期的第一天&lt;br&gt;
%u 星期(0……52), 这里星期一是星期的第一天&lt;br&gt;
%% 一个文字“%”。&lt;/p&gt;
&lt;p&gt;所有的其他字符不做解释被复制到结果中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%W %M %Y&#39;);                   
+------------------------------------------------+
| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%W %M %Y&#39;) |
+------------------------------------------------+
| Friday January 2017                            |
+------------------------------------------------+
mysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H:%i:%s&#39;);                   
+------------------------------------------------+
| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H:%i:%s&#39;) |
+------------------------------------------------+
| 12:05:03                                       |
+------------------------------------------------+
mysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%D %y %a %d %m %b %j&#39;);                   
+------------------------------------------------------------+
| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%D %y %a %d %m %b %j&#39;) |
+------------------------------------------------------------+
| 6th 17 Fri 06 01 Jan 006                                   |
+------------------------------------------------------------+
mysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H %k %I %r %T %S %w&#39;);                   
+------------------------------------------------------------+
| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H %k %I %r %T %S %w&#39;) |
+------------------------------------------------------------+
| 12 12 12 12:05:03 PM 12:05:03 03 5                         |
+------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TIME_FORMAT(time,format)&lt;/strong&gt;&lt;br&gt;
这象上面的DATE_FORMAT()函数一样使用，但是format字符串只能包含处理小时、分钟和秒的那些格式修饰符。其他修饰符产生一个NULL值或0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CURDATE()、CURRENT_DATE&lt;/strong&gt;&lt;br&gt;
以&#39;YYYY-MM-DD&#39;或YYYYMMDD格式返回今天日期值，取决于函数是在一个字符串还是数字上下文被使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select CURDATE();
+------------+
| CURDATE()  |
+------------+
| 2017-01-06 |
+------------+
mysql&amp;gt; select CURDATE()+2; 
+-------------+
| CURDATE()+2 |
+-------------+
|    20170108 |
+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CURRENT_TIME&lt;/strong&gt;&lt;br&gt;
以&#39;HH:MM:SS&#39;或HHMMSS格式返回当前时间值，取决于函数是在一个字符串还是在数字的上下文被使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select CURTIME();
+-----------+
| CURTIME() |
+-----------+
| 13:55:04  |
+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOW()、SYSDATE()、CURRENT_TIMESTAMP&lt;/strong&gt;&lt;br&gt;
以&#39;YYYY-MM-DD HH:MM:SS&#39;或YYYYMMDDHHMMSS格式返回当前的日期和时间，取决于函数是在一个字符串还是在数字的上下文被使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select NOW();
+---------------------+
| NOW()               |
+---------------------+
| 2017-01-06 13:57:02 |
+---------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;UNIX_TIMESTAMP()、UNIX_TIMESTAMP(date)&lt;/strong&gt;&lt;br&gt;
如果没有参数调用，返回一个Unix时间戳记(从&#39;1970-01-01 00:00:00&#39;GMT开始的秒数)。如果UNIX_TIMESTAMP()用一个date参数被调用，它返回从&#39;1970-01-01 00:00:00&#39; GMT开始的秒数值。date可以是一个DATE字符串、一个DATETIME字符串、一个TIMESTAMP或以YYMMDD或YYYYMMDD格式的本地时间的一个数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select UNIX_TIMESTAMP();
+------------------+
| UNIX_TIMESTAMP() |
+------------------+
|       1483682742 |
+------------------+
mysql&amp;gt; select UNIX_TIMESTAMP(&#39;2017-01-06 12:05:03&#39;);
+---------------------------------------+
| UNIX_TIMESTAMP(&#39;2017-01-06 12:05:03&#39;) |
+---------------------------------------+
|                            1483675503 |
+---------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当UNIX_TIMESTAMP被用于一个TIMESTAMP列，函数将直接接受值，没有隐含的“string-to-unix-timestamp”变换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FROM_UNIXTIME(unix_timestamp)&lt;/strong&gt;&lt;br&gt;
以&#39;YYYY-MM-DD HH:MM:SS&#39;或YYYYMMDDHHMMSS格式返回unix_timestamp参数所表示的值，取决于函数是在一个字符串还是或数字上下文中被使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select FROM_UNIXTIME(1483682742);
+---------------------------+
| FROM_UNIXTIME(1483682742) |
+---------------------------+
| 2017-01-06 14:05:42       |
+---------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FROM_UNIXTIME(unix_timestamp,format)&lt;/strong&gt;&lt;br&gt;
返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(), &#39;%Y %D %M %h:%i:%s %x&#39;);
+---------------------------------------------------------+
| FROM_UNIXTIME(UNIX_TIMESTAMP(), &#39;%Y %D %M %h:%i:%s %x&#39;) |
+---------------------------------------------------------+
| 2017 6th January 02:23:08 2017                          |
+---------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SEC_TO_TIME(seconds)&lt;/strong&gt;&lt;br&gt;
返回seconds参数，变换成小时、分钟和秒，值以&#39;HH:MM:SS&#39;或HHMMSS格式化，取决于函数是在一个字符串还是在数字上下文中被使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SEC_TO_TIME(2378);
+-------------------+
| SEC_TO_TIME(2378) |
+-------------------+
| 00:39:38          |
+-------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TIME_TO_SEC(time)&lt;/strong&gt;&lt;br&gt;
返回time参数，转换成秒。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select TIME_TO_SEC(&#39;14:05:42&#39;);         
+-------------------------+
| TIME_TO_SEC(&#39;14:05:42&#39;) |
+-------------------------+
|                   50742 |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
">mysql 时间函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/mysql-function/"" data-c="
          &lt;p&gt;&lt;strong&gt;ASCII(str)&lt;/strong&gt;&lt;br&gt;
返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 &lt;!--more--&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select ASCII(&#39;4&#39;);
+------------+
| ASCII(&#39;4&#39;) |
+------------+
|         52 |
+------------+
mysql&amp;gt; select ASCII(4);
+----------+
| ASCII(4) |
+----------+
|       52 |
+----------+
mysql&amp;gt; select ASCII(&#39;dx&#39;);
+-------------+
| ASCII(&#39;ex&#39;) |
+-------------+
|         101 |
+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可参见ORD()函数。&lt;br&gt;
**ORD(str) **&lt;br&gt;
如果字符串str最左面字符是一个多字节字符，通过以格式((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]返回字符的ASCII代码值来返回多字节字符代码。如果最左面的字符不是一个多字节字符。返回与ASCII()函数返回的相同值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select ORD(&#39;3&#39;);
+----------+
| ORD(&#39;3&#39;) |
+----------+
|       51 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CONV(N,from_base,to_base)&lt;/strong&gt;&lt;br&gt;
在不同的数字基之间变换数字。返回数字N的字符串数字，从from_base基变换为to_base基，如果任何参数是NULL，返回NULL。参数N解释为一个整数，但是可以指定为一个整数或一个字符串。最小基是2且最大的基是36。如果to_base是一个负数，N被认为是一个有符号数，否则，N被当作无符号数。 CONV以64位点精度工作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select CONV(&amp;quot;A&amp;quot;,16,2);
+----------------+
| CONV(&amp;quot;A&amp;quot;,16,2) |
+----------------+
| 1010           |
+----------------+
mysql&amp;gt; select CONV(&amp;quot;6EB&amp;quot;,18,8);
+------------------+
| CONV(&amp;quot;6EB&amp;quot;,18,8) |
+------------------+
| 4237             |
+------------------+
mysql&amp;gt; select CONV(-178,10,-18);
+-------------------+
| CONV(-178,10,-18) |
+-------------------+
| -9G               |
+-------------------+
mysql&amp;gt; select CONV(10+&amp;quot;10&amp;quot;+&#39;10&#39;+0xB,10,10);
+------------------------------+
| CONV(10+&amp;quot;10&amp;quot;+&#39;10&#39;+0xB,10,10) |
+------------------------------+
| 41                           |
+------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**BIN(N) **&lt;br&gt;
返回二进制值N的一个字符串表示，在此N是一个长整数(BIGINT)数字，这等价于CONV(N,10,2)。如果N是NULL，返回NULL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select BIN(532);
+------------+
| BIN(532)   |
+------------+
| 1000010100 |
+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;OCT(N)&lt;/strong&gt;&lt;br&gt;
返回八进制值N的一个字符串的表示，在此N是一个长整型数字，这等价于CONV(N,10,8)。如果N是NULL，返回NULL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select OCT(98);
+---------+
| OCT(98) |
+---------+
| 142     |
+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;HEX(N)&lt;/strong&gt;&lt;br&gt;
返回十六进制值N一个字符串的表示，在此N是一个长整型(BIGINT)数字，这等价于CONV(N,10,16)。如果N是NULL，返回NULL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select HEX(432);
+----------+
| HEX(432) |
+----------+
| 1B0      |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CHAR(N,...)&lt;/strong&gt;&lt;br&gt;
CHAR()将参数解释为整数并且返回由这些整数的ASCII代码字符组成的一个字符串。NULL值被跳过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select CHAR(77, 121, 83, 81,&#39;76&#39;);
+----------------------------+
| CHAR(77, 121, 83, 81,&#39;76&#39;) |
+----------------------------+
| MySQL                      |
+----------------------------+
mysql&amp;gt; select CHAR(77,77.3,&#39;77.3&#39;);
+----------------------+
| CHAR(77,77.3,&#39;77.3&#39;) |
+----------------------+
| MMM                  |
+----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CONCAT(str1,str2,...)&lt;/strong&gt;&lt;br&gt;
返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select CONCAT(&#39;My&#39;, &#39;S&#39;, &#39;QL&#39;);
+-------------------------+
| CONCAT(&#39;My&#39;, &#39;S&#39;, &#39;QL&#39;) |
+-------------------------+
| MySQL                   |
+-------------------------+
mysql&amp;gt; select CONCAT(&#39;My&#39;, NULL, &#39;QL&#39;);
+--------------------------+
| CONCAT(&#39;My&#39;, NULL, &#39;QL&#39;) |
+--------------------------+
| NULL                     |
+--------------------------+
mysql&amp;gt; select CONCAT(14.3);
+--------------+
| CONCAT(14.3) |
+--------------+
| 14.3         |
+--------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LENGTH(str)、OCTET_LENGTH(str)、CHAR_LENGTH(str)、CHARACTER_LENGTH(str)&lt;/strong&gt;&lt;br&gt;
返回字符串str的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select LENGTH(&#39;hello world&#39;);
+-----------------------+
| LENGTH(&#39;hello world&#39;) |
+-----------------------+
|                    11 |
+-----------------------+
mysql&amp;gt; select OCTET_LENGTH(&#39;hello world&#39;);
+-----------------------------+
| OCTET_LENGTH(&#39;hello world&#39;) |
+-----------------------------+
|                          11 |
+-----------------------------+
注意，对于多字节字符，其CHAR_LENGTH()仅计算一次。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LOCATE(substr,str,pos)、POSITION(substr IN str)&lt;/strong&gt;&lt;br&gt;
返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0&lt;br&gt;
如果设置了pos值，那么起始位置将从pos处，否则从1开始。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;);
+----------------------------+
| LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;) |
+----------------------------+
|                          4 |
+----------------------------+
mysql&amp;gt; select LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;, 5);
+-------------------------------+
| LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;, 5) |
+-------------------------------+
|                             7 |
+-------------------------------+
这函数是多字节可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;INSTR(str,substr)&lt;/strong&gt;&lt;br&gt;
返回子串substr在字符串str中的第一个出现的位置。这与有2个参数形式的LOCATE()相同，除了参数被颠倒。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select INSTR(&#39;foobarbar&#39;, &#39;bar&#39;);
+---------------------------+
| INSTR(&#39;foobarbar&#39;, &#39;bar&#39;) |
+---------------------------+
|                         4 |
+---------------------------+
这函数是多字节可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LPAD(str,len,padstr)&lt;/strong&gt;&lt;br&gt;
返回字符串str，左面用字符串padstr填补直到str是len个字符长。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select LPAD(&#39;A&#39;,5,&#39;BCD&#39;);
+-------------------+
| LPAD(&#39;A&#39;,5,&#39;BCD&#39;) |
+-------------------+
| BCDBA             |
+-------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RPAD(str,len,padstr)&lt;/strong&gt;&lt;br&gt;
返回字符串str，右面用字符串padstr填补直到str是len个字符长。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select RPAD(&#39;A&#39;,5,&#39;BCD&#39;);
+-------------------+
| RPAD(&#39;A&#39;,5,&#39;BCD&#39;) |
+-------------------+
| ABCDB             |
+-------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LEFT(str,len)&lt;/strong&gt;&lt;br&gt;
返回字符串str的最左面len个字符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select LEFT(&#39;hello world&#39;, 7);
+------------------------+
| LEFT(&#39;hello world&#39;, 7) |
+------------------------+
| hello w                |
+------------------------+
该函数是多字节可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RIGHT(str,len)&lt;/strong&gt;&lt;br&gt;
返回字符串str的最右面len个字符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select RIGHT(&#39;hello world&#39;, 7);       
+-------------------------+
| RIGHT(&#39;hello world&#39;, 7) |
+-------------------------+
| o world                 |
+-------------------------+
该函数是多字节可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)、MID(str,pos,len)&lt;/strong&gt;&lt;br&gt;
从字符串str返回一个len个字符的子串，从位置pos开始。使用FROM的变种形式是ANSI SQL92语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SUBSTRING(&#39;abcdefghijk&#39;,5,6);  
+------------------------------+
| SUBSTRING(&#39;abcdefghijk&#39;,5,6) |
+------------------------------+
| efghij                       |
+------------------------------+
该函数是多字节可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SUBSTRING(str,pos)、SUBSTRING(str FROM pos)&lt;/strong&gt;&lt;br&gt;
从字符串str的起始位置pos返回一个子串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SUBSTRING(&#39;abcdefghijk&#39;,5);  
+----------------------------+
| SUBSTRING(&#39;abcdefghijk&#39;,5) |
+----------------------------+
| efghijk                    |
+----------------------------+
该函数是多字节可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SUBSTRING_INDEX(str,delim,count)&lt;/strong&gt;&lt;br&gt;
返回从字符串str的第count个出现的分隔符delim之后的子串。如果count是正数，返回最后的分隔符到左边(从左边数) 的所有字符。如果count是负数，返回最后的分隔符到右边的所有字符(从右边数)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SUBSTRING_INDEX(&#39;http://blog.imarkofu.com&#39;, &#39;.&#39;, 2);         
+-----------------------------------------------------+
| SUBSTRING_INDEX(&#39;http://blog.imarkofu.com&#39;, &#39;.&#39;, 2) |
+-----------------------------------------------------+
| http://blog.imarkofu                                |
+-----------------------------------------------------+
该函数对多字节是可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LTRIM(str)&lt;/strong&gt;&lt;br&gt;
返回删除了其前置空格字符的字符串str。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select LTRIM(&#39;   hello world   &#39;); 
+----------------------------+
| LTRIM(&#39;   hello world   &#39;) |
+----------------------------+
| hello world                |
+----------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RTRIM(str)&lt;/strong&gt;&lt;br&gt;
返回删除了其拖后空格字符的字符串str。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select RTRIM(&#39;   hello world   &#39;);  
+----------------------------+
| RTRIM(&#39;   hello world   &#39;) |
+----------------------------+
|    hello world             |
+----------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)&lt;/strong&gt;&lt;br&gt;
返回字符串str，其所有remstr前缀或后缀被删除了。如果没有修饰符BOTH、LEADING或TRAILING给出，BOTH被假定。如果remstr没被指定，空格被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select TRIM(&#39;   hello world   &#39;); 
+---------------------------+
| TRIM(&#39;   hello world   &#39;) |
+---------------------------+
| hello world               |
+---------------------------+
mysql&amp;gt; select TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);
+------------------------------------+
| TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;) |
+------------------------------------+
| barxxx                             |
+------------------------------------+
mysql&amp;gt; select TRIM(TRAILING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);       
+-------------------------------------+
| TRIM(TRAILING &#39;x&#39; FROM &#39;xxxbarxxx&#39;) |
+-------------------------------------+
| xxxbar                              |
+-------------------------------------+
mysql&amp;gt; select TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;);        
+---------------------------------+
| TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;) |
+---------------------------------+
| bar                             |
+---------------------------------+
该函数对多字节是可靠的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SOUNDEX(str)&lt;/strong&gt;&lt;br&gt;
返回str的一个同音字符串。听起来“大致相同”的2个字符串应该有相同的同音字符串。一个“标准”的同音字符串长是4个字符，但是SOUNDEX()函数返回一个任意长的字符串。你可以在结果上使用SUBSTRING()得到一个“标准”的 同音串。所有非数字字母字符在给定的字符串中被忽略。所有在A-Z之外的字符国际字母被当作元音。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SOUNDEX(&#39;Hello&#39;);
+------------------+
| SOUNDEX(&#39;Hello&#39;) |
+------------------+
| H400             |
+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SPACE(N)&lt;/strong&gt;&lt;br&gt;
返回由N个空格字符组成的一个字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select SPACE(32);
+----------------------------------+
| SPACE(32)                        |
+----------------------------------+
|                                  |
+----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;REPLACE(str,from_str,to_str)&lt;/strong&gt;&lt;br&gt;
返回字符串str，其字符串from_str的所有出现由字符串to_str代替。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select REPLACE(&#39;www.mysql.com&#39;, &#39;w&#39;, &#39;M&#39;); 
+------------------------------------+
| REPLACE(&#39;www.mysql.com&#39;, &#39;w&#39;, &#39;M&#39;) |
+------------------------------------+
| MMM.mysql.com                      |
+------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;REPEAT(str,count)&lt;/strong&gt;&lt;br&gt;
返回由重复countTimes次的字符串str组成的一个字符串。如果count &amp;lt;= 0，返回一个空字符串。如果str或count是NULL，返回NULL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select REPEAT(&#39;MySQL&#39;, 3);
+--------------------+
| REPEAT(&#39;MySQL&#39;, 3) |
+--------------------+
| MySQLMySQLMySQL    |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;REVERSE(str)&lt;/strong&gt;&lt;br&gt;
返回颠倒字符顺序的字符串str。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select REVERSE(&#39;abc&#39;);
+----------------+
| REVERSE(&#39;abc&#39;) |
+----------------+
| cba            |
+----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;INSERT(str,pos,len,newstr)&lt;/strong&gt;&lt;br&gt;
返回字符串str，在位置pos起始的子串且len个字符长得子串由字符串newstr代替。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select INSERT(&#39;Quadratic&#39;, 3, 5, &#39;What&#39;); 
+-----------------------------------+
| INSERT(&#39;Quadratic&#39;, 3, 5, &#39;What&#39;) |
+-----------------------------------+
| QuWhatic                          |
+-----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ELT(N,str1,str2,str3,...)&lt;/strong&gt;&lt;br&gt;
如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select ELT(1, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;);           
+----------------------------+
| ELT(1, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;) |
+----------------------------+
| A                          |
+----------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FIELD(str,str1,str2,str3,...)&lt;/strong&gt;&lt;br&gt;
返回str在str1, str2, str3, ...清单的索引。如果str没找到，返回0。FIELD()是ELT()反运算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select FIELD(&#39;F&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;EF&#39;);
+--------------------------------------+
| FIELD(&#39;F&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;EF&#39;) |
+--------------------------------------+
|                                    0 |
+--------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FIND_IN_SET(str,strlist)&lt;/strong&gt;&lt;br&gt;
如果字符串str在由N子串组成的表strlist之中，返回一个1到N的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为SET的列，FIND_IN_SET()函数被优化而使用位运算！如果str不是在strlist里面或如果strlist是空字符串，返回0。如果任何一个参数是NULL，返回NULL。如果第一个参数包含一个“,”，该函数将工作不正常。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; SELECT FIND_IN_SET(&#39;C&#39;,&#39;A,B,C,D&#39;);
+----------------------------+
| FIND_IN_SET(&#39;C&#39;,&#39;A,B,C,D&#39;) |
+----------------------------+
|                          3 |
+----------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MAKE_SET(bits,str1,str2,...)&lt;/strong&gt;&lt;br&gt;
返回一个集合 (包含由“,”字符分隔的子串组成的一个字符串)，由相应的位在bits集合中的的字符串组成。str1对应于位0，str2对应位1，等等。在str1, str2, ...中的NULL串不添加到结果中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; SELECT MAKE_SET(4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);
+-------------------------+
| MAKE_SET(4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) |
+-------------------------+
| c                       |
+-------------------------+
mysql&amp;gt; SELECT MAKE_SET(1|4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);
+---------------------------+
| MAKE_SET(1|4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) |
+---------------------------+
| a,c                       |
+---------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EXPORT_SET(bits,on,off,[separator,[number_of_bits]])&lt;/strong&gt;&lt;br&gt;
返回一个字符串，在这里对于在“bits”中设定每一位，你得到一个“on”字符串，并且对于每个复位(reset)的位，你得到一个“off”字符串。每个字符串用“separator”分隔(缺省“,”)，并且只有“bits”的“number_of_bits” (缺省64)位被使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select EXPORT_SET(7,&#39;Y&#39;,&#39;N&#39;,&#39;,&#39;,6);
+-----------------------------+
| EXPORT_SET(7,&#39;Y&#39;,&#39;N&#39;,&#39;,&#39;,6) |
+-----------------------------+
| Y,Y,Y,N,N,N                 |
+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LCASE(str)、LOWER(str)&lt;/strong&gt;&lt;br&gt;
返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成小写。该函数对多字节是可靠的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select LOWER(&#39;Imarkofu&#39;);     
+-------------------+
| LOWER(&#39;Imarkofu&#39;) |
+-------------------+
| imarkofu          |
+-------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;UCASE(str)、UPPER(str)&lt;/strong&gt;&lt;br&gt;
返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成大写。该函数对多字节是可靠的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select UPPER(&#39;Imarkofu&#39;);
+-------------------+
| UPPER(&#39;Imarkofu&#39;) |
+-------------------+
| IMARKOFU          |
+-------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LOAD_FILE(file_name)&lt;/strong&gt;&lt;br&gt;
读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select load_file(&amp;quot;/abc.txt&amp;quot;);                                        
+-----------------------+
| load_file(&amp;quot;/abc.txt&amp;quot;) |
+-----------------------+
| ABC
                  |
+-----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL必要时自动变换数字为字符串，并且反过来也如此：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; SELECT 3+&amp;quot;2&amp;quot;;
+-------+
| 3+&amp;quot;2&amp;quot; |
+-------+
|     5 |
+-------+
mysql&amp;gt; SELECT CONCAT(3+&amp;quot;2&amp;quot;,&#39; total&#39;);
+------------------------+
| CONCAT(3+&amp;quot;2&amp;quot;,&#39; total&#39;) |
+------------------------+
| 5 total                |
+------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。&lt;br&gt;
如果字符串函数提供一个二进制字符串作为参数，结果字符串也是一个二进制字符串。被变换到一个字符串的数字被当作是一个二进制字符串。这仅影响比较;&lt;/p&gt;
">mysql字符函数详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/linux-date-command/"" data-c="
          &lt;p&gt;date命令是显示或设置系统时间与日期。&lt;br&gt;
很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id=&#34;选项&#34;&gt;选项&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;-d&amp;lt;字符串&amp;gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；&lt;br&gt;
-s&amp;lt;字符串&amp;gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；&lt;br&gt;
-u：显示GMT；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;lt;+时间日期格式&amp;gt;：指定显示时使用的日期时间格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;日期格式字符串列表&#34;&gt;日期格式字符串列表&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;%H 小时，24小时制（00~23）&lt;br&gt;
%I 小时，12小时制（01~12）&lt;br&gt;
%k 小时，24小时制（0~23）&lt;br&gt;
%l 小时，12小时制（1~12）&lt;br&gt;
%M 分钟（00~59）&lt;br&gt;
%p 显示出AM或PM&lt;br&gt;
%r 显示时间，12小时制（hh:mm:ss %p）&lt;br&gt;
%s 从1970年1月1日00:00:00到目前经历的秒数&lt;br&gt;
%S 显示秒（00~59）&lt;br&gt;
%T 显示时间，24小时制（hh:mm:ss）&lt;br&gt;
%X 显示时间的格式（%H:%M:%S）&lt;br&gt;
%Z 显示时区，日期域（CST）&lt;br&gt;
%a 星期的简称（Sun~Sat）&lt;br&gt;
%A 星期的全称（Sunday~Saturday）&lt;br&gt;
%h,%b 月的简称（Jan~Dec）&lt;br&gt;
%B 月的全称（January~December）&lt;br&gt;
%c 日期和时间（Tue Nov 20 14:12:58 2012）&lt;br&gt;
%d 一个月的第几天（01~31）&lt;br&gt;
%x,%D 日期（mm/dd/yy）&lt;br&gt;
%j 一年的第几天（001~366）&lt;br&gt;
%m 月份（01~12）&lt;br&gt;
%w 一个星期的第几天（0代表星期天）&lt;br&gt;
%W 一年的第几个星期（00~53，星期一为第一天）&lt;br&gt;
%y 年的最后两个数字（1999则是99）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;格式化输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date +&amp;quot;%Y-%m-%d&amp;quot;&lt;br&gt;
2016-12-29&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出昨天日期：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -d &amp;quot;1 day ago&amp;quot; +&amp;quot;%Y-%m-%d&amp;quot;&lt;br&gt;
2016-12-28&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2秒后输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -d &amp;quot;2 second&amp;quot; +&amp;quot;%Y-%m-%d %H:%M.%S&amp;quot;&lt;br&gt;
2016-12-29 14:37.22&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传说中的 1234567890 秒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -d &amp;quot;1970-01-01 1482990408 seconds&amp;quot; +&amp;quot;%Y-%m-%d %H:%m:%S&amp;quot;&lt;br&gt;
2016-12-29 05:12:48&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;普通转格式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -d &amp;quot;2016-12-29&amp;quot; +&amp;quot;%Y/%m/%d %H:%M.%S&amp;quot;&lt;br&gt;
2016/12/29 00:00.00&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apache格式转换：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -d &amp;quot;Dec 29, 2016 12:00:37 AM&amp;quot; +&amp;quot;%Y-%m-%d %H:%M.%S&amp;quot;&lt;br&gt;
2016-12-29 00:00.37&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;格式转换后时间游走：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -d &amp;quot;Dec 29, 2016 12:00:37 AM 2 year ago&amp;quot; +&amp;quot;%Y-%m-%d %H:%M.%S&amp;quot;&lt;br&gt;
2014-12-29 00:00.37&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加减操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date -s //设置当前时间，只有root权限才能设置，其他只能查看&lt;br&gt;
date -s 20161229 //设置成20120523，这样会把具体时间设置成空00:00:00&lt;br&gt;
date -s 01:01:01 //设置具体时间，不会对日期做更改&lt;br&gt;
date -s &amp;quot;01:01:01 2016-12-29&amp;quot; //这样可以设置全部时间&lt;br&gt;
date -s &amp;quot;01:01:01 20161229&amp;quot; //这样可以设置全部时间&lt;br&gt;
date -s &amp;quot;2016-12-29 01:01:01&amp;quot; //这样可以设置全部时间&lt;br&gt;
date -s &amp;quot;20161229 01:01:01&amp;quot; //这样可以设置全部时间&lt;/p&gt;
&lt;/blockquote&gt;
">linux date命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/svn-backup/"" data-c="
          &lt;h1 id=&#34;备份策略&#34;&gt;备份策略&lt;/h1&gt;
&lt;p&gt;svn备份一般采用三种方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1）svnadmin dump&lt;br&gt;
2)svnadmin hotcopy&lt;br&gt;
3)svnsync&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;-more-注意svn备份不宜采用普通的文件拷贝方式除非你备份的时候将库暂停如copy命令-rsync命令-优缺点分析&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
**注意：**svn备份不宜采用普通的文件拷贝方式（除非你备份的时候将库暂停），如copy命令、rsync命令。&lt;br&gt;
优缺点分析&lt;/h1&gt;
&lt;p&gt;第一种svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。&lt;br&gt;
缺点是：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。&lt;br&gt;
个人建议在版本数比较小的情况下使用这种备份方式。&lt;br&gt;
第二种svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；&lt;br&gt;
优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。&lt;br&gt;
缺点是：比较耗费硬盘，需要有较大的硬盘支持（俺的备份机有1TB空间，呵呵）。&lt;br&gt;
第三种svnsync实际上是制作2个镜像库，当一个坏了的时候，可以迅速切换到另一个。不过，必须svn1.4版本以上才支持这个功能。&lt;br&gt;
优点是：当制作成2个镜像库的时候起到双机实时备份的作用；&lt;br&gt;
缺点是：当作为2个镜像库使用时，没办法做到“想完全抛弃今天的修改恢复到昨晚的样子”；而当作为普通备份机制每日备份时，操作又较前2种方法麻烦。&lt;/p&gt;
&lt;h1 id=&#34;备份方案&#34;&gt;备份方案&lt;/h1&gt;
&lt;p&gt;以下是个人的备份方案：&lt;br&gt;
1、定期对线上SVN进行全量备份【目前每月1号】&lt;br&gt;
svnadmin dump /仓库路径/仓库名 |gzip &amp;gt; ~/svn/仓库名_yyyyMMdd.gz&lt;br&gt;
将备份文件统一上传到其他设备的备份目录下进行存档&lt;/p&gt;
&lt;p&gt;2、定期进行全量备份恢复测试&lt;br&gt;
解压.gz文件&lt;br&gt;
建立新的svn仓库&lt;br&gt;
导入存储库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;svnadmin load 仓库路径 &amp;lt; 解压的备份文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、对常用的几个SVN仓库进行热备份&lt;br&gt;
首先在其他设备上上编译安装SVN&lt;br&gt;
创建需要备份的仓库（这里以sm为例）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;svnadmin create 从仓库路径&lt;br&gt;
cp /从仓库路径/hooks/pre-revprop-change.tmpl /从仓库路径/hooks/pre-revprop-change&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改/从仓库路径/hooks/pre-revprop-change的内容，将最后的&amp;quot;exit 1&amp;quot;修改&amp;quot;exit 0&amp;quot;&lt;br&gt;
增加执行权限&lt;br&gt;
将主svn的对应仓库目录下的所有配置文件拷贝到从svn的仓库目录下覆盖替换&lt;/p&gt;
&lt;p&gt;在从SVN上执行如下命令，进行初始化【这里尚未开始进行同步】&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;svnsync init 从仓库地址  主仓库地址&lt;br&gt;
svnsync init file:///从仓库路径 主仓库地址&lt;br&gt;
注意这里是三个/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里会询问当前Linux用户的密码，主SVN用户名，主SVN密码&lt;br&gt;
输入相应即可，然后会询问是否明文存储【这里建议输入no不存在，每次自行输入】&lt;/p&gt;
&lt;p&gt;开始同步数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;svnsync sync file:///从仓库路径&lt;br&gt;
这里如果又用户正在提交SVN时，可能会出现获取锁失败的问题，需要清除锁的命令，再继续同步&lt;br&gt;
svn propdel svn:sync-lock --revprop -r0  file:///从仓库路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同步完成之后，为了保证后续的SVN更新都能自动同步到从svn中&lt;br&gt;
需要在主SVN的/仓库路径/hooks下建立post-commit脚本，增加如下内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;svnsync sync --non-interactive 从仓库地址 --username 用户名 --password 密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此双击热备份即完成，可能还需要做的是定期抽查热备是否正常；&lt;/p&gt;
">SVN备份方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/windows-forgets-the-administrator-password/"" data-c="
          &lt;p&gt;对于一个专业的运维人员而言，可能收下有很多台设备需要管理，这里不免需要记录各种奇奇怪怪的密码，可能发生最北催的事情，莫过于忘记了自己维护设备的管理密码。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;忘记密码其实还是有解决方案的，只需要拿到一张系统的安装光盘。&lt;br&gt;
将光盘放入光驱当中，重启电脑，从光驱启动电脑，在选择“安装语言”的位置，按Shite+F10&lt;br&gt;
此时会弹出一个dos窗口，在这个dos窗口中执行如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd windows\system32
ren Magnify.exe Magnify1.exe
ren cmd.exe Magnify.exe
exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上命令主要是用于替换掉放大镜窗口&lt;br&gt;
然后再次重启电脑，正常启动&lt;br&gt;
在需要输入密码的界面中，点击放大镜，打开放大镜会出现一个dos窗口，这就是我们上面的操作的目的&lt;br&gt;
然后执行如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net user administrator Imarkofu123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：这里的Imarkofu123456即为重置的新密码，你可以根据自己的情况设置密码&lt;br&gt;
还有一点需要注意的是设置密码时不要使用特殊字符，只要数字大小写字母就可以了&lt;br&gt;
然后关闭窗口&lt;br&gt;
输入刚刚重置的密码即可登录了&lt;/p&gt;
">windows server 2008 R2忘记administrator密码</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/centos-safety-reinforcement-and-performance-optimization/"" data-c="
          &lt;p&gt;**说明：**经常玩Linux系统的朋友多多少少也知道些系统参数优化和怎样增强系统安全性，系统默认的一些参数都是比较保守的，所以我们可以通过调整系统参数来提高系统内存、CPU、内核资源的占用，通过禁用不必要的服务、端口，来提高系统的安全性，更好的发挥系统的可用性。通过自己对Linux了解，对系统调优做了如下小结：&lt;br&gt;
**操作系统：**CentOS 6.5_x64最小化安装&lt;/p&gt;
&lt;h2 id=&#34;-more-1-主机名设置&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;
1、主机名设置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# vi /etc/sysconfig/network
HOSTNAME=test.com
[root@localhost~]# hostname test.com  #临时生效
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-关闭selinux&#34;&gt;2、关闭SELinux&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# vi /etc/selinux/config
SELINUX=disabled
[root@localhost~]# setenforce #临时生效
[root@localhost~]# getenforce #查看selinux状态
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-清空防火墙并设置规则&#34;&gt;3、清空防火墙并设置规则&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# iptables -F   #清楚防火墙规则
[root@localhost~]# iptables -L   #查看防火墙规则
[root@localhost~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT
[root@localhost~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT
[root@localhost~]# iptables -A INPUT -p tcp --dport 53 -j ACCEPT
[root@localhost~]# iptables -A INPUT -p udp --dport 53 -j ACCEPT
[root@localhost~]# iptables -A INPUT -p udp --dport 123 -j ACCEPT
[root@localhost~]# iptables -A INPUT -p icmp -j ACCEPT
[root@localhost~]# iptables -P INPUT DROP
[root@localhost~]# /etc/init.d/iptables save
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;根据需求开启相应端口4-添加普通用户并进行sudo授权管理&#34;&gt;根据需求开启相应端口&lt;br&gt;
4、添加普通用户并进行sudo授权管理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# useradd user
[root@localhost~]# echo &amp;quot;123456&amp;quot; | passwd --stdin user  #设置密码
[root@localhost~]# vi /etc/sudoers  #或visudo打开，添加user用户所有权限
root    ALL=(ALL)       ALL
user    ALL=(ALL)       ALL
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-禁用root远程登录&#34;&gt;5、禁用root远程登录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# vi /etc/ssh/sshd_config
PermitRootLogin no
PermitEmptyPasswords no #禁止空密码登录
UseDNS no #关闭DNS查询
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-关闭不必要开机自启动服务&#34;&gt;6、关闭不必要开机自启动服务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# chkconfig auditd off
[root@localhost~]# chkconfig blk-availablility off
[root@localhost~]# chkconfig ip6tables off
[root@localhost~]# chkconfig lvm2-monitor off
[root@localhost~]# chkconfig netfs off
[root@localhost~]# chkconfig udev-post off
[root@localhost~]# chkconfig --list | grep 3:on
crond          0:off   1:off   2:on   3:on   4:on   5:on   6:off
network        0:off   1:off   2:on   3:on   4:on   5:on   6:off
postfix        0:off   1:off   2:on   3:on   4:on   5:on   6:off
rsyslog        0:off   1:off   2:on   3:on   4:on   5:on   6:off
sshd           0:off   1:off   2:on   3:on   4:on   5:on   6:off
[root@localhost~]# 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-删除不必要的系统用户&#34;&gt;7、删除不必要的系统用户&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost~]# awk -F&amp;quot;:&amp;quot; &#39;{print $1}&#39; /etc/passwd
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
uucp
operator
games
gopher
ftp
nobody
vcsa
saslauth
postfix
sshd
ntp
[root@localhost~]# userdel adm
[root@localhost~]# userdel lp
[root@localhost~]# userdel shutdown
[root@localhost~]# userdel halt
[root@localhost~]# userdel uucp
[root@localhost~]# userdel operator
[root@localhost~]# userdel games
[root@localhost~]# userdel gopher
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-关闭重启ctl-alt-delete组合键&#34;&gt;8、关闭重启ctl-alt-delete组合键&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# vi /etc/init/control-alt-delete.conf
#exec /sbin/shutdown -r now &amp;quot;Control-Alt-Deletepressed&amp;quot;  #注释掉
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-调整文件描述符大小&#34;&gt;9、调整文件描述符大小&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ulimit –n #默认是1024
1024
[root@localhost ~]# echo &amp;quot;ulimit -SHn 102400&amp;quot;&amp;gt;&amp;gt; /etc/rc.local   #设置开机自动生效
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-修改history记录&#34;&gt;11、修改history记录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# vi /etc/profile  #修改记录10个
HISTSIZE=10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-同步系统时间&#34;&gt;12、同步系统时间&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime  #设置Shanghai时区
[root@localhost ~]# ntpdate cn.pool.ntp.org ；hwclock–w  #同步时间并写入blos硬件时间
[root@localhost ~]# crontab –e     #设置任务计划每天零点同步一次
0 0 * * * /usr/sbin/ntpdate cn.pool.ntp.org ; hwclock -w
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-内核参数优化&#34;&gt;13、内核参数优化&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# vi /etc/sysctl.conf    #末尾添加如下参数
net.ipv4.tcp_syncookies = 1            #1是开启SYN Cookies，当出现SYN等待队列溢出时，启用Cookies来处，理，可防范少量SYN攻击，默认是0关闭
net.ipv4.tcp_tw_reuse = 1              #1是开启重用，允许讲TIME_AIT sockets重新用于新的TCP连接，默认是0关闭
net.ipv4.tcp_tw_recycle = 1            #TCP失败重传次数，默认是15，减少次数可释放内核资源
net.ipv4.ip_local_port_range = 4096 65000  #应用程序可使用的端口范围
net.ipv4.tcp_max_tw_buckets = 5000     #系统同时保持TIME_WAIT套接字的最大数量，如果超出这个数字，TIME_WATI套接字将立刻被清除并打印警告信息，默认180000
net.ipv4.tcp_max_syn_backlog = 4096    #进入SYN宝的最大请求队列，默认是1024
net.core.netdev_max_backlog =  10240   #允许送到队列的数据包最大设备队列，默认300
net.core.somaxconn = 2048              #listen挂起请求的最大数量，默认128
net.core.wmem_default = 8388608        #发送缓存区大小的缺省值
net.core.rmem_default = 8388608        #接受套接字缓冲区大小的缺省值（以字节为单位）
net.core.rmem_max = 16777216           #最大接收缓冲区大小的最大值
net.core.wmem_max = 16777216           #发送缓冲区大小的最大值
net.ipv4.tcp_synack_retries = 2        #SYN-ACK握手状态重试次数，默认5
net.ipv4.tcp_syn_retries = 2           #向外SYN握手重试次数，默认4
net.ipv4.tcp_tw_recycle = 1            #开启TCP连接中TIME_WAIT sockets的快速回收，默认是0关闭
net.ipv4.tcp_max_orphans = 3276800     #系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上，如果超出这个数字，孤儿连接将立即复位并打印警告信息
net.ipv4.tcp_mem = 94500000 915000000 927000000
net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力；
net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段；
net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。内存单位是页，可根据物理内存大小进行调整，如果内存足够大的话，可适当往上调。上述内存单位是页，而不是字节。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此CentOS 6.5_x64最小化安装系统基本优化调整完毕，需要重启下系统。&lt;/p&gt;
">CentOS 6.5安全加固及性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/centos-compile-and-install-MySQL/"" data-c="
          &lt;p&gt;在开始之前我们需要准备一些库文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# yum install zlib-devel openssl-devel gcc-c++ gcc bison cmake ncurses-devel -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一定要安装这些包， LZ之前没有安装就开始编译MySQL，踩了好多坑， 后来上网一查才发现需要这些文件和管理工具才行。因此一定要安装。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;还有如果大家编译过程中出错, 请一定要执行:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# rm -f CMakeCache.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后再继续安装。&lt;br&gt;
安装好之后我们来添加MySQL数据库需要的账户和目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# groupadd -r mysql
[root@imarkofu ~]# useradd -g mysql -r -s /sbin/nologin mysql
[root@imarkofu ~]# id mysql #确认用户
[root@imarkofu ~]# mkdir /var/data/mysql -p #存放数据库文件
[root@imarkofu ~]# chown mysql:mysql /var/data -R
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载MySQL源码包：&lt;a href=&#34;http://pan.baidu.com/s/1c0fdgdE&#34;&gt;mysql-5.5.40.tar.gz&lt;/a&gt;&lt;br&gt;
下载后上传到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# tar -xvf mysql-5.5.40.tar.gz -C /usr/local/src/
[root@imarkofu ~]# cd /usr/local/src/mysql-5.5.40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cmake编译MySQL的一些常用选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------------------------------------------------------
cmake mysql 编译安装:
./configure -&amp;gt; cmake .
./configure --help -&amp;gt; cmake -LH -&amp;gt; ccmake .
------------------------------------------------------------
指定安装文件的安装路径常用选项
-DCMAKE_INSTALL_PREFIX=/usr/local/mysql
-DMYSQL_DATADIR=/data/mysql
-DSYSCONFDIR=/etc
------------------------------------------------------------
默认编译的存储引擎包括: csv, myisma, myisammrg, heap. 若要安装其他存储引擎,可以使用类似如下的编译选项
-DWITH_INNOBASE_STORAGE_ENGINE=1
-DWITH_ARCHIVE_STORAGE_ENGINE=1
-DWITH_BLACKHOLE_STORAGE_ENGINE=1
------------------------------------------------------------
若要明确指出不编译某存储引擎, 可以使用类似如下的选项:
-DWITHOUT_&amp;lt;ENGINE&amp;gt;_STORAGE_ENGINE=1
例如:
-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1
-DWITHOUT_FEDERATED_STORAGE_ENGINE=1
------------------------------------------------------------
若要编译进其他功能, 如SSl等, 可使用类似如下选项来实现编译时使用某库文件或者, 或者不使用某库文件.
-DWITH_READLINE=1
-DWITH_SSL=system
-DWITH_ZLIB=system
-DWITH_LIBWRAP=0
------------------------------------------------------------
其他常用选项:
-DMYSQL_TCP_PORT=3306
-MYDQL_UNIX_ADDR=/tmp/mysql.sock
-DENABLED_LOCAL_INFILE=1
-DEXTRA_CHARSETS=all
-DDEFAULT_CHARSET=utf8
-DDEFAULT_COLLATION=utf8_general_ci
-DWITH_DEBUG=0
-DENABLE_PROFILING=1
------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql-5.5.40 \
-DMYSQL_DATADIR=/var/data/mysql \ #数据库目录
-DSYSCONFDIR=/etc \ #配置文件目录
-DWITH_INNOBASE_STORAGE_ENGINE=1 \ #启用InnoDB存储引擎
-DWITH_ARCHIVE_STORAGE_ENGINE=1 \ #启用ARCHIVE存储引擎
-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ #启用黑洞存储引擎
-DWITH_READLINE=1 \
-DWITH_SSL=system \ #启用SSL协议
-DWITH_ZLIB=system \ #启用Zlib压缩
-DWITH_LIBWRAP=0 \
-DDEFAULT_CHARSET=utf8 \ #设置字符集utf8
-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \
-DDEFAULT_COLLATION=utf8_general_ci
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果出现以下信息，那么恭喜你第一阶段的配置顺利完成了&lt;br&gt;
过程中如果出现错误也不要害怕， 因为你长经验的时刻就要来了， 通常是因为缺少了什么依赖的包而出现的问题， 你可以把你的错误信息铁道Google或者百度中去搜索。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;....(此处省略一万字)
-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS
-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS - Success
-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC
-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC - Success
-- Check size of pthread_t
-- Check size of pthread_t - done
-- Performing Test HAVE_PEERCRED
-- Performing Test HAVE_PEERCRED - Success
-- Library mysqlclient depends on OSLIBS -lpthread;z;m;rt;/usr/lib64/libssl.so;/usr/lib64/libcrypto.so;dl
-- Configuring done
-- Generating done
-- Build files have been written to: /usr/local/mysql-5.5.40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继续&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# make
....(此处省略一万字)
Scanning dependencies of target udf_example
[100%] Building C object sql/CMakeFiles/udf_example.dir/udf_example.c.o
Linking C shared module udf_example.so
[100%] Built target udf_example
Scanning dependencies of target my_safe_process
[100%] Building CXX object mysql-test/lib/My/SafeProcess/CMakeFiles/my_safe_process.dir/safe_process.cc.o
Linking CXX executable my_safe_process
[100%] Built target my_safe_process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有报错，继续&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# make install
....(此处省略一万字)
-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_upgrade.1
-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlslap.1
-- Installing: /usr/local/mysql-5.5.40/man/man1/replace.1
-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql.1
-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_setpermission.1
-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_secure_installation.1
-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlimport.1
-- Installing: /usr/local/mysql-5.5.40/man/man8/mysqld.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部安装ok之后我们来配置下文档的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# chown :mysql /usr/local/mysql-5.5.40 -R
[root@imarkofu mysql-5.5.40]# cd /usr/local/mysql-5.5.40/
[root@imarkofu mysql-5.5.40]# chmod +x scripts/mysql_install_db
[root@imarkofu mysql-5.5.40]# scripts/mysql_install_db --user=mysql --datadir=/var/data/mysql/ #执行初始化脚本
....(此处省略一万字)
./bin/mysqladmin -u root password &#39;new-password&#39;
./bin/mysqladmin -u root -h imarkofu password &#39;new-password&#39;
 
Alternatively you can run:
./bin/mysql_secure_installation
 
which will also give you the option of removing the test
databases and anonymous user created by default.  This is
strongly recommended for production servers.
 
See the manual for more instructions.
 
You can start the MySQL daemon with:
cd . ; ./bin/mysqld_safe &amp;amp;
 
You can test the MySQL daemon with mysql-test-run.pl
cd ./mysql-test ; perl mysql-test-run.pl
 
Please report any problems at http://bugs.mysql.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你获得的信息和上面一样的话, 恭喜你, 你又离成功近了一步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# ls /var/data/mysql/ #看一下是否生成了文件
mysql  performance_schema  test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是这样那么继续&lt;br&gt;
创建服务脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld 
[root@imarkofu mysql-5.5.40]# chmod +x /etc/rc.d/init.d/mysqld #添加mysqld执行权限
[root@imarkofu mysql-5.5.40]# chkconfig --add mysqld #添加开机启动
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# mv /etc/my.cnf{,.bak}
[root@imarkofu mysql-5.5.40]# cp support-files/my-large.cnf /etc/my.cnf
[root@imarkofu mysql-5.5.40]# vim /etc/my.cnf

#找到如下部分
[mysqld]
port            = 3306
socket          = /tmp/mysql.sock
skip-external-locking
key_buffer_size = 256M
max_allowed_packet = 1M
table_open_cache = 256
sort_buffer_size = 1M
read_buffer_size = 1M
read_rnd_buffer_size = 4M
myisam_sort_buffer_size = 64M
thread_cache_size = 8
query_cache_size= 16M
# Try number of CPU&#39;s*2 for thread_concurrency
thread_concurrency = 8
datadir= /var/data/mysql #添加次行内容, 就是数据库文件存放路径
:wq
#保存退出

[root@imarkofu mysql-5.5.40]# vim /etc/profile.d/mysql.sh
export PATH=/usr/local/mysql-5.5.40/bin:$PATH #添加此行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，尝试着启动MySQL服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# service mysqld start
Starting MySQL..                                           [  OK  ]
[root@imarkofu mysql-5.5.40]#
[root@imarkofu mysql-5.5.40]# ss -tnl| grep :3306 
LISTEN     0      50                        *:3306                     *:*    
#发现正常监听 3306端口
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;距离胜利越来越近了&lt;br&gt;
然后配置MySQL管理员密码进行初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# mysql #使用客户端登录
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.5.40-log Source distribution
Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
mysql&amp;gt; 
#查看一下默认存在的用户
mysql&amp;gt; select user,password,host from mysql.user; 
+------+----------+-----------+
| user | password | host      |
+------+----------+-----------+
| root |          | localhost |
| root |          | imarkofu  |
| root |          | 127.0.0.1 |
| root |          | ::1       |
|      |          | localhost |
|      |          | imarkofu  |
+------+----------+-----------+
6 rows in set (0.00 sec)
mysql&amp;gt; 

#删除默认存在的账户, 要求用户只能从本地服务器访问数据库
mysql&amp;gt; delete from mysql.user where host!=&#39;localhost&#39;; 
Query OK, 4 rows affected (0.00 sec)

#修改root管理员账号密码
mysql&amp;gt; update mysql.user set password=PASSWORD(&#39;p@ssw0rd&#39;) where user=&#39;root&#39;; 
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
 
#更新数据库
mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
 
#看一下修改后的结果
mysql&amp;gt; select user,password,host from mysql.user;
+------+-------------------------------------------+-----------+
| user | password                                  | host      |
+------+-------------------------------------------+-----------+
| root | *D7E39C3AF517EC9EF7086223B036E0B4F22821F8 | localhost |
|      |                                           | localhost |
+------+-------------------------------------------+-----------+
2 rows in set (0.00 sec)
mysql&amp;gt; \q
Bye
[root@imarkofu mysql-5.5.40]#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以使用新密码登陆了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# mysql -u root -h localhost -p
Enter password: #输入刚才设置的密码
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.5.40-log Source distribution
Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了MySQL到此 就安装成功了&lt;br&gt;
对了，忘记了导入开发的库文件了， ok 很快就好&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# ln -sv /usr/local/mysql/include/ /usr/include/mysql #软连接到系统库中
[root@imarkofu mysql-5.5.40]# vim /etc/ld.so.conf.d/mysql.conf #编辑这个文件, 并且添加如下路径
/usr/local/mysql-5.5.40/lib
[root@imarkofu mysql-5.5.40]# ldconfig #重新加载库文件
[root@imarkofu mysql-5.5.40]# ldconfig -p | grep mysql #让我们来检查下是不是加载好了
    libmysqlclient_r.so.16 (libc6,x86-64) =&amp;gt; /usr/lib64/mysql/libmysqlclient_r.so.16
    libmysqlclient.so.18 (libc6,x86-64) =&amp;gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so.18
    libmysqlclient.so.16 (libc6,x86-64) =&amp;gt; /usr/lib64/mysql/libmysqlclient.so.16
    libmysqlclient.so (libc6,x86-64) =&amp;gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，MySQL5.5.40 编译安装完成&lt;/p&gt;
">centos 6.5 编译安装 mysql 5.5.40</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/optimize-mysql-in-subqueries/"" data-c="
          &lt;p&gt;现在的CMS系统、博客系统、BBS等都喜欢使用标签tag作交叉链接，因此我也尝鲜用了下。但用了后发现我想查询某个tag的文章列表时速度很慢，达到5秒之久！百思不解(后来终于解决)，我的表结构是下面这样的，文章只有690篇。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;文章表article(id,title,content)&lt;br&gt;
标签表tag(tid,tag_name)&lt;br&gt;
标签文章中间表article_tag(id,tag_id,article_id)&lt;br&gt;
其中有个标签的tid是135，我帮查询标签tid是135的文章列表&lt;br&gt;
用以下语句时发现速度好慢,我文章才690篇&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select id,title from article where id in(select article_id from article_tag where tag_id=135)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中这条速度很快：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select article_id from article_tag where tag_id=135&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询结果是五篇文章，id为428,429,430,431,432&lt;br&gt;
我用写死的方式用下面sql来查文章也很快&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select id,title from article where id in(428,429,430,431,432)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在SqlServer中好像不会这样慢，不知MySQL怎样写好点，也想不出慢在哪里。&lt;br&gt;
后来我找到了解决方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select id,title from article where id in(select article_id from (select article_id from article_tag where tag_id=135) as tbt)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其它解决方法：（举例）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = &#39;82306839&#39;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了节省篇幅，省略了输出内容，下同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;67 rows in set (12.00 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只有67行数据返回，却花了12秒，而系统中可能同时会有很多这样的查询，系统肯定扛不住。用desc看一下(注：explain也可)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql&amp;gt;desc select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = &#39;82306839&#39;);&lt;br&gt;
+----+--------------------+------------------+--------+-----------------+-------+---------+------------+---------+--------------------------+&lt;br&gt;
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |&lt;br&gt;
+----+--------------------+------------------+--------+-----------------+-------+---------+------------+---------+--------------------------+&lt;br&gt;
| 1 | PRIMARY | abc_number_prop | ALL | NULL | NULL | NULL | NULL | 2679838 | Using where |&lt;br&gt;
| 2 | DEPENDENT SUBQUERY | abc_number_phone | eq_ref | phone,number_id | phone | 70 | const,func | 1 | Using where; Using index |&lt;br&gt;
+----+--------------------+------------------+--------+-----------------+-------+---------+------------+---------+--------------------------+&lt;br&gt;
2 rows in set (0.00 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的信息可以看出，在执行此查询时会扫描两百多万行，难道是没有创建索引吗，看一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql&amp;gt;show index from abc_number_phone;&lt;br&gt;
+------------------+------------+-------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |&lt;br&gt;
+------------------+------------+-------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;
| abc_number_phone | 0 | PRIMARY | 1 | number_phone_id | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_phone | 0 | phone | 1 | phone | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_phone | 0 | phone | 2 | number_id | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_phone | 1 | number_id | 1 | number_id | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_phone | 1 | created_by | 1 | created_by | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_phone | 1 | modified_by | 1 | modified_by | A | 36879 | NULL | NULL | YES | BTREE | | |&lt;br&gt;
+------------------+------------+-------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;
6 rows in set (0.06 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql&amp;gt;show index from abc_number_prop;&lt;br&gt;
+-----------------+------------+-------------+--------------+----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |&lt;br&gt;
+-----------------+------------+-------------+--------------+----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;
| abc_number_prop | 0 | PRIMARY | 1 | number_prop_id | A | 311268 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_prop | 1 | number_id | 1 | number_id | A | 311268 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_prop | 1 | created_by | 1 | created_by | A | 311268 | NULL | NULL | | BTREE | | |&lt;br&gt;
| abc_number_prop | 1 | modified_by | 1 | modified_by | A | 311268 | NULL | NULL | YES | BTREE | | |&lt;br&gt;
+-----------------+------------+-------------+--------------+----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;
4 rows in set (0.15 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的输出可以看出，这两张表在number_id字段上创建了索引的。&lt;br&gt;
看看子查询本身有没有问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql&amp;gt;desc select number_id from abc_number_phone where phone = &#39;82306839&#39;;&lt;br&gt;
+----+-------------+------------------+------+---------------+-------+---------+-------+------+--------------------------+&lt;br&gt;
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |&lt;br&gt;
+----+-------------+------------------+------+---------------+-------+---------+-------+------+--------------------------+&lt;br&gt;
| 1 | SIMPLE | abc_number_phone | ref | phone | phone | 66 | const | 6 | Using where; Using index |&lt;br&gt;
+----+-------------+------------------+------+---------------+-------+---------+-------+------+--------------------------+&lt;br&gt;
1 row in set (0.00 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有问题，只需要扫描几行数据，索引起作用了。查询出来看看&lt;br&gt;
mysql&amp;gt;select number_id from abc_number_phone where phone = &#39;82306839&#39;;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;+-----------+&lt;br&gt;
| number_id |&lt;br&gt;
+-----------+&lt;br&gt;
| 8585 |&lt;br&gt;
| 10720 |&lt;br&gt;
| 148644 |&lt;br&gt;
| 151307 |&lt;br&gt;
| 170691 |&lt;br&gt;
| 221897 |&lt;br&gt;
+-----------+&lt;br&gt;
6 rows in set (0.00 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接把子查询得到的数据放到上面的查询中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql&amp;gt; select * from abc_number_prop where number_id in (8585, 10720, 148644, 151307, 170691, 221897);&lt;br&gt;
67 rows in set (0.03 sec)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;速度也快，看来MySQL在处理子查询的时候是不够好。我在MySQL 5.1.42 和 MySQL 5.5.19 都进行了尝试，都有这个问题。&lt;/p&gt;
">mysql in 子查询 效率慢 优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/gets-the-screen-properties-by-JS/"" data-c="
          &lt;p&gt;JS获取当前对象大小属性以及屏幕分辨率属性等&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
function getInfo(){ 
    var s = &amp;quot;&amp;quot;;   
    s += &amp;quot; 网页可见区域宽：&amp;quot;+ document.body.clientWidth+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页可见区域高：&amp;quot;+ document.body.clientHeight+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页可见区域宽：&amp;quot;+ document.body.offsetWidth + &amp;quot; (包括边线和滚动条的宽)&amp;quot;+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页可见区域高：&amp;quot;+ document.body.offsetHeight + &amp;quot; (包括边线的宽)&amp;quot;+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页正文全文宽：&amp;quot;+ document.body.scrollWidth+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页正文全文高：&amp;quot;+ document.body.scrollHeight+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页被卷去的高(ff)：&amp;quot;+ document.body.scrollTop+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页被卷去的高(ie)：&amp;quot;+ document.documentElement.scrollTop+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页被卷去的左：&amp;quot;+ document.body.scrollLeft+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页正文部分上：&amp;quot;+ window.screenTop+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 网页正文部分左：&amp;quot;+ window.screenLeft+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 屏幕分辨率的高：&amp;quot;+ window.screen.height+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 屏幕分辨率的宽：&amp;quot;+ window.screen.width+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 屏幕可用工作区高度：&amp;quot;+ window.screen.availHeight+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 屏幕可用工作区宽度：&amp;quot;+ window.screen.availWidth+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 你的屏幕设置是 &amp;quot;+ window.screen.colorDepth +&amp;quot; 位彩色&amp;quot;+&amp;quot;\n&amp;quot;;    
    s += &amp;quot; 你的屏幕设置 &amp;quot;+ window.screen.deviceXDPI +&amp;quot; 像素/英寸&amp;quot;+&amp;quot;\n&amp;quot;;    
    alert (s);
}
getInfo();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">JS获取当前对象大小属性以及屏幕分辨率属性等</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/translation-redid-conf/"" data-c="
          &lt;p&gt;redis 2.4的conf文件的中文翻译，大致参考。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;# Redis示例配置文件

# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：
#
# 1k =&amp;gt; 1000 bytes
# 1kb =&amp;gt; 1024 bytes
# 1m =&amp;gt; 1000000 bytes
# 1mb =&amp;gt; 1024*1024 bytes
# 1g =&amp;gt; 1000000000 bytes
# 1gb =&amp;gt; 1024*1024*1024 bytes
#
# 单位是大小写不敏感的，所以1GB 1Gb 1gB的写法都是完全一样的。

# Redis默认是不作为守护进程来运行的。你可以把这个设置为&amp;quot;yes&amp;quot;让它作为守护进程来运行。
# 注意，当作为守护进程的时候，Redis会把进程ID写到 /var/run/redis.pid
daemonize no

# 当以守护进程方式运行的时候，Redis会把进程ID默认写到 /var/run/redis.pid。你可以在这里修改路径。
pidfile /var/run/redis.pid

# 接受连接的特定端口，默认是6379。
# 如果端口设置为0，Redis就不会监听TCP套接字。
port 6379

# 如果你想的话，你可以绑定单一接口；如果这里没单独设置，那么所有接口的连接都会被监听。
#
# bind 127.0.0.1

# 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果你不指定的话，Redis就不会通过unix套接字来监听。
#
# unixsocket /tmp/redis.sock
# unixsocketperm 755

#一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)
timeout 0

# 设置服务器调试等级。
# 可能值：
# debug （很多信息，对开发/测试有用）
# verbose （很多精简的有用信息，但是不像debug等级那么多）
# notice （适量的信息，基本上是你生产环境中需要的程度）
# warning （只有很重要/严重的信息会记录下来）
loglevel verbose

# 指明日志文件名。也可以使用&amp;quot;stdout&amp;quot;来强制让Redis把日志信息写到标准输出上。
# 注意：如果Redis以守护进程方式运行，而你设置日志显示到标准输出的话，那么日志会发送到 /dev/null
logfile stdout

# 要使用系统日志记录器很简单，只要设置 &amp;quot;syslog-enabled&amp;quot; 为 &amp;quot;yes&amp;quot; 就可以了。
# 然后根据需要设置其他一些syslog参数就可以了。
# syslog-enabled no

# 指明syslog身份
# syslog-ident redis

# 指明syslog的设备。必须是一个用户或者是 LOCAL0 ~ LOCAL7 之一。
# syslog-facility local0

# 设置数据库个数。默认数据库是 DB 0，你可以通过SELECT &amp;lt;dbid&amp;gt; WHERE dbid（0～&#39;databases&#39; - 1）来为每个连接使用不同的数据库。
databases 16

################################ 快照 #################################

#
# 把数据库存到磁盘上:
#
#   save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;
#   
#   会在指定秒数和数据变化次数之后把数据库写到磁盘上。
#
#   下面的例子将会进行把数据写入磁盘的操作:
#   900秒（15分钟）之后，且至少1次变更
#   300秒（5分钟）之后，且至少10次变更
#   60秒之后，且至少10000次变更
#
#   注意：你要想不写磁盘的话就把所有 &amp;quot;save&amp;quot; 设置注释掉就行了。

save 900 1
save 300 10
save 60 10000

# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象。
# 默认设置为 &amp;quot;yes&amp;quot;，所以几乎总是生效的。
# 如果你想节省CPU的话你可以把这个设置为 &amp;quot;no&amp;quot;，但是如果你有可压缩的key的话，那数据文件就会更大了。
rdbcompression yes

# 数据库的文件名
dbfilename dump.rdb

# 工作目录
#
# 数据库会写到这个目录下，文件名就是上面的 &amp;quot;dbfilename&amp;quot; 的值。
# 
# 累加文件也放这里。
# 
# 注意你这里指定的必须是目录，不是文件名。
dir ./

################################# 同步 #################################

#
# 主从同步。通过 slaveof 配置来实现Redis实例的备份。
# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。
#
# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;

# 如果master设置了密码（通过下面的 &amp;quot;requirepass&amp;quot; 选项来配置），那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。
#
# masterauth &amp;lt;master-password&amp;gt;

# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：
#
# 1) 如果 slave-serve-stale-data 设置为 &amp;quot;yes&amp;quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。
# 2) 如果 slave-serve-stale-data 设置为 &amp;quot;no&amp;quot;，slave会回复&amp;quot;正在从master同步（SYNC with master in progress）&amp;quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。
#
slave-serve-stale-data yes

# slave根据指定的时间间隔向服务器发送ping请求。
# 时间间隔可以通过 repl_ping_slave_period 来设置。
# 默认10秒。
#
# repl-ping-slave-period 10

# 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。
# 默认值60秒。
#
# 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。
#
# repl-timeout 60

################################## 安全 ###################################

# 要求客户端在处理任何命令时都要验证身份和密码。
# 这在你信不过来访者时很有用。
#
# 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证（例如：它们运行在自己的服务器上。）
# 
# 警告：因为Redis太快了，所以居心不良的人可以每秒尝试150k的密码来试图破解密码。
# 这意味着你需要一个高强度的密码，否则破解太容易了。
#
# requirepass foobared

# 命令重命名
#
# 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法做坏事了。
#
# 例如:
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令：
#
# rename-command CONFIG &amp;quot;&amp;quot;

################################### 限制 ####################################

#
# 设置最多同时连接客户端数量。
# 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。
# 特殊值&amp;quot;0&amp;quot;表示没有限制。
# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&amp;quot;达到最大用户数上限（max number of clients reached）&amp;quot;
#
# maxclients 128

# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。
#
# 如果因为删除策略问题Redis无法删除key，或者策略设置为 &amp;quot;noeviction&amp;quot;，Redis会回复需要更多内存的错误信息给命令。
# 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。
#
# 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &amp;quot;noeviction&amp;quot; 策略）的时候，这个选项还是满有用的。
#
# 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。
# 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。
#
# 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。
# （如果策略设置为&amp;quot;noeviction&amp;quot;的话就不无所谓了）
#
# maxmemory &amp;lt;bytes&amp;gt;

# 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选：
# 
# volatile-lru -&amp;gt; 根据LRU算法生成的过期时间来删除。
# allkeys-lru -&amp;gt; 根据LRU算法删除任何key。
# volatile-random -&amp;gt; 根据过期设置来随机删除key。
# allkeys-&amp;gt;random -&amp;gt; 无差别随机删。
# volatile-ttl -&amp;gt; 根据最近过期时间来删除（辅以TTL）
# noeviction -&amp;gt; 谁也不删，直接在写操作时返回错误。
# 
# 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。
#
#       这里涉及的命令：set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#
# 默认值如下：
#
# maxmemory-policy volatile-lru

# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样例做测试。
# 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。
#
# maxmemory-samples 3

############################## 纯累加模式 ###############################

# 默认情况下，Redis是异步的把数据导出到磁盘上。这种情况下，当Redis挂掉的时候，最新的数据就丢了。
# 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。
# 每次启动时Redis都会把这个文件的数据读入内存里。
#
# 注意，异步导出的数据库文件和纯累加文件可以并存（你得把上面所有&amp;quot;save&amp;quot;设置都注释掉，关掉导出机制）。
# 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。
#
# 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。

appendonly no

# 纯累加文件名字（默认：&amp;quot;appendonly.aof&amp;quot;）
# appendfilename appendonly.aof

# fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。
# 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。
#
# Redis支持三种不同的模式：
#
# no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。
# always：每次写操作都立刻写入到aof文件。慢，但是最安全。
# everysec：每秒写一次。折衷方案。
#
# 默认的 &amp;quot;everysec&amp;quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。
# 如果你真的理解了这个意味着什么，那么设置&amp;quot;no&amp;quot;可以获得更好的性能表现（如果丢数据的话，则只能拿到一个不是很新的快照）；
# 或者相反的，你选择 &amp;quot;always&amp;quot; 来牺牲速度确保数据安全、完整。
#
# 如果拿不准，就用 &amp;quot;everysec&amp;quot;

# appendfsync always
appendfsync everysec
# appendfsync no

# 如果AOF的同步策略设置成 &amp;quot;always&amp;quot; 或者 &amp;quot;everysec&amp;quot;，那么后台的存储进程（后台存储或写入AOF日志）会产生很多磁盘I/O开销。
# 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。
# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。
#
# 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。
# 
# 这就意味着如果有子进程在进行保存操作，那么Redis就处于&amp;quot;不可同步&amp;quot;的状态。
# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）
# 
# 如果你有延迟的问题那就把这个设为 &amp;quot;yes&amp;quot;，否则就保持 &amp;quot;no&amp;quot;，这是保存持久数据的最安全的方式。
no-appendfsync-on-rewrite no

# 自动重写AOF文件
#
# 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。
# 
# 工作原理：Redis记住上次重写时AOF日志的大小（或者重启后没有写操作的话，那就直接用此时的AOF文件），
#           基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。
#
# 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。
#
# 指定百分比为0会禁用AOF自动重写特性。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

################################## 慢查询日志 ###################################

# Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。
# 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间（这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景）
# 
# 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。
# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。
#
# 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。
slowlog-log-slower-than 10000

# 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。（译者注：日志居然是在内存里的Orz）
slowlog-max-len 128

################################ 虚拟内存 ###############################

### 警告！虚拟内存在Redis 2.4是反对的。
### 非常不鼓励使用虚拟内存！！

# 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。
# 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。
#
# 要使用虚拟内存，只要把 &amp;quot;vm-enabled&amp;quot; 设置为 &amp;quot;yes&amp;quot;，并根据需要设置下面三个虚拟内存参数就可以了。

vm-enabled no
# vm-enabled yes

# 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。
#
# 最好的保存交换文件（被随机访问）的介质是固态硬盘（SSD）。
#
# *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。
# 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。
vm-swap-file /tmp/redis.swap

# &amp;quot;vm-max-memory&amp;quot; 配置虚拟内存可用的最大内存容量。
# 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。
#
# &amp;quot;vm-max-memory&amp;quot; 设置为0表示系统会用掉所有可用内存。
# 这默认值不咋地，只是把你能用的内存全用掉了，留点余量会更好。
# 例如，设置为剩余内存的60%-80%。
vm-max-memory 0

# Redis交换文件是分成多个数据页的。
# 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。
# 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。
# 如果数据页太小，那用于存储的交换空间就会更少（假定你设置相同的数据页数量）
#
# 如果你使用很多小对象，建议分页尺寸为64或32个字节。
# 如果你使用很多大对象，那就用大一些的尺寸。
# 如果不确定，那就用默认值 :)
vm-page-size 32

# 交换文件里数据页总数。
# 根据内存中分页表（已用/未用的数据页分布情况），磁盘上每8个数据页会消耗内存里1个字节。
#
# 交换区容量 = vm-page-size * vm-pages
#
# 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。
#
# 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。
vm-pages 134217728

# 同时可运行的虚拟内存I/O线程数。
# 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。
# 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。
#
# 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。
vm-max-threads 4

############################### 高级配置 ###############################

# 当有大量数据时，适合用哈希编码（需要更多的内存），元素数量上限不能超过给定限制。
# 你可以通过下面的选项来设定这些限制：
hash-max-zipmap-entries 512
hash-max-zipmap-value 64

# 与哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。
# 这种方式只有在符合下面限制的时候才可以用：
list-max-ziplist-entries 512
list-max-ziplist-value 64

# 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。
# 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。
set-max-intset-entries 512

# 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。
# 这种编码只适合长度和元素都符合下面限制的有序序列：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。
# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；
# 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。
# 
# 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。
#
# 建议：
# 如果你对延迟比较在意的话就用 &amp;quot;activerehashing no&amp;quot;，每个请求延迟2毫秒不太好嘛。
# 如果你不太在意延迟而希望尽快释放内存的话就设置 &amp;quot;activerehashing yes&amp;quot;。
activerehashing yes

################################## 包含 ###################################

# 包含一个或多个其他配置文件。
# 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。
# 包含文件特性允许你引人其他配置文件，所以好好利用吧。
#
# include /path/to/local.conf
# include /path/to/other.conf
&lt;/code&gt;&lt;/pre&gt;
">Redis的redis.conf中文版（基于2.4）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/the-difference-of-HashSet-LinkedHashSet-TreeSet/"" data-c="
          &lt;p&gt;HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；&lt;br&gt;
LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；&lt;br&gt;
TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;用例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.HashSet;  
import java.util.LinkedHashSet;  
import java.util.TreeSet;  
  
/**  
 * @description 几个set的比较  
 *    HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；  
 *    LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；  
 *    TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。  
 * @author gbwl_cgl  
 *  
 */  
public class SetDemo {  
  
    public static void main(String[] args) {  
  
        HashSet&amp;lt;String&amp;gt; hs = new HashSet&amp;lt;String&amp;gt;();  
        hs.add(&amp;quot;B&amp;quot;);  
        hs.add(&amp;quot;A&amp;quot;);  
        hs.add(&amp;quot;D&amp;quot;);  
        hs.add(&amp;quot;E&amp;quot;);  
        hs.add(&amp;quot;C&amp;quot;);  
        hs.add(&amp;quot;F&amp;quot;);  
        System.out.println(&amp;quot;HashSet 顺序:\n&amp;quot;+hs);  
          
        LinkedHashSet&amp;lt;String&amp;gt; lhs = new LinkedHashSet&amp;lt;String&amp;gt;();  
        lhs.add(&amp;quot;B&amp;quot;);  
        lhs.add(&amp;quot;A&amp;quot;);  
        lhs.add(&amp;quot;D&amp;quot;);  
        lhs.add(&amp;quot;E&amp;quot;);  
        lhs.add(&amp;quot;C&amp;quot;);  
        lhs.add(&amp;quot;F&amp;quot;);  
        System.out.println(&amp;quot;LinkedHashSet 顺序:\n&amp;quot;+lhs);  
          
        TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;String&amp;gt;();  
        ts.add(&amp;quot;B&amp;quot;);  
        ts.add(&amp;quot;A&amp;quot;);  
        ts.add(&amp;quot;D&amp;quot;);  
        ts.add(&amp;quot;E&amp;quot;);  
        ts.add(&amp;quot;C&amp;quot;);  
        ts.add(&amp;quot;F&amp;quot;);  
        System.out.println(&amp;quot;TreeSet 顺序:\n&amp;quot;+ts);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出效果：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HashSet 顺序:&lt;br&gt;
[D, E, F, A, B, C]&lt;br&gt;
LinkedHashSet 顺序:&lt;br&gt;
[B, A, D, E, C, F]&lt;br&gt;
TreeSet 顺序:&lt;br&gt;
[A, B, C, D, E, F]&lt;/p&gt;
&lt;/blockquote&gt;
">HashSet、LinkedHashSet、TreeSet使用区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/java-collection-transformation/"" data-c="
          &lt;p&gt;代码演示List&amp;lt;--&amp;gt;数组、List&amp;lt;--&amp;gt;Set、数组&amp;lt;--&amp;gt;Set、Map将键转化为Set、Map将值转化为Set、Map将值转化为List等集合常用转化操作。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @Title: CollectionConversion.java&amp;lt;br&amp;gt;
 * @package: com.imarkofu.demo&amp;lt;br&amp;gt;
 * @Description:集合转换&amp;lt;br&amp;gt;
 * @author gbwl&amp;lt;br&amp;gt;
 * @date 2015年5月11日 下午3:57:01&amp;lt;br&amp;gt;
 */
public class CollectionConversion {

	public static void main(String[] args) {
		// List--&amp;gt;数组
		List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
		list.add(&amp;quot;蹇伟&amp;quot;);
		list.add(&amp;quot;Jerval&amp;quot;);
		list.add(&amp;quot;杰威&amp;quot;);
		Object[] objects = list.toArray();// 返回Object数组
		System.out.println(&amp;quot;objects:&amp;quot; + Arrays.toString(objects));
		String[] strings1 = new String[list.size()];
		list.toArray(strings1);// 将转化后的数组放入已经创建好的对象中
		System.out.println(&amp;quot;strings1:&amp;quot; + Arrays.toString(strings1));
		String[] strings2 = list.toArray(new String[0]);// 将转化后的数组赋给新对象
		System.out.println(&amp;quot;strings2:&amp;quot; + Arrays.toString(strings2));
		// 数组--&amp;gt;List
		String[] ss = { &amp;quot;JJ&amp;quot;, &amp;quot;KK&amp;quot; };
		List&amp;lt;String&amp;gt; list1 = Arrays.asList(ss);
		List&amp;lt;String&amp;gt; list2 = Arrays.asList(&amp;quot;AAA&amp;quot;, &amp;quot;BBB&amp;quot;);
		System.out.println(list1);
		System.out.println(list2);
		// List--&amp;gt;Set
		List&amp;lt;String&amp;gt; list3 = new ArrayList&amp;lt;String&amp;gt;(new HashSet&amp;lt;String&amp;gt;());
		// Set--&amp;gt;List
		Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;(new ArrayList&amp;lt;String&amp;gt;());
		// 数组--&amp;gt;Set
		String[] strs = { &amp;quot;AA&amp;quot;, &amp;quot;BB&amp;quot; };
		Set&amp;lt;String&amp;gt; set2 = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(strs));
		System.out.println(set2);
		// Set--&amp;gt;数组
		Set&amp;lt;String&amp;gt; set3 = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&amp;quot;PP&amp;quot;, &amp;quot;OO&amp;quot;));
		String[] strSet = new String[set3.size()];
		set3.toArray(strSet);
		System.out.println(Arrays.toString(strSet));
		// Map操作
		Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
		map.put(&amp;quot;YYY&amp;quot;, &amp;quot;UUU&amp;quot;);
		map.put(&amp;quot;RRR&amp;quot;, &amp;quot;TTT&amp;quot;);
		// 将键转化为Set
		Set&amp;lt;String&amp;gt; mapKeySet = map.keySet();
		// 将值转化为Set
		Set&amp;lt;String&amp;gt; mapValuesSet = new HashSet&amp;lt;String&amp;gt;(map.values());
		// 将值转化为List
		List&amp;lt;String&amp;gt; mapValuesList = new ArrayList&amp;lt;String&amp;gt;(map.values());
	}
}
&lt;/code&gt;&lt;/pre&gt;
">Java集合间的相互转换</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imarkofu.github.io/post/curl-command-usage-guide/"" data-c="
          &lt;p&gt;我一向以为，curl只是一个编程用的函数库。&lt;br&gt;
最近才发现，这个命令本身，就是一个无比有用的网站开发工具，请看我整理的它的用法。&lt;br&gt;
curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。&lt;/p&gt;
&lt;h1 id=&#34;-more-curl的选项功能&#34;&gt;&lt;!--more--&gt;&lt;br&gt;
curl的选项功能&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;不带任何参数时curl将返回指定url中的数据并打印在屏幕上
  -u 使用用户名和密码登陆。如curl -uname:passwd URL
  -b/--cookie  &amp;lt;name=data&amp;gt;   向服务器提交cookie，若无=则name视为文件名，例如：curl -b cookie.txt www.imarkofu.com
  -o out  将指定curl返回保存为out文件，内容从html/jpg到各种MIME类型文件。如curl -o page.html URL
  -d &amp;lt;key=value&amp;gt;  向服务器POST表单数据 例如：curl -d &amp;quot;pageSize=8&amp;amp;pageNo=5&amp;quot; http://www.imarkofu.com/load.do
  -A/--user-agent  &amp;lt;ua&amp;gt;  指定发送请求的用户代理，例如：curl -A My-Agent/1.0.0 www.imarkofu.com
  -x  ip:port 指定使用的http代理，例如：curl -x 192.168.1.1:8080 www.imarkofu.com
  -D head.txt  将服务器的返回的header保存为文件，头部的cookie也可被保存，例如：curl -D header.txt www.imarkofu.com
  -L 当页面有跳转的时候，输出跳转到的页面
  -I  header信息  当有跳转时，可以通过 curl -L -I URL|grep Location 来确定跳转到的新url地址
  -c &amp;lt;file&amp;gt; 保存服务器的cookie文件
  -e url  设置引用头的值
  -T localfile  向服务器PUT文件 例如：curl -T xxx.doc  www.imarkofu.com/upload.do
  -F &amp;lt;key=value&amp;gt; 向服务器POST表单，例如：curl -F &amp;quot;web=@index.html;type=text/html&amp;quot; url.com
  -E cert.pem  指定本地证书
  -H &amp;lt;header:value&amp;gt;  为HTTP请求设置任意header及值。如curl -H &amp;quot;Connection:keep-alive&amp;quot; http://www.imarkofu.com
  -X/--request method 用户定义的HTTP请求方法名如 curl -X GET www.imarkofu.com
  -compressed 采用压缩方式接收返回数据
  -connect-timeout `&amp;lt;`s`&amp;gt;` 设置超时时间
   -v 详细输出，包含请求和响应的首部
  --retry num
  --retry timeo 指定重试的次数和间隔
  --tcp-nodelay 打开TCP_NODELAY选项  不进行捎带确认
  -O  按服务器上的名称保存下载的文件
  -r/--range  from-to 下载指定range内的数据
  -C 在保存文件时进行续传
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;curl的常见使用&#34;&gt;curl的常见使用&lt;/h1&gt;
&lt;h2 id=&#34;curl查看web站点rt&#34;&gt;curl查看web站点rt&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -o /dev/null -s -w %{time_namelookup}::%{time_connect}::%{time_starttransfer}::%{time_total}::%{speed_download}&amp;quot;\n&amp;quot; &amp;quot;http://www.taobao.com&amp;quot;  
0.014::0.015::0.018::0.019::1516256.00
  -s：去掉所有状态
  -w：按照后面的格式写出rt
time_namelookup：DNS 解析域名[www.taobao.com]的时间 
time_commect：client和server端建立TCP 连接的时间
time_starttransfer：从client发出请求；到web的server 响应第一个字节的时间
time_total：client发出请求；到web的server发送会所有的相应数据的时间
speed_download：下载速度  单位 byte/s

0.014: DNS 服务器解析www.taobao.com 的时间单位是s
0.015: client发出请求到server建立TCP的时间，里面包括DNS解析的时间  
0.018: client发出请求到server响应发出第一个字节开始的时间，包括前面的2个时间  
0.019: client发出请求到server把响应的数据全部发送给client,并关闭connect的时间  
1516256.00 ：下载数据的速度  
  
1. 建立TCP连接到server返回client第一个字节的时间：0.018s - 0.015s = 0.003s  
2. server把响应数据发送给client的时间：0.019s - 0.018 = 0.01s  
&lt;/code&gt;&lt;/pre&gt;
">curl命令使用指南</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;h2 id=\&#34;下载\&#34;&gt;下载&lt;/h2&gt;\n&lt;p&gt;官网[ https://dev.mysql.com/downloads/mysql/5.7.html ]下载mysql5.7.34，选择zip；&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imarkofu.github.io/post-images/1624116256763.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imarkofu.github.io/post-images/1624116526129.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;解压配置\&#34;&gt;解压配置&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;解压到[C:\\Program Files\\mysql]目录&lt;/li&gt;\n&lt;li&gt;建立data文件夹&lt;/li&gt;\n&lt;li&gt;新建my.ini文件&lt;br&gt;\n&lt;img src=\&#34;https://imarkofu.github.io/post-images/1624116734018.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\nmy.ini文件内容如下&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[mysqld]\n#设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir=C:\\\\Program Files\\\\mysql\\\\mysql-5.7.34-winx64\ndatadir=C:\\\\Program Files\\\\mysql\\\\mysql-5.7.34-winx64\\\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\ninnodb_flush_method=normal\n \n[client]\n#设置3306端口\nport = 3306\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装并初始化\&#34;&gt;安装并初始化&lt;/h2&gt;\n&lt;p&gt;管理员身份打开cmd，进入[C:\\Program Files\\mysql\\mysql-5.7.34-winx64\\bin]目录；执行以下指令&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;mysqld --install，生成mysql实例，打开服务：&lt;br&gt;\n执行如下命令：net start MySQL&lt;br&gt;\n或到电脑服务列表中找到MySQL服务，并启动&lt;br&gt;\n&lt;img src=\&#34;https://imarkofu.github.io/post-images/1624117086839.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;mysqld --initialize --user=mysql --console，此时终端显示随机密码，需要记住，后面会使用到：&lt;br&gt;\n&lt;img src=\&#34;https://imarkofu.github.io/post-images/1624117374482.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;修改mysql密码：输入命令行mysql -uroot -p，输入临时密码即可登录数据库成功&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;\nflush privileges;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-5-7-34-winx64-install&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;下载\&#34;&gt;下载&lt;/h2&gt;\n&lt;p&gt;官网[ https://dev.mysql.com/downloads/mysql/5.7.html ]下载mysql5.7.34，选择zip；&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql-5.7.34-winx64安装&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;}],&#34;date&#34;:&#34;2021-06-19 23:17:48&#34;,&#34;dateFormat&#34;:&#34;2021-06-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-5-7-34-winx64-install/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:79000,&#34;words&#34;:303,&#34;minutes&#34;:2},&#34;description&#34;:&#34;下载\n官网[ https://dev.mysql.com/downloads/mysql/5.7.html ]下载mysql5.7.34，选择zip；\n\n\n\n解压配置\n\n解压到[C:\\Program Files\\mysql]目录\n建立dat...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BD%BD\&#34;&gt;下载&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%8E%8B%E9%85%8D%E7%BD%AE\&#34;&gt;解压配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96\&#34;&gt;安装并初始化&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;debian操作系统，apt-get update 报错，采用更换源的方式解决问题。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;E: Release file for http://deb.debian.org/debian/dists/buster-updates/InRelease is not valid yet (invalid for another 7h 27min 25s). Updates for this repository will not be applied.\nE: Release file for http://security.debian.org/debian-security/dists/buster/updates/InRelease is not valid yet (invalid for another 1h 35min 41s). Updates for this repository will not be applied.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;解决\&#34;&gt;解决&lt;/h2&gt;\n&lt;p&gt;尝试更换源来解决，将 sources.list 文件复制到 /etc/apt/sources.list 下，更新即可。&lt;/p&gt;\n&lt;h3 id=\&#34;阿里云源\&#34;&gt;阿里云源&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib\ndeb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib\ndeb http://mirrors.aliyun.com/debian-security buster/updates main\ndeb-src http://mirrors.aliyun.com/debian-security buster/updates main\ndeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib\ndeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib\ndeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib\ndeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;清华源\&#34;&gt;清华源&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;docker示例\&#34;&gt;Docker示例&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib&amp;quot; &amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb http://mirrors.aliyun.com/debian-security buster/updates main&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian-security buster/updates main&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \\\n    echo &amp;quot;deb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib&amp;quot; &amp;gt;&amp;gt;/etc/apt/sources.list\n\nRUN apt-get clean &amp;amp;&amp;amp; \\\n    apt-get update &amp;amp;&amp;amp; \\\n    apt-get install -y --no-install-recommends curl procps telnet net-tools &amp;amp;&amp;amp; \\\n    rm -rf /var/lib/apt/lists/*\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;注意\&#34;&gt;注意&lt;/h2&gt;\n&lt;p&gt;不管是阿里云的源还是清华的源，http和https均可以，自行斟酌即可；&lt;br&gt;\n如果遇到无法拉取 https 源的情况，请先使用 http 源并安装：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;apt install apt-transport-https ca-certificates\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;debian-switch-source&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;debian操作系统，apt-get update 报错，采用更换源的方式解决问题。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;E: Release file for http://deb.debian.org/debian/dists/buster-updates/InRelease is not valid yet (invalid for another 7h 27min 25s). Updates for this repository will not be applied.\nE: Release file for http://security.debian.org/debian-security/dists/buster/updates/InRelease is not valid yet (invalid for another 1h 35min 41s). Updates for this repository will not be applied.\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;Debian 官方源换为国内的源的操作方法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;linux&#34;,&#34;slug&#34;:&#34;uP-eMausMK8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/uP-eMausMK8/&#34;}],&#34;date&#34;:&#34;2021-06-09 15:12:24&#34;,&#34;dateFormat&#34;:&#34;2021-06-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/debian-switch-source/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:218000,&#34;words&#34;:640,&#34;minutes&#34;:4},&#34;description&#34;:&#34;描述\ndebian操作系统，apt-get update 报错，采用更换源的方式解决问题。\nE: Release file for http://deb.debian.org/debian/dists/buster-updates/InRe...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%8F%E8%BF%B0\&#34;&gt;描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3\&#34;&gt;解决&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%BF%E9%87%8C%E4%BA%91%E6%BA%90\&#34;&gt;阿里云源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B8%85%E5%8D%8E%E6%BA%90\&#34;&gt;清华源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker%E7%A4%BA%E4%BE%8B\&#34;&gt;Docker示例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F\&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;目前应用开发前后端分离是大趋势，故而前后端部署在不同的两个域也是大概率事件，那么势必需要解决跨域请求的问题。&lt;/p&gt;\n&lt;p&gt;本文描述spring-boot项目中如何解决请求跨域的三种解决方案，以及升级spring-boot 2.4后的跨域问题。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;解决\&#34;&gt;解决&lt;/h2&gt;\n&lt;h3 id=\&#34;方案一\&#34;&gt;方案一&lt;/h3&gt;\n&lt;p&gt;通过实现WebMvcConfigurer接口的addCorsMappings方法解决跨域问题。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Configuration\npublic class WebMvcConfiguration implements WebMvcConfigurer {\n\n\t@Override\n    public void addCorsMappings(CorsRegistry registry) {\n        // 所有的当前站点的请求地址，都支持跨域访问。\n        registry.addMapping(&amp;quot;/**&amp;quot;)\n                // 所有的外部域都可跨域访问\n                .allowedOrigins(&amp;quot;*&amp;quot;)\n                // 是否支持跨域用户凭证\n                .allowCredentials(true)\n                // 当前站点支持的跨域请求类型是什么\n                .allowedMethods(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;PUT&amp;quot;, &amp;quot;DELETE&amp;quot;)\n                .maxAge(3600);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;方案二\&#34;&gt;方案二&lt;/h3&gt;\n&lt;p&gt;使用@CrossOrigin注解实现跨域&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@RestController\n@CrossOrigin(origins = &amp;quot;*&amp;quot;, maxAge = 3600)\npublic class TestController {\n    \n    @GetMapping(&amp;quot;/test&amp;quot;)\n    public ApiResult&amp;lt;String&amp;gt; test() {\n        return null;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;方案三\&#34;&gt;方案三&lt;/h3&gt;\n&lt;p&gt;使用Filter实现跨域&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t@ConditionalOnProperty(name = &amp;quot;manage.api.cors&amp;quot;, havingValue = &amp;quot;true&amp;quot;)\n    @Bean\n    public CorsFilter corsFilter() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.addAllowedOrigin(&amp;quot;*&amp;quot;);\n        config.addAllowedHeader(&amp;quot;*&amp;quot;);\n        config.addAllowedMethod(&amp;quot;*&amp;quot;);\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&amp;quot;/**&amp;quot;, config);\n        return new CorsFilter(source);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;注意\&#34;&gt;注意&lt;/h2&gt;\n&lt;p&gt;spring-boot升级到2.4版本以后，使用如下方案时会抛一下异常&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value &amp;quot;*&amp;quot; since that cannot be set on the &amp;quot;Access-Control-Allow-Origin&amp;quot; response header. To allow credentials to a set of origins, list them explicitly or consider using &amp;quot;allowedOriginPatterns&amp;quot; instead.\n\n// 解决方法提示内容中也有香惜的说明\n// 当allowCredentials设置为&#39;true&#39;时，allowedOrigins不能包含特殊值&#39;*&#39;\n// 可以考虑使用allowedOriginPatterns代替\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-boot-allowed-origins&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;目前应用开发前后端分离是大趋势，故而前后端部署在不同的两个域也是大概率事件，那么势必需要解决跨域请求的问题。&lt;/p&gt;\n&lt;p&gt;本文描述spring-boot项目中如何解决请求跨域的三种解决方案，以及升级spring-boot 2.4后的跨域问题。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;spring boot跨域问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;spring&#34;,&#34;slug&#34;:&#34;aUuOA0b3r&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/aUuOA0b3r/&#34;}],&#34;date&#34;:&#34;2021-06-03 20:12:24&#34;,&#34;dateFormat&#34;:&#34;2021-06-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/spring-boot-allowed-origins/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:111000,&#34;words&#34;:409,&#34;minutes&#34;:2},&#34;description&#34;:&#34;描述\n目前应用开发前后端分离是大趋势，故而前后端部署在不同的两个域也是大概率事件，那么势必需要解决跨域请求的问题。\n本文描述spring-boot项目中如何解决请求跨域的三种解决方案，以及升级spring-boot 2.4后的跨域问题。\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%8F%E8%BF%B0\&#34;&gt;描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3\&#34;&gt;解决&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%88%E4%B8%80\&#34;&gt;方案一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%88%E4%BA%8C\&#34;&gt;方案二&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%88%E4%B8%89\&#34;&gt;方案三&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F\&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;maven编译项目提示&lt;br&gt;\n程序包com.sun.image.codec.jpeg不存在&lt;br&gt;\n然后这个类位于：jre/lib/rt.jar&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;解决\&#34;&gt;解决&lt;/h2&gt;\n&lt;h3 id=\&#34;方案一\&#34;&gt;方案一&lt;/h3&gt;\n&lt;p&gt;java_home下面的lib/dt.jar中没有这个文件，导致编译失败。&lt;br&gt;\n通过配置maven-compiler-plugin插件可以解决此问题。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;&amp;lt;build&amp;gt;\n    &amp;lt;plugins&amp;gt;\n        &amp;lt;plugin&amp;gt;\n            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;\n            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;\n            &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;\n            &amp;lt;configuration&amp;gt;\n                &amp;lt;source&amp;gt;${maven.compiler.source}&amp;lt;/source&amp;gt;\n                &amp;lt;target&amp;gt;${maven.compiler.target}&amp;lt;/target&amp;gt;\n                &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;\n                &amp;lt;compilerArguments&amp;gt;\n                    &amp;lt;verbose /&amp;gt;\n                    &amp;lt;bootclasspath&amp;gt;${java.home}/lib/rt.jar;${java.home}/lib/jce.jar&amp;lt;/bootclasspath&amp;gt;\n                &amp;lt;/compilerArguments&amp;gt;\n            &amp;lt;/configuration&amp;gt;\n        &amp;lt;/plugin&amp;gt;\n    &amp;lt;/plugins&amp;gt;\n&amp;lt;/build&amp;gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;缺陷：在windows下面用&#39;;&#39;分隔，linux下面用&#39;:&#39;分隔。&lt;/p&gt;\n&lt;h3 id=\&#34;方案二\&#34;&gt;方案二&lt;/h3&gt;\n&lt;p&gt;更换API&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;JPEGImageEncoder en = JPEGCodec.createJPEGEncoder(os);\nen.encode(targetImage);\n\n// 更换为\nImageIO.write(targetImage, &amp;quot;jpg&amp;quot;, os);\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;maven-compiler-image-api-not-exist&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;maven编译项目提示&lt;br&gt;\n程序包com.sun.image.codec.jpeg不存在&lt;br&gt;\n然后这个类位于：jre/lib/rt.jar&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;maven项目编译：程序包com.sun.image.codec.jpeg不存在&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;maven&#34;,&#34;slug&#34;:&#34;rgfrKmU1i-l&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/rgfrKmU1i-l/&#34;}],&#34;date&#34;:&#34;2021-06-03 12:12:24&#34;,&#34;dateFormat&#34;:&#34;2021-06-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/maven-compiler-image-api-not-exist/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:66000,&#34;words&#34;:213,&#34;minutes&#34;:2},&#34;description&#34;:&#34;描述\nmaven编译项目提示\n程序包com.sun.image.codec.jpeg不存在\n然后这个类位于：jre/lib/rt.jar\n\n解决\n方案一\njava_home下面的lib/dt.jar中没有这个文件，导致编译失败。\n通过配置m...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%8F%E8%BF%B0\&#34;&gt;描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3\&#34;&gt;解决&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%88%E4%B8%80\&#34;&gt;方案一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%88%E4%BA%8C\&#34;&gt;方案二&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;从github克隆一个项目下发出现了错误：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;cglong@cglong MINGW64 /c/Tools/workspace/idea/open\n$ git clone git@github.com:imarkofu/shenyu.git\nCloning into &#39;shenyu&#39;...\nWarning: Permanently added the RSA host key for IP address &#39;52.192.72.89&#39; to the list of known hosts.\nremote: Enumerating objects: 53479, done.\nremote: Counting objects: 100% (15170/15170), done.\nremote: Compressing objects: 100% (4534/4534), done.\nremote: Total 53479 (delta 4593), reused 14765 (delta 4365), pack-reused 38309\nReceiving objects: 100% (53479/53479), 20.72 MiB | 128.00 KiB/s, done.\nResolving deltas: 100% (17773/17773), done.\nerror: unable to create file shenyu-spring-boot-starter/shenyu-spring-boot-starter-sync-data-center/shenyu-spring-boot-starter-sync-data-websocket/src/main/java/org/apache/shenyu/springboot/starter/sync/data/websocket/WebsocketSyncDataConfiguration.java: Filename too long\nerror: unable to create file shenyu-spring-boot-starter/shenyu-spring-boot-starter-sync-data-center/shenyu-spring-boot-starter-sync-data-websocket/src/test/java/org/apache/shenyu/springboot/starter/sync/data/websocket/WebsocketSyncDataConfigurationTest.java: Filename too long\nChecking out files: 100% (1439/1439), done.\nfatal: unable to checkout working tree\nwarning: Clone succeeded, but checkout failed.\nYou can inspect what was checked out with &#39;git status&#39;\nand retry the checkout with &#39;git checkout -f HEAD&#39;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;git可以创建4096长度的路径，然而Windows 默认不支持文件名或目录名长于260个字符，所以Git的Windows客户端默认是禁用长名称支持的。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;解决\&#34;&gt;解决&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;git config --global core.longpaths true\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;git-bash-filename-too-long&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;描述\&#34;&gt;描述&lt;/h2&gt;\n&lt;p&gt;从github克隆一个项目下发出现了错误：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;cglong@cglong MINGW64 /c/Tools/workspace/idea/open\n$ git clone git@github.com:imarkofu/shenyu.git\nCloning into &#39;shenyu&#39;...\nWarning: Permanently added the RSA host key for IP address &#39;52.192.72.89&#39; to the list of known hosts.\nremote: Enumerating objects: 53479, done.\nremote: Counting objects: 100% (15170/15170), done.\nremote: Compressing objects: 100% (4534/4534), done.\nremote: Total 53479 (delta 4593), reused 14765 (delta 4365), pack-reused 38309\nReceiving objects: 100% (53479/53479), 20.72 MiB | 128.00 KiB/s, done.\nResolving deltas: 100% (17773/17773), done.\nerror: unable to create file shenyu-spring-boot-starter/shenyu-spring-boot-starter-sync-data-center/shenyu-spring-boot-starter-sync-data-websocket/src/main/java/org/apache/shenyu/springboot/starter/sync/data/websocket/WebsocketSyncDataConfiguration.java: Filename too long\nerror: unable to create file shenyu-spring-boot-starter/shenyu-spring-boot-starter-sync-data-center/shenyu-spring-boot-starter-sync-data-websocket/src/test/java/org/apache/shenyu/springboot/starter/sync/data/websocket/WebsocketSyncDataConfigurationTest.java: Filename too long\nChecking out files: 100% (1439/1439), done.\nfatal: unable to checkout working tree\nwarning: Clone succeeded, but checkout failed.\nYou can inspect what was checked out with &#39;git status&#39;\nand retry the checkout with &#39;git checkout -f HEAD&#39;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;git可以创建4096长度的路径，然而Windows 默认不支持文件名或目录名长于260个字符，所以Git的Windows客户端默认是禁用长名称支持的。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;git bash下的Filename too long&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;git&#34;,&#34;slug&#34;:&#34;smEw4gxeP&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/smEw4gxeP/&#34;}],&#34;date&#34;:&#34;2021-06-02 19:12:24&#34;,&#34;dateFormat&#34;:&#34;2021-06-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/git-bash-filename-too-long/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:93000,&#34;words&#34;:279,&#34;minutes&#34;:2},&#34;description&#34;:&#34;描述\n从github克隆一个项目下发出现了错误：\ncglong@cglong MINGW64 /c/Tools/workspace/idea/open\n$ git clone git@github.com:imarkofu/shenyu.g...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%8F%E8%BF%B0\&#34;&gt;描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3\&#34;&gt;解决&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;准备编译环境&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;yum install zlib-devel bzip2-devel openssl-devel ncurses-devel xz gcc-c++ gcc libffi-devel -y\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;下载并解压&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz\ntar xf Python-3.7.3.tar.xz -C /usr/local/src/\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;编译安装&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;cd /usr/local/src/Python-3.7.3\n./configure --prefix=/usr/local/python3 --with-ssl --enable-optimizations\nmake -j 4 &amp;amp;&amp;amp; make install\n\n最终提示如下，表示pip-9.0.1与setuptools-28.8.0同时安装成功\nif test &amp;quot;x&amp;quot; != &amp;quot;x&amp;quot; ; then \\\n                rm -f /usr/local/python3/bin/python3-32; \\\n                (cd /usr/local/python3/bin; ln -s python3.7-32 python3-32) \\\n        fi\nrm -f /usr/local/python3/share/man/man1/python3.1\n(cd /usr/local/python3/share/man/man1; ln -s python3.7.1 python3.1)\nif test &amp;quot;xupgrade&amp;quot; != &amp;quot;xno&amp;quot;  ; then \\\n                case upgrade in \\\n                        upgrade) ensurepip=&amp;quot;--upgrade&amp;quot; ;; \\\n                        install|*) ensurepip=&amp;quot;&amp;quot; ;; \\\n                esac; \\\n                 ./python -E -m ensurepip \\\n                        $ensurepip --root=/ ; \\\n        fi\nLooking in links: /tmp/tmpnffpnbr9\nCollecting setuptools\nCollecting pip\nInstalling collected packages: setuptools, pip\nSuccessfully installed pip-19.0.3 setuptools-40.8.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;建立软连接&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;ln -s /usr/local/python3/bin/python3.7 /usr/local/bin/python3 \nln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;升级到最新的pip&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;pip3 install --upgrade pip\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;修改默认的Python&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mv /usr/bin/python /usr/bin/python_bak\nln -s /usr/local/python3/bin/python3.7 /usr/bin/python\n\n# 验证\npython -V\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;CentOS-install-python3&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;准备编译环境&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;yum install zlib-devel bzip2-devel openssl-devel ncurses-devel xz gcc-c++ gcc libffi-devel -y\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;CentOS6编译安装Python3.7&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;编译安装Python&#34;,&#34;slug&#34;:&#34;dYnxLc62K&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/dYnxLc62K/&#34;},{&#34;name&#34;:&#34;Python安装&#34;,&#34;slug&#34;:&#34;-MJ4bHnjMi&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/-MJ4bHnjMi/&#34;}],&#34;date&#34;:&#34;2019-04-03 20:21:10&#34;,&#34;dateFormat&#34;:&#34;2019-04-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/CentOS-install-python3/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:96000,&#34;words&#34;:280,&#34;minutes&#34;:2},&#34;description&#34;:&#34;准备编译环境\nyum install zlib-devel bzip2-devel openssl-devel ncurses-devel xz gcc-c++ gcc libffi-devel -y\n\n\n\n下载并解压\nwget https...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Ekho（余音）是一个免费、开源的中文语音合成软件。它目前支持粤语、普通话（国语）、广东台山话、诏安客语、藏语、雅言（中国古代通用语）和韩语（试验中），英语则通过eSpeak或Festival间接实现。Ekho支持Linux、Windows和Android平台。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;源码下载页面：&lt;a href=\&#34;https://sourceforge.net/projects/e-guidedog/files/Ekho/\&#34; title=\&#34;ekho源码下载\&#34;&gt;ekho&lt;/a&gt;.&lt;br&gt;\n项目主页：&lt;a href=\&#34;http://www.eguidedog.net/ekho.php\&#34; title=\&#34;ekho主页\&#34;&gt;ekho&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;编译安装基于CentOS 6.10&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 添加 SCL 和 EPEL 软件仓库\nyum install centos-release-scl epel-release\n\n# 安装 GCC 5 和编译 ekho 的开发库\nyum install devtoolset-6-gcc* libsndfile-devel.x86_64 pulseaudio-libs-devel.x86_64 ncurses-devel.x86_64 espeak-devel.x86_64 lame-devel.x86_64\n\n# 使用 SCL 启动 shell \nscl enable devtoolset-6 bash\n\n# 验证 GCC 版本 \n# which gcc\n# gcc --version\n\n# [可选] 设置 GCC 编译器选项\nexport CFLAGS=&#39;-O2 -g -pipe -Wall -fexceptions -fno-strict-aliasing -fstack-protector -m64 -mtune=generic -fPIC&#39;\n\n# 生成 MakeFile，编译，安装 \n./configure --prefix=/opt/app/ekho &amp;amp;&amp;amp; make -j 8 &amp;amp;&amp;amp; make install\n\n# 设置 ekho 相关环境变量 \ncat &amp;gt; /etc/profile.d/ekho_env.sh &amp;lt;&amp;lt; EOF\n#!/bin/bash\nexport PATH=\\${PATH}:/opt/app/ekho/bin\nexport EKHO_DATA_PATH=/opt/app/ekho/share/ekho-data/\nEOF\n\n# 退出 SCL shell \nexit \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;更换音频文件参考：&lt;a href=\&#34;http://cto.eguidedog.net/node/809\&#34; title=\&#34;怎样替换Ekho的语音文件\&#34;&gt;怎样替换Ekho的语音文件&lt;/a&gt;&lt;br&gt;\n制作和添加新的语音声音参考：&lt;a href=\&#34;http://www.eguidedog.net/doc/doc_make_new_voice_cn.php\&#34; title=\&#34;如何为Ekho添加新的声音\&#34;&gt;如何为Ekho添加新的声音&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;CentOS-ekho-TTS&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Ekho（余音）是一个免费、开源的中文语音合成软件。它目前支持粤语、普通话（国语）、广东台山话、诏安客语、藏语、雅言（中国古代通用语）和韩语（试验中），英语则通过eSpeak或Festival间接实现。Ekho支持Linux、Windows和Android平台。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;ekho中文TTS CentOS6编译安装&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;TTS&#34;,&#34;slug&#34;:&#34;3RN5pO-e_Q&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/3RN5pO-e_Q/&#34;},{&#34;name&#34;:&#34;中文TTS&#34;,&#34;slug&#34;:&#34;vTZWKiwV9e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/vTZWKiwV9e/&#34;},{&#34;name&#34;:&#34;ekho&#34;,&#34;slug&#34;:&#34;KklA2V1Ye3&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/KklA2V1Ye3/&#34;},{&#34;name&#34;:&#34;ekho编译安装&#34;,&#34;slug&#34;:&#34;aF7XhNQSmF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/aF7XhNQSmF/&#34;}],&#34;date&#34;:&#34;2019-04-02 20:21:10&#34;,&#34;dateFormat&#34;:&#34;2019-04-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/CentOS-ekho-TTS/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:80000,&#34;words&#34;:295,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Ekho（余音）是一个免费、开源的中文语音合成软件。它目前支持粤语、普通话（国语）、广东台山话、诏安客语、藏语、雅言（中国古代通用语）和韩语（试验中），英语则通过eSpeak或Festival间接实现。Ekho支持Linux、Windows...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:6000,&#34;words&#34;:31,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n👨‍💻 博主是谁\n⛹ 兴趣爱好\n📬 联系我呀\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;\n&lt;p&gt;动态规划常常适用于&lt;strong&gt;有重叠子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构性质&lt;/strong&gt;的问题，动态规划方法所耗时间往往远少于朴素解法。&lt;/p&gt;\n&lt;p&gt;动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。&lt;/p&gt;\n&lt;p&gt;通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-适用情况\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n适用情况&lt;/h1&gt;\n&lt;p&gt;**最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。&lt;br&gt;\n**无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。&lt;br&gt;\n**子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。&lt;/p&gt;\n&lt;h1 id=\&#34;实例\&#34;&gt;实例&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;求解的关键：第一步找到问题的“状态”， 第二步找到“状态转移方程”&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;示例一\&#34;&gt;示例一&lt;/h2&gt;\n&lt;p&gt;一个序列有N个数：A[1],A[2],…,A[N]，求出最长上升子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)&lt;/p&gt;\n&lt;p&gt;示例：5，3，4，8，6，7&lt;br&gt;\n**前1个数的LIS长度d(1)=1(序列：5)&lt;br&gt;\n**前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)&lt;br&gt;\n**前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)&lt;br&gt;\n**前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)&lt;/p&gt;\n&lt;p&gt;状态转移方程&lt;br&gt;\ndp[i]=max{dp[j]}+1，j=[0,i-1]且a[j]&amp;lt;a[i]&lt;br&gt;\n即为：到第i个元素的最长上升子序列=第0到i-1的元素的最长上升子序列+1&lt;br&gt;\n时间复杂度=O(n^2)&lt;/p&gt;\n&lt;p&gt;这个问题还有另一种更优化的解法，时间复杂度为O(nlog(n))&lt;br&gt;\n参考：https://leetcode.com/problems/longest-increasing-subsequence/&lt;/p&gt;\n&lt;h2 id=\&#34;示例二\&#34;&gt;示例二&lt;/h2&gt;\n&lt;p&gt;平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始走到右下角， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。&lt;/p&gt;\n&lt;p&gt;这个状态转移方程应该会更好理解&lt;br&gt;\ndp[i][j]=A[i][j]+max(dp[i+1][j], dp[i][j+1])，当然这里没有将边界问题考虑进来，实际编程中需要注意。&lt;/p&gt;\n&lt;p&gt;即为：从第i,j位置到走到左下角能收集的最大苹果数量=当前格子内苹果数量+向右走或向下走的两种方式的最大值&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-dynamic-programming&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;\n&lt;p&gt;动态规划常常适用于&lt;strong&gt;有重叠子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构性质&lt;/strong&gt;的问题，动态规划方法所耗时间往往远少于朴素解法。&lt;/p&gt;\n&lt;p&gt;动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。&lt;/p&gt;\n&lt;p&gt;通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-动态规划&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;动态规划&#34;,&#34;slug&#34;:&#34;Tj5Ev9UDze&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Tj5Ev9UDze/&#34;}],&#34;date&#34;:&#34;2019-01-14 23:03:27&#34;,&#34;dateFormat&#34;:&#34;2019-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-dynamic-programming/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:223000,&#34;words&#34;:1023,&#34;minutes&#34;:4},&#34;description&#34;:&#34;动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n动态规划常常适用于有重叠子问题和最优子结构性质的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n适用情况&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E4%BE%8B\&#34;&gt;实例&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B%E4%B8%80\&#34;&gt;示例一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B%E4%BA%8C\&#34;&gt;示例二&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。&lt;/p&gt;\n&lt;p&gt;贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。&lt;/p&gt;\n&lt;p&gt;所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;基本思路\&#34;&gt;基本思路&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;建立数学模型来描述问题。&lt;/li&gt;\n&lt;li&gt;把求解的问题分成若干个子问题。&lt;/li&gt;\n&lt;li&gt;对每一子问题求解，得到子问题的局部最优解。&lt;/li&gt;\n&lt;li&gt;把子问题的解局部最优解合成原来解问题的一个解。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;适用的问题\&#34;&gt;适用的问题&lt;/h2&gt;\n&lt;p&gt;前提：局部最优策略能导致产生全局最优解。&lt;/p&gt;\n&lt;p&gt;贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。&lt;br&gt;\n因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。&lt;br&gt;\n示例参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-greedy-algorithm&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。&lt;/p&gt;\n&lt;p&gt;贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。&lt;/p&gt;\n&lt;p&gt;所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-贪心算法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;贪心&#34;,&#34;slug&#34;:&#34;IyGxpU62KW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IyGxpU62KW/&#34;},{&#34;name&#34;:&#34;贪心算法&#34;,&#34;slug&#34;:&#34;yZy_FtK53C&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/yZy_FtK53C/&#34;}],&#34;date&#34;:&#34;2019-01-03 23:11:57&#34;,&#34;dateFormat&#34;:&#34;2019-01-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-greedy-algorithm/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:85000,&#34;words&#34;:418,&#34;minutes&#34;:2},&#34;description&#34;:&#34;所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。\n贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\&#34;&gt;基本思路&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%82%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;适用的问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;递归\&#34;&gt;递归&lt;/h1&gt;\n&lt;p&gt;直接或者间接不断反复调用自身来达到解决问题的方法。要求原始问题可以分解为相同问题的子问题。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;先决条件&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;递归边界&lt;/li&gt;\n&lt;li&gt;自身调用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;br&gt;\n思路简单清晰，如果分析出将很快得到结果;递归将多次调用，使用到堆栈，算法效率低，费时费内存。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;常用场景&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;阶乘&lt;/li&gt;\n&lt;li&gt;斐波纳契数列&lt;/li&gt;\n&lt;li&gt;汉诺塔问题&lt;/li&gt;\n&lt;li&gt;整数划分&lt;/li&gt;\n&lt;li&gt;枚举排列及二叉树&lt;/li&gt;\n&lt;li&gt;图的搜索相关问题。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;分治\&#34;&gt;分治&lt;/h1&gt;\n&lt;p&gt;把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;br&gt;\n将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;br&gt;\n对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;问题的规模缩小到一定的程度就可以容易地解决&lt;/li&gt;\n&lt;li&gt;问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质&lt;/li&gt;\n&lt;li&gt;问题分解出的子问题的解可以合并为该问题的解&lt;/li&gt;\n&lt;li&gt;问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;基本操作步骤&lt;/strong&gt;&lt;br&gt;\n分治法在每一层递归上都有三个步骤：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题&lt;/li&gt;\n&lt;li&gt;解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题&lt;/li&gt;\n&lt;li&gt;合并：将各个子问题的解合并为原问题的解&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;常用场景&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;二分搜索&lt;/li&gt;\n&lt;li&gt;大整数乘法&lt;/li&gt;\n&lt;li&gt;Strassen矩阵乘法&lt;/li&gt;\n&lt;li&gt;棋盘覆盖&lt;/li&gt;\n&lt;li&gt;合并排序&lt;/li&gt;\n&lt;li&gt;快速排序&lt;/li&gt;\n&lt;li&gt;线性时间选择&lt;/li&gt;\n&lt;li&gt;最接近点对问题&lt;/li&gt;\n&lt;li&gt;循环赛日程表&lt;/li&gt;\n&lt;li&gt;汉诺塔&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-recursion-and-division&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;递归\&#34;&gt;递归&lt;/h1&gt;\n&lt;p&gt;直接或者间接不断反复调用自身来达到解决问题的方法。要求原始问题可以分解为相同问题的子问题。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;先决条件&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;递归边界&lt;/li&gt;\n&lt;li&gt;自身调用&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-递归和分治&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;递归&#34;,&#34;slug&#34;:&#34;7RKy9sP4fu&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/7RKy9sP4fu/&#34;},{&#34;name&#34;:&#34;分治&#34;,&#34;slug&#34;:&#34;ZJqXQqA9UT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ZJqXQqA9UT/&#34;}],&#34;date&#34;:&#34;2019-01-03 22:51:01&#34;,&#34;dateFormat&#34;:&#34;2019-01-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-recursion-and-division/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:123000,&#34;words&#34;:613,&#34;minutes&#34;:3},&#34;description&#34;:&#34;递归\n直接或者间接不断反复调用自身来达到解决问题的方法。要求原始问题可以分解为相同问题的子问题。\n先决条件\n\n递归边界\n自身调用\n\n\n特点\n思路简单清晰，如果分析出将很快得到结果;递归将多次调用，使用到堆栈，算法效率低，费时费内存。\n常用场...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%92%E5%BD%92\&#34;&gt;递归&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E6%B2%BB\&#34;&gt;分治&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;树\&#34;&gt;树&lt;/h1&gt;\n&lt;h2 id=\&#34;定义\&#34;&gt;定义&lt;/h2&gt;\n&lt;p&gt;树(Tree)是元素的集合，每棵树由多个节点（node）组成，用以储存元素。某些节点之间存在着一定的关系，用连线表示，连线称为边（edge）或者链接。边的上端点成为父节点，下端称为子节点。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;img src=\&#34;/images/tree01.png\&#34; alt=\&#34;tree\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n每个节点可以有多个子节点，而该节点则是相应子节点的父节点。但是每个节点只能有一个父节点（只有一个例外，也就是根节点，它没有父节点），如图中第一棵树的 S 节点即为根节点。而没有子节点的节点则称为叶子节点或叶节点，如上图中第一棵树的 A、R、X 节点。E、X 的父节点是一个节点，所以它们被称为兄弟节点。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;树是元素的集合&lt;/li&gt;\n&lt;li&gt;该集合可以为空。此时树中没有元素，称之为空树（empty tree）。&lt;/li&gt;\n&lt;li&gt;如果该集合不为空，那么该集合至少含有一个根节点以及 0 个或多个子树。根节点与它的子树的根节点用一个边（edge）或链接相连。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;特征\&#34;&gt;特征&lt;/h2&gt;\n&lt;p&gt;高度（Height）、深度（Depth）、层（Level）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;节点的高度 = 节点到叶子结点的最长路径（边数）&lt;/li&gt;\n&lt;li&gt;节点的深度 = 根节点到这个节点所经历的边的个数&lt;/li&gt;\n&lt;li&gt;节点的层数 = 节点的深度 + 1&lt;/li&gt;\n&lt;li&gt;树的高度 = 根节点的高度&lt;br&gt;\n&lt;img src=\&#34;/images/tree02.png\&#34; alt=\&#34;tree\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;二叉树\&#34;&gt;二叉树&lt;/h1&gt;\n&lt;h2 id=\&#34;定义-2\&#34;&gt;定义&lt;/h2&gt;\n&lt;p&gt;二叉树是一种特殊的数据结构，顾名思义，二叉树只有两个叉，也就是两个子节点：左子节点和右子节点。其中，左子节点是左子树的根节点，右子节点是右子树的根节点。当然，这并不是说，二叉树一定要求每个节点都必须有两个子节点，有的节点只有左子节点，而有的节点只有右子节点。&lt;/p&gt;\n&lt;h2 id=\&#34;二叉树的三种遍历方法\&#34;&gt;二叉树的三种遍历方法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;前序遍历（也叫先序遍历）：若二叉树为空，则空操作，否则，对于二叉树中的任意节点，先访问这个节点，然后再访问它的左子树，最后打印它的右子树。&lt;/li&gt;\n&lt;li&gt;中序遍历：若二叉树为空，则空操作，否则，对于二叉树中的任意节点，先访问它的左子树，然后再访问这个节点本身，最后访问它的右子树。&lt;/li&gt;\n&lt;li&gt;后序遍历：若二叉树为空，则空操作，否则，对于二叉树中的任意节点，先访问它的左子树，然后访问它的右子树，最后访问这个节点本身。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /** 先序递归遍历 */\n    void DLR(BiTree bt) {\n        if (null != bt) {\n            System.out.println(bt.data);\n            DLR(bt.lchild);\n            DLR(bt.rchild);\n        }\n    }\n    /** 中序递归遍历 */\n    void LDR(BiTree bt) {\n        if (null != bt) {\n            LDR(bt.lchild);\n            System.out.println(bt.data);\n            LDR(bt.rchild);\n        }\n    }\n    /** 后序递归遍历 */\n    void LRD(BiTree bt) {\n        if (null != bt) {\n            LRD(bt.lchild);\n            LRD(bt.rchild);\n            System.out.println(bt.data);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;树与二叉树的区别\&#34;&gt;树与二叉树的区别&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;二叉树的每个节点最多只能有两个节点，而树则无限制&lt;/li&gt;\n&lt;li&gt;二叉树中节点的子树分为左子树和右子树，即使某个节点只有一棵树，也必须要指明这棵树是左子树还是右子树，也就是说，二叉树是有序的&lt;/li&gt;\n&lt;li&gt;树不能为空，至少含有一个节点，而一棵二叉树可以为空&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;二叉搜索树\&#34;&gt;二叉搜索树&lt;/h1&gt;\n&lt;h2 id=\&#34;定义-3\&#34;&gt;定义&lt;/h2&gt;\n&lt;p&gt;二叉查找树（Binary Search Tree，BST）是一种特殊的二叉树，一棵二叉搜索树（BST）是一棵二叉树，其中，每个节点的值都要大于其左子树中任意节点的值而小于右子树中任意节点的值。&lt;/p&gt;\n&lt;h2 id=\&#34;特征-2\&#34;&gt;特征&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;若它的左子树不为空，那么左子树上所有节点的key都小于根节点的key。&lt;/li&gt;\n&lt;li&gt;若它的右子树不为空，那么右子树上所有节点的key都大于根节点的key。&lt;/li&gt;\n&lt;li&gt;它的左右子树也分别为二叉排序树。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;查找\&#34;&gt;查找&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;如果二叉查找树为空，则返回空操作，否则，执行一下操作；&lt;/li&gt;\n&lt;li&gt;先取根节点，如果节点 X 等于根节点，则返回；&lt;/li&gt;\n&lt;li&gt;如果节点小于根节点，则递归查找左子树；&lt;/li&gt;\n&lt;li&gt;如果节点大于根节点，则递归查找右子树。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;插入\&#34;&gt;插入&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;如果树是空的，则直接将新节点插入，否则，执行下面步骤。&lt;/li&gt;\n&lt;li&gt;要插入的数据比根节点数据大，则到右子树中插入新数据，如果右子树为空，则将新数据直接插入到右子节点的位置；不为空，则继续遍历右子树，查找插入位置。&lt;/li&gt;\n&lt;li&gt;要插入的数据比根节点数据小，则到左子树中插入数据，如果左子树为空，则直接将新数据插入到左子节点的位置；不为空，则继续遍历左子树，查找插入的位置。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;删除\&#34;&gt;删除&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;第一种情况，如果要删除的节点没有子节点，直接将父节点指向要删除节点的指针指向 null。比如途中要删除的节点 55。&lt;/li&gt;\n&lt;li&gt;第二种情况，如果要删除的节点只有一个节点，即只有左子节点或右子节点，则将父节点指向要删除节点的指针指向要删除节点的子节点即可。比如途中要删除的节点&lt;/li&gt;\n&lt;li&gt;第三种情况，如果要删除的节点有两个子节点，则需要先找到这个节点右子树中的最小节点或者左子树中的最大节点，将其替换到要删除的节点上。然后删除这个右子树中的最小节点或左子树中的最大节点，这样就可以利用&lt;br&gt;\n1、2 两条规则来删除了。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;查找最大-最小节点\&#34;&gt;查找最大、最小节点&lt;/h2&gt;\n&lt;p&gt;查找最大、最小节点比较简单，比如要查找二叉查找树的最大节点时，如果二叉查找树为空，则返回空操作，如果不为空，则判断是否只有一个节点（即只有根节点），如果是则返回根节点，否则到右子树中递归查找。同理，查找最小节点类似，只是到左子树中查找而已。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-tree&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;树\&#34;&gt;树&lt;/h1&gt;\n&lt;h2 id=\&#34;定义\&#34;&gt;定义&lt;/h2&gt;\n&lt;p&gt;树(Tree)是元素的集合，每棵树由多个节点（node）组成，用以储存元素。某些节点之间存在着一定的关系，用连线表示，连线称为边（edge）或者链接。边的上端点成为父节点，下端称为子节点。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学些-树、二叉树、二叉搜索树&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;树&#34;,&#34;slug&#34;:&#34;ugfXNwcZgD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ugfXNwcZgD/&#34;},{&#34;name&#34;:&#34;二叉树&#34;,&#34;slug&#34;:&#34;q0FWefvTSU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/q0FWefvTSU/&#34;},{&#34;name&#34;:&#34;二叉搜索树&#34;,&#34;slug&#34;:&#34;uJeRBpJAps&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/uJeRBpJAps/&#34;}],&#34;date&#34;:&#34;2019-01-02 23:05:12&#34;,&#34;dateFormat&#34;:&#34;2019-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-tree/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:325000,&#34;words&#34;:1557,&#34;minutes&#34;:6},&#34;description&#34;:&#34;树\n定义\n树(Tree)是元素的集合，每棵树由多个节点（node）组成，用以储存元素。某些节点之间存在着一定的关系，用连线表示，连线称为边（edge）或者链接。边的上端点成为父节点，下端称为子节点。\n\n\n每个节点可以有多个子节点，而该节点则...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%91\&#34;&gt;树&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89\&#34;&gt;定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E5%BE%81\&#34;&gt;特征&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E5%8F%89%E6%A0%91\&#34;&gt;二叉树&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89-2\&#34;&gt;定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95\&#34;&gt;二叉树的三种遍历方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB\&#34;&gt;树与二叉树的区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\&#34;&gt;二叉搜索树&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89-3\&#34;&gt;定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E5%BE%81-2\&#34;&gt;特征&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E6%89%BE\&#34;&gt;查找&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E5%85%A5\&#34;&gt;插入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4\&#34;&gt;删除&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7-%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9\&#34;&gt;查找最大、最小节点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;定义\&#34;&gt;定义&lt;/h1&gt;\n&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。它通过把关键码映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数（哈希函数），存放记录的数组叫做散列表。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-优缺点\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n优缺点&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;优点：哈希表可以提供快速的操作。&lt;/li&gt;\n&lt;li&gt;缺点：哈希表通常是基于数组的，数组创建后难于扩展。&lt;br&gt;\n也没有一种简便的方法可以以任何一种顺序〔例如从小到大）遍历表中的数据项。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;综上，如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。&lt;/p&gt;\n&lt;h1 id=\&#34;哈希查找\&#34;&gt;哈希查找&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;使用哈希函数将被查找的键转换为数组的索引。&lt;/li&gt;\n&lt;li&gt;处理哈希碰撞冲突。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;散列函数\&#34;&gt;散列函数&lt;/h1&gt;\n&lt;p&gt;若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。&lt;/p&gt;\n&lt;p&gt;若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数(Uniform Hash function)，这就是使关键字经过散列函数得到一个&amp;quot;随机的地址&amp;quot;，从而减少碰撞。&lt;/p&gt;\n&lt;p&gt;散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。&lt;/p&gt;\n&lt;p&gt;一个好的散列函数一般应该考虑下列因素：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;计算简单，以便提高转换速度。&lt;/li&gt;\n&lt;li&gt;关键词对应的地址空间分布均匀，以尽量减少冲突。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;常见的散列函数\&#34;&gt;常见的散列函数&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;直接定址法：取关键字key的某个线性函数为散列地址，如Hash(key) = key  或 Hash(key) = A*key+B；A,B为常数&lt;/li&gt;\n&lt;li&gt;除留取余法：关键值除以比散列表长度小的素数所得的余数作为散列地址。Hash(key) = key % p;&lt;/li&gt;\n&lt;li&gt;平均取中法：先计算构成关键码的标识符的内码的平方，然后按照散列表的大小取中间的若干位作为散列地址。&lt;/li&gt;\n&lt;li&gt;折叠法：把关键码自左到右分为位数相等的几部分，每一部分的位数应与散列表地址位数相同，只有最后一部分的位数可以短一些。把这些部分的数据叠加起来，就可以得到具有关键码的记录的散列地址。分为移位法和分界法。&lt;/li&gt;\n&lt;li&gt;随机数法：选择一个随机函数，取关键字的随机函数作为它的哈希地址。&lt;/li&gt;\n&lt;li&gt;数学分析法：设有N个d位数，每一位可能有r种不同的符号。这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种符号出现的机会均等；在某些位上分布不均匀，只有某几种符号经常出现。可根据散列表的大小，选取其中各种符号分布均匀的若干位作为散列地址。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;处理冲突\&#34;&gt;处理冲突&lt;/h1&gt;\n&lt;p&gt;对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为碰撞(英语:Collision)。具有相同函数值的关键字对该散列函数来说称做同义词。&lt;/p&gt;\n&lt;p&gt;通过构造性能良好的散列函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。&lt;/p&gt;\n&lt;h2 id=\&#34;开放定址法\&#34;&gt;开放定址法&lt;/h2&gt;\n&lt;p&gt;这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H(key)出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：Hi=(H(key)+di)%m   i=1，2，…，m-1,其中H（key）为哈希函数，m 为表长，di称为增量序列，i为碰撞次数。增量序列的取值方式不同，相应的再散列方式也不同。增量序列主要有以下几种：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;线性探测再散列&lt;/strong&gt;&lt;br&gt;\ndi=1，2，3，…，m-1&lt;br&gt;\n这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;二次探测再散列&lt;/strong&gt;&lt;br&gt;\ndi=12，-12，22，-22，…，k2，-k2( k&amp;lt;=m/2 )&lt;br&gt;\n这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;伪随机探测再散列&lt;/strong&gt;&lt;br&gt;\ndi=伪随机数序列。&lt;br&gt;\n线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定。线性探测再散列容易产生“二次聚集”，即在处理同义词的冲突时又导致非同义词的冲突。&lt;/p&gt;\n&lt;h2 id=\&#34;再哈希法\&#34;&gt;再哈希法&lt;/h2&gt;\n&lt;p&gt;这种方法是同时构造多个不同的哈希函数：Hi=RHi（key），i=1，2,3，…,n。&lt;br&gt;\n当哈希地址H1=RH1（key）发生冲突时，再计算H2=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。&lt;/p&gt;\n&lt;h2 id=\&#34;链地址法拉链法\&#34;&gt;链地址法(拉链法)&lt;/h2&gt;\n&lt;p&gt;这种方法的基本思想是将所有哈希地址相同的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表（数组）中，因而查找、插入和删除主要在同义词链中进行。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。链地址法适用于经常进行插入和删除的情况。&lt;/p&gt;\n&lt;p&gt;与开放定址法相比，拉链法有如下几个优点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；&lt;/li&gt;\n&lt;li&gt;由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；&lt;/li&gt;\n&lt;li&gt;开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中理论上可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；（散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度）&lt;/li&gt;\n&lt;li&gt;在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放定址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径。这是因为各种开放定址法中，空地址单元都被理解没有查找到元素。 因此在用开放定址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;拉链法的缺点&lt;br&gt;\n指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，此时将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。&lt;/p&gt;\n&lt;h2 id=\&#34;建立公共溢出区\&#34;&gt;建立公共溢出区&lt;/h2&gt;\n&lt;p&gt;将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表(在这个方法里面是把元素分开两个表来存储)。&lt;/p&gt;\n&lt;h1 id=\&#34;查找性能\&#34;&gt;查找性能&lt;/h1&gt;\n&lt;p&gt;散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。&lt;/p&gt;\n&lt;p&gt;查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;影响产生冲突多少有以下三个因素:&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;散列函数是否均匀;&lt;/li&gt;\n&lt;li&gt;处理冲突的方法;&lt;/li&gt;\n&lt;li&gt;散列表的装填因子。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-hash-table&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;定义\&#34;&gt;定义&lt;/h1&gt;\n&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。它通过把关键码映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数（哈希函数），存放记录的数组叫做散列表。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-哈希表&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;哈希表&#34;,&#34;slug&#34;:&#34;emN0OH3DIoM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/emN0OH3DIoM/&#34;}],&#34;date&#34;:&#34;2019-01-02 21:18:12&#34;,&#34;dateFormat&#34;:&#34;2019-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-hash-table/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:501000,&#34;words&#34;:2413,&#34;minutes&#34;:9},&#34;description&#34;:&#34;定义\n散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。它通过把关键码映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数（哈希函数），存放记录的数组叫做散列表。\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89\&#34;&gt;定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-%E4%BC%98%E7%BC%BA%E7%82%B9\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n优缺点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE\&#34;&gt;哈希查找&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\&#34;&gt;散列函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\&#34;&gt;常见的散列函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81\&#34;&gt;处理冲突&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95\&#34;&gt;开放定址法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95\&#34;&gt;再哈希法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E6%8B%89%E9%93%BE%E6%B3%95\&#34;&gt;链地址法(拉链法)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA\&#34;&gt;建立公共溢出区&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD\&#34;&gt;查找性能&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-实现机制\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n实现机制&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;Heap(Binary, Binomial, Fibonacci)&lt;/li&gt;\n&lt;li&gt;Binary Search Tree&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;各种堆的时间复杂堆参考：https://en.wikipedia.org/wiki/Heap_(data_structure)&lt;br&gt;\n&lt;img src=\&#34;/images/heap01.png\&#34; alt=\&#34;各种堆的时间复杂度\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-priority-queue&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-优先队列&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;优先队列&#34;,&#34;slug&#34;:&#34;v0Pc3JyAq-C&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/v0Pc3JyAq-C/&#34;}],&#34;date&#34;:&#34;2019-01-01 23:58:36&#34;,&#34;dateFormat&#34;:&#34;2019-01-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-priority-queue/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:26000,&#34;words&#34;:115,&#34;minutes&#34;:1},&#34;description&#34;:&#34;普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。\n\n实现机制\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n实现机制&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;栈和队列都是动态集合，可以理解为线性表或线性表实现的数据结构。它可以由数组实现，也可以由链表实现。&lt;br&gt;\n和数组链表等不一样的是，栈、队列添加、删除数据的位置都是预先设定的。在栈中，被删除的是最近被插入的元素，栈实现的是一种先进后出的策略。而队列中，被删去的总是在集合中存在时间最长的元素，队列实现的是一种先进先出的策略。&lt;br&gt;\n栈和队列是非常有用的数据结构，在计算机中很多的地方使用了栈、队列的思想。函数执行的压栈及出栈，消息队列的使用等等。本文最后将介绍栈和队列的常见使用场景，递归转化。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-堆栈\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n堆栈&lt;/h1&gt;\n&lt;p&gt;一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。不含任何元素的栈称为空栈，栈又称为后进先出的线性表。&lt;br&gt;\n&lt;img src=\&#34;/images/stack01.jpeg\&#34; alt=\&#34;堆栈\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;队列\&#34;&gt;队列&lt;/h1&gt;\n&lt;p&gt;只允许在一端进行插入数据操作，在另一端进行删除操作的特殊线性表。插入的叫队尾，删除的叫队头，对列具有先进先出的特性。&lt;br&gt;\n&lt;img src=\&#34;/images/queue01.jpeg\&#34; alt=\&#34;队列\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;时间复杂度对比参考：http://www.bigocheatsheet.com/&lt;br&gt;\n&lt;img src=\&#34;/images/bigocheatsheet.png\&#34; alt=\&#34;时间复杂度对比\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-stack-and-queue&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;栈和队列都是动态集合，可以理解为线性表或线性表实现的数据结构。它可以由数组实现，也可以由链表实现。&lt;br&gt;\n和数组链表等不一样的是，栈、队列添加、删除数据的位置都是预先设定的。在栈中，被删除的是最近被插入的元素，栈实现的是一种先进后出的策略。而队列中，被删去的总是在集合中存在时间最长的元素，队列实现的是一种先进先出的策略。&lt;br&gt;\n栈和队列是非常有用的数据结构，在计算机中很多的地方使用了栈、队列的思想。函数执行的压栈及出栈，消息队列的使用等等。本文最后将介绍栈和队列的常见使用场景，递归转化。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-堆栈和队列&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;堆栈&#34;,&#34;slug&#34;:&#34;sHjwe6Ur5uV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/sHjwe6Ur5uV/&#34;},{&#34;name&#34;:&#34;队列&#34;,&#34;slug&#34;:&#34;2FO5xFRR5C3&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/2FO5xFRR5C3/&#34;}],&#34;date&#34;:&#34;2019-01-01 23:24:08&#34;,&#34;dateFormat&#34;:&#34;2019-01-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-stack-and-queue/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:73000,&#34;words&#34;:365,&#34;minutes&#34;:2},&#34;description&#34;:&#34;栈和队列都是动态集合，可以理解为线性表或线性表实现的数据结构。它可以由数组实现，也可以由链表实现。\n和数组链表等不一样的是，栈、队列添加、删除数据的位置都是预先设定的。在栈中，被删除的是最近被插入的元素，栈实现的是一种先进后出的策略。而队列...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-%E5%A0%86%E6%A0%88\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n堆栈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%9F%E5%88%97\&#34;&gt;队列&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;数组和链表是数据结构中最基本的部分，也是其余众多数据结构的基础。即使在Java中，这两种结构使用的也很普遍。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-数组\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n数组&lt;/h1&gt;\n&lt;p&gt;在java中，数组定义为一种基本类型，其可以通过下标获取到对应位置的数据。那么这种结构的数据，在内存中是怎么存放的呢？&lt;br&gt;\n&lt;img src=\&#34;/images/array01.png\&#34; alt=\&#34;array01\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n正如上图所示，数组在内存中是一段连续的存储单元，每个数据依次放在每个单元中。分析这种结构，我们可以得出以下几个结论：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;创建一个数组，必须声明其长度，以在内存中寻找合适的一段连续存储单元。这也意味着数组的大小是固定的，我们无法动态调整其大小。&lt;/li&gt;\n&lt;li&gt;想要获取数组中第i个元素，其时间复杂度是 O(1)，因为可以根据其地址直接找到它。同理修改也是。&lt;/li&gt;\n&lt;li&gt;数组对查询表现一般，要想查找一个元素，需要遍历，时间复杂度为O(n)。&lt;/li&gt;\n&lt;li&gt;因为地址连续，想要在数组中插入一个元素是复杂的，因为从插入位置起，后边的所有元素都需要向后移动一位。同理删除也是，只是移动方向为向前。并且，当数组存满时，就无法继续插入了。&lt;/li&gt;\n&lt;li&gt;因为数组要占据一整块内存，有可能产生许多的碎片，也可能因为找不到合适的内存块，而导致存储失败。&lt;br&gt;\n故：数组大小固定，查找迅速，增删复杂，需要完整的内存块，容易产生碎片。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;链表\&#34;&gt;链表&lt;/h1&gt;\n&lt;p&gt;链表是一种离散存储结构，其在内存中存储不是连续的，每个数据元素都通过一个指针指向其下一个元素的地址。根据指针域的不同，链表又分为单链表、双向链表、循环链表等，这里我们只分析单链表。示意图如下所示：&lt;br&gt;\n&lt;img src=\&#34;/images/linkedlist.png\&#34; alt=\&#34;linkedlist\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;分析这种结构，我们可以得出以下几个结论：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;声明一个链表时，不需要知道其长度，也不需要连续的内存块，所以其大小可以动态调整。&lt;/li&gt;\n&lt;li&gt;链表的每个元素都分为数据域和指针域，前者是实际存储的数据，后者则指向下一个元素的地址。和数组相比，每个元素需要占用的内存更大了。&lt;/li&gt;\n&lt;li&gt;要获取链表的第 i 个元素变得复杂，因为其地址存放在它上一个元素的指针域里，所以只能从第一个元素起，进行 i 次操作。同理修改也是。&lt;/li&gt;\n&lt;li&gt;链表对查询表现也一般，需要遍历，时间复杂度为O(n)。&lt;/li&gt;\n&lt;li&gt;增加与删除一个元素更方便了，因为没有对内存地址的限制，我们只需要在对应节点合理处理下指针域的值，就可以把一个元素插入链表或者从链表删除。&lt;/li&gt;\n&lt;li&gt;链表对内存的要求很小，只要能够存储下一个数据元素的内存块都可以使用，因此不会造成碎片化。&lt;br&gt;\n故：大小可以动态调整，增删迅速，查找较慢，数据元素所占内存略多，不需要整块内存块，不会造成碎片化。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;对比\&#34;&gt;对比&lt;/h1&gt;\n&lt;p&gt;数组按位置查找迅速，链表增删方便&lt;br&gt;\n数组是固定大小，链表可以随时扩充与缩减&lt;br&gt;\n链表每个元素占据内存略多于数组&lt;br&gt;\n数组和链表在查询方面表现都比较一般，耗时较长&lt;br&gt;\n时间复杂度参考：http://www.bigocheatsheet.com/&lt;br&gt;\n&lt;img src=\&#34;/images/time.png\&#34; alt=\&#34;time\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;algorithm-array-and-linkedlist&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;数组和链表是数据结构中最基本的部分，也是其余众多数据结构的基础。即使在Java中，这两种结构使用的也很普遍。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;算法学习-数组与链表&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;0n80ESKHvQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/0n80ESKHvQ/&#34;},{&#34;name&#34;:&#34;数据结构&#34;,&#34;slug&#34;:&#34;4-Zd241g2e&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4-Zd241g2e/&#34;},{&#34;name&#34;:&#34;数组&#34;,&#34;slug&#34;:&#34;seydi9asI86&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/seydi9asI86/&#34;},{&#34;name&#34;:&#34;链表&#34;,&#34;slug&#34;:&#34;7gQuVpPxVb0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/7gQuVpPxVb0/&#34;}],&#34;date&#34;:&#34;2019-01-01 22:24:08&#34;,&#34;dateFormat&#34;:&#34;2019-01-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/algorithm-array-and-linkedlist/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:190000,&#34;words&#34;:940,&#34;minutes&#34;:4},&#34;description&#34;:&#34;数组和链表是数据结构中最基本的部分，也是其余众多数据结构的基础。即使在Java中，这两种结构使用的也很普遍。\n\n数组\n在java中，数组定义为一种基本类型，其可以通过下标获取到对应位置的数据。那么这种结构的数据，在内存中是怎么存放的呢？\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-%E6%95%B0%E7%BB%84\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%93%BE%E8%A1%A8\&#34;&gt;链表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E6%AF%94\&#34;&gt;对比&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;ExecutorService中有很多工具方法，在前面的文章中提过一些，这里将对剩余方法的功能进行介绍。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;invokeyAny()和invokeAll()具有阻塞特性&lt;/p&gt;\n&lt;h1 id=\&#34;invokeanycollection-extends-callablet-tasks\&#34;&gt;invokeAny(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks)&lt;/h1&gt;\n&lt;p&gt;取得第一个完成任务的结果值，当第一个任务执行完成后，会调用interrupt()方法将其他任务中断，所以在这些任务中可以结果if(Thread.currentThread().isInterrupted()==true)代码来决定任务是否继续&lt;br&gt;\n1、其他线程无if(Thread.currentThread().isInterrupted()==true)代码，已经获得第一个运行的结果值后，其他线程继续运行&lt;br&gt;\n2、其他线程有if(Thread.currentThread().isInterrupted()==true)代码，已经获得第一个运行的结果值后，其他线程用throw new InterruptedException()代码则这些线程中断，虽然throw 抛出了异常。但在主线程中并不能捕获到异常，如果想捕获异常，则需要在Callable中使用try-catch显示进行捕获。&lt;/p&gt;\n&lt;p&gt;如果invokeyAny()执行慢的任务发生异常，默认情况下在主线程中捕获不到异常信息，只能在当前任务中显示的使用try-catch进行捕获&lt;br&gt;\n如果invokeyAny()执行快的任务发生异常，默认情况下在主线程中捕获不到异常信息，除非在当前任务中显示的使用try-catch进行捕获，该方法还会等待执行慢的任务返回结果值。&lt;br&gt;\n【先出现异常而不影响后面的任务取值的原理在源码中一直判断没有正确的返回值，如果直到最后都没有获得返回值则抛出ExecutionException，这个异常的内容是最后出现的异常。比如A、B、C这三个任务一起被执行，都出现了异常，则最终的异常就是在最后出现的异常】&lt;/p&gt;\n&lt;h1 id=\&#34;invokeanycollection-extends-callablet-tasks-long-timeout-timeunit-unit\&#34;&gt;invokeAny(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks, long timeout, TimeUnit unit)&lt;/h1&gt;\n&lt;p&gt;指定时间内取得第一个先执行完任务的结果值&lt;br&gt;\n在出现超时异常时，可以将if(Thread.currentThread().isInterrupted()==true)判断和throw new InterruptedException()结合以使线程中断执行&lt;/p&gt;\n&lt;h1 id=\&#34;invokeallcollection-extends-callablet-tasks\&#34;&gt;invokeAll(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks)&lt;/h1&gt;\n&lt;p&gt;等待全部线程执行完毕后，取得全部完成任务的结果值。&lt;br&gt;\n如果有任务执行时异常，则在对应的get()方法时抛出&lt;/p&gt;\n&lt;h1 id=\&#34;invokeallcollection-extends-callablet-tasks-long-timeout-timeunit-unit\&#34;&gt;invokeAll(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks, long timeout, TimeUnit unit)&lt;/h1&gt;\n&lt;p&gt;如果全部任务在指定时间内没有完成，则出现异常(CancallationException)&lt;br&gt;\n如果正常执行完成的任务，可以通过对应的get()方法获取到返回值，没有在指定时间内执行完的任务则抛出CancallationException异常。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ExecutorService&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;ExecutorService中有很多工具方法，在前面的文章中提过一些，这里将对剩余方法的功能进行介绍。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;ExecutorService接口的使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;ExecutorService&#34;,&#34;slug&#34;:&#34;YRBifJssT9l&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/YRBifJssT9l/&#34;},{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;d7I_i0o7n6s&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/d7I_i0o7n6s/&#34;}],&#34;date&#34;:&#34;2018-05-07 23:02:23&#34;,&#34;dateFormat&#34;:&#34;2018-05-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/ExecutorService/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:146000,&#34;words&#34;:656,&#34;minutes&#34;:3},&#34;description&#34;:&#34;ExecutorService中有很多工具方法，在前面的文章中提过一些，这里将对剩余方法的功能进行介绍。\n\ninvokeyAny()和invokeAll()具有阻塞特性\ninvokeAny(Collection&amp;lt;? extends C...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#invokeanycollection-extends-callablet-tasks\&#34;&gt;invokeAny(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#invokeanycollection-extends-callablet-tasks-long-timeout-timeunit-unit\&#34;&gt;invokeAny(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks, long timeout, TimeUnit unit)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#invokeallcollection-extends-callablet-tasks\&#34;&gt;invokeAll(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#invokeallcollection-extends-callablet-tasks-long-timeout-timeunit-unit\&#34;&gt;invokeAll(Collection&amp;lt;? extends Callable&lt;T&gt;&amp;gt; tasks, long timeout, TimeUnit unit)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;接口CompletionService的功能是以异步的方式一边生产新任务，一边处理已完成任务的结果，这样可以将执行任务与处理任务分离开来进行处理。使用submit()执行任务，使用take()取得已完成的任务，并按照完成这些任务的时间顺序处理它们。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;上一篇文章讲到Future具有阻塞同步性，这样的代码运行效率大打折扣，接口CompletionService可以很好的解决这个问题。&lt;/p&gt;\n&lt;p&gt;示例代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) {\n        try {\n            ThreadPoolExecutor pool = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;());\n            CompletionService cs = new ExecutorCompletionService(pool);\n            List&amp;lt;Callable&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();\n            list.add(() -&amp;gt; { System.out.println(&amp;quot;username1&amp;quot;);Thread.sleep(5000);return &amp;quot;return username1&amp;quot;; });\n            list.add(() -&amp;gt; { System.out.println(&amp;quot;username2&amp;quot;);Thread.sleep(4000);return &amp;quot;return username2&amp;quot;; });\n            list.add(() -&amp;gt; { System.out.println(&amp;quot;username3&amp;quot;);Thread.sleep(3000);return &amp;quot;return username3&amp;quot;; });\n            list.add(() -&amp;gt; { System.out.println(&amp;quot;username4&amp;quot;);Thread.sleep(2000);return &amp;quot;return username4&amp;quot;; });\n            list.add(() -&amp;gt; { System.out.println(&amp;quot;username5&amp;quot;);Thread.sleep(1000);return &amp;quot;return username5&amp;quot;; });\n\n            list.forEach(cs::submit);\n\n            for (int i = 1; i &amp;lt;= 5; i ++) {\n                System.out.println(&amp;quot;等待第&amp;quot; + i + &amp;quot;个的返回值&amp;quot;);\n                System.out.println(cs.take().get());\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;username1\nusername2\nusername3\nusername4\n等待第1个的返回值\nusername5\nreturn username5\n等待第2个的返回值\nreturn username4\n等待第3个的返回值\nreturn username3\n等待第4个的返回值\nreturn username2\n等待第5个的返回值\nreturn username1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从结果来看，CompletionService解决Future阻塞的特性，也就是谁先执行完成，就先处理谁的结果。&lt;br&gt;\n当然如果当前没有任务被执行完，cs.take().get()也是呈阻塞特性的&lt;/p&gt;\n&lt;p&gt;CompletionService执行任务时的各种异常：&lt;br&gt;\n如果任务执行异常，则通过对应的Future对象的get()方法抛出，如果不执行Future对象的get()方法，则该异常不抛出&lt;/p&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;take()取得最先完成任务的Future对象\npool()获取并移除表示下一个已经完成任务的Future对象，如果不存在这样的任务，则返回null，此方法无阻塞的效果\npoll(long timeout, TimeUnit unit)等带指定的时间，在指定的时间内获取到值时立即向下继续执行，如果超时也立即执行\nsubmit(Callable&amp;lt;V&amp;gt; task)\nsubmit(Runnable task, V result)参数V是对应的返回值\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;CompletionService&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;接口CompletionService的功能是以异步的方式一边生产新任务，一边处理已完成任务的结果，这样可以将执行任务与处理任务分离开来进行处理。使用submit()执行任务，使用take()取得已完成的任务，并按照完成这些任务的时间顺序处理它们。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;CompletionService的使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;d7I_i0o7n6s&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/d7I_i0o7n6s/&#34;},{&#34;name&#34;:&#34;CompletionService&#34;,&#34;slug&#34;:&#34;mTvkwGgyq1I&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/mTvkwGgyq1I/&#34;}],&#34;date&#34;:&#34;2018-05-07 21:40:33&#34;,&#34;dateFormat&#34;:&#34;2018-05-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/CompletionService/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:156000,&#34;words&#34;:595,&#34;minutes&#34;:3},&#34;description&#34;:&#34;接口CompletionService的功能是以异步的方式一边生产新任务，一边处理已完成任务的结果，这样可以将执行任务与处理任务分离开来进行处理。使用submit()执行任务，使用take()取得已完成的任务，并按照完成这些任务的时间顺序处...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在默认情况下，线程Thread对象不具有返回值的功能，如果在需要取得返回值的情况下是极为不方便的，但在JDK1.5的并发包中可以使用Future和Callable来使线程具有返回值的功能。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;接口Callable和Runnable的区别&lt;br&gt;\n1、Callable接口的call()方法可以有返回值，而Runnable接口的run()方法没有返回值。&lt;br&gt;\n2、Callable()接口的call()方法可以声明抛出异常，而Runnable接口的run()方法不可以声明异常。&lt;/p&gt;\n&lt;p&gt;执行完Callable接口中的任务后，返回值是通过Future接口进行获取；&lt;br&gt;\nCallable示例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2, 3, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;());\n        Future&amp;lt;String&amp;gt; future = pool.submit(() -&amp;gt; {\n            Thread.sleep(5000);\n            return &amp;quot;Finished&amp;quot;;\n        });\n        System.out.println(&amp;quot;main A:&amp;quot; + System.currentTimeMillis());\n        System.out.println(future.get());\n        System.out.println(&amp;quot;main B:&amp;quot; + System.currentTimeMillis());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;main A:1525698162505\nFinished\nmain B:1525698167510\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从结果看出，get()方法具有阻塞的特性&lt;/p&gt;\n&lt;p&gt;Runnable示例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2, 3, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;());\n        Future&amp;lt;?&amp;gt; future = pool.submit(() -&amp;gt; {\n            try {\n                System.out.println(&amp;quot;运行开始：&amp;quot; + System.currentTimeMillis());\n                Thread.sleep(5000);\n                System.out.println(&amp;quot;运行结束：&amp;quot; + System.currentTimeMillis());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        System.out.println(&amp;quot;main A:&amp;quot; + System.currentTimeMillis());\n        System.out.println(future.get() + &amp;quot; | &amp;quot; + future.isDone());\n        System.out.println(&amp;quot;main B:&amp;quot; + System.currentTimeMillis());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;main A:1525698748640\n运行开始：1525698748640\n运行结束：1525698753643\nnull | true\nmain B:1525698753643\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从结果看出Runnable是没有返回值的，所以get()方法打印null，且也具有阻塞的特性，而isDone()方法无阻塞特性&lt;br&gt;\nCallable接口相对于Runnable接口的优点在于Callable接口可以通过Future获取返回值，但需要注意的是，Future接口调用get()方法时，是呈阻塞性的，也就是如果任务尚未完成，则调用get()方法时一直阻塞到此任务完成为止&lt;/p&gt;\n&lt;p&gt;异常处理&lt;br&gt;\nCallable任务如果执行过程中抛出来异常，会在对应的Future的get()方法中抛出&lt;/p&gt;\n&lt;p&gt;方法execute()与submit()的区别&lt;br&gt;\n1、execute()没有返回值，submit()可以有返回值&lt;br&gt;\n2、execute()默认情况下异常直接抛出，不能捕获，但可以通过自定义ThreadFactory的方式进行捕获(Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler eh))，&lt;br&gt;\nsubmit()方法在默认情况下，可以在对应的Future.get方法处捕获异常&lt;/p&gt;\n&lt;p&gt;Future的缺点:get()方法呈阻塞性，影响效率&lt;/p&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;ExecutorService接口的\nsubmit(Callable callable)\nsubmit(Runnable runnable)\nsubmit(Runnable runnable, T result)第二个参数可作为执行结果返回，而不需要使用get()方法来进行获取\n\nFuture\ncancel(boolean mayInterruptIfRunning)参数的作用是：如果线程正在运行则是否中断中断正在运行的线程，在代码中需要使用if(Thread.currentThread().isInterrupted())进行配合。返回值代表发送取消任务的命令是否成功完成\nget()\nget(long timeout, TimeUnit unit)指定的最大时间内等待获取返回值\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;Future-And-Callable&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;在默认情况下，线程Thread对象不具有返回值的功能，如果在需要取得返回值的情况下是极为不方便的，但在JDK1.5的并发包中可以使用Future和Callable来使线程具有返回值的功能。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Future和Callable的使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;d7I_i0o7n6s&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/d7I_i0o7n6s/&#34;},{&#34;name&#34;:&#34;Future&#34;,&#34;slug&#34;:&#34;zsn80gp17c8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/zsn80gp17c8/&#34;},{&#34;name&#34;:&#34;Callable&#34;,&#34;slug&#34;:&#34;L7rSjh6cCCV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/L7rSjh6cCCV/&#34;}],&#34;date&#34;:&#34;2018-05-07 20:37:19&#34;,&#34;dateFormat&#34;:&#34;2018-05-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/Future-And-Callable/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:188000,&#34;words&#34;:739,&#34;minutes&#34;:4},&#34;description&#34;:&#34;在默认情况下，线程Thread对象不具有返回值的功能，如果在需要取得返回值的情况下是极为不方便的，但在JDK1.5的并发包中可以使用Future和Callable来使线程具有返回值的功能。\n\n接口Callable和Runnable的区别\n1...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在开发服务端软件项目时，经常需要处理时间很短而数目却非常巨大的请求，如果为每一个请求创建一个新的线程，会导致性能上的瓶颈，因为线程对象的创建和销毁需要JVM频繁的处理，如果执行时间很短，可能花在创建和销毁线程对象上的时间将大于真正执行任务的时间，若这样，系统性能将大大降低。&lt;br&gt;\n因此JDK5起提供了线程池的支持，主要作用则时支持高并发的访问处理，并且可以将线程对象进行复用。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-executors\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\nExecutors&lt;/h1&gt;\n&lt;p&gt;Exwcutor仅仅时一种规范，是一种声明和定义，并没有实现任何的功能，所以需要使用接口的实现类来完成指定的功能，比如ThreadPoolExecutor。ThreadPoolExecutor使用上并不是很方便，实例化时需要传入很多个参数，还要考虑线程并发数等与线程运行效率相关的参数，所以官方建议使用Executors工厂类来创建线程池对象。&lt;/p&gt;\n&lt;h2 id=\&#34;newcachedthreadpool\&#34;&gt;newCachedThreadPool()&lt;/h2&gt;\n&lt;p&gt;创建无界线程池，可以进行线程自动回收&lt;br&gt;\n所谓“无界”就是指理论上的Integer.MAX_VALUE&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&amp;lt;Runnable&amp;gt;());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;newcachedthreadpoolthreadfactory-threadfactory\&#34;&gt;newCachedThreadPool(ThreadFactory threadFactory)&lt;/h2&gt;\n&lt;p&gt;可通过ThreadFactory定制无界线程池中的线程对象&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class MyThreadFactory implements ThreadFactory {\n    int i = 0;\n    @Override\n    public Thread newThread(Runnable r) {\n        return new Thread(r, &amp;quot;定制线程对象-&amp;quot; + ++ i);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;newfixedthreadpoolint-nthreads\&#34;&gt;newFixedThreadPool(int nThreads)&lt;/h2&gt;\n&lt;p&gt;创建有界线程池，也就是线程池中的线程数可以指定最大值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;newfixedthreadpoolint-nthreads-threadfactory-threadfactory\&#34;&gt;newFixedThreadPool(int nThreads, ThreadFactory threadFactory)&lt;/h2&gt;\n&lt;h2 id=\&#34;增加定制线程功能的有界线程池newsinglethreadexecutor\&#34;&gt;增加定制线程功能的有界线程池&lt;br&gt;\nnewSingleThreadExecutor()&lt;/h2&gt;\n&lt;p&gt;单一线程的线程池，实现队列的方式来执行任务&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;newsinglethreadexecutorthreadfactory-threadfactory\&#34;&gt;newSingleThreadExecutor(ThreadFactory threadFactory)&lt;/h2&gt;\n&lt;p&gt;定制线程功能的单一线程池&lt;/p&gt;\n&lt;h1 id=\&#34;threadpoolexecutor的使用\&#34;&gt;ThreadPoolExecutor的使用&lt;/h1&gt;\n&lt;p&gt;常用构造方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)\ncorePoolSize：池中保存的线程数，包括空闲线程数\nmaximumPoolSize：池中允许的最大线程数\nkeepAliveTime：线程数数量大于corePoolSize时，在没有超过指定时间内时不会从线程池中将空闲线程删除，超过此时间单位，则删除\nunit：keepAliveTime的时间单位\nworkQueue：执行前用于保存任务的队列。此队列仅保持由execute方法提交的Runnable任务\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;示例注释：&lt;br&gt;\nA：execute提交的Runnable任务数量&lt;br&gt;\nB：核心线程数corePoolSize&lt;br&gt;\nC：最大线程数maximumPoolSize&lt;br&gt;\nD：A-B（假设A&amp;gt;=B）&lt;br&gt;\nE：new LinkedBlockingDeque&lt;Runnable&gt;();队列，无构造参数&lt;br&gt;\nF：new SynchronousQueue&lt;Runnable&gt;();队列&lt;br&gt;\nG：keepAliveTime&lt;br&gt;\n注：这里E和F时两种类型的队列，指定线程池仅可选择一种&lt;/p&gt;\n&lt;p&gt;1、如果A&amp;lt;=B，那么马上创建线程运行这个任务，并不放入扩展队列Queue中，其他参数功能忽略&lt;br&gt;\n2、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;lt;=C&amp;amp;&amp;amp;E，那么C和G参数忽略，并把D放入E中等待被执行&lt;br&gt;\n3、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;lt;=C&amp;amp;&amp;amp;F，那么C和G参数有效，并马上创建线程运行这些任务，而不把D放入F中，D执行完成后在执行时间后放生超时将D进行清除&lt;br&gt;\n4、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;gt;C&amp;amp;&amp;amp;E，那么C和G参数忽略，并把D放入E中等待被执行&lt;br&gt;\n5、如果A&amp;gt;B &amp;amp;&amp;amp; A&amp;gt;C&amp;amp;&amp;amp;F，那么处理C的任务，其他任务则不再处理抛出异常&lt;/p&gt;\n&lt;p&gt;ThreadPoolExecutor常见的队列&lt;br&gt;\nA：ArrayBlockingQueue&lt;br&gt;\nB：LinkedBlockingDeque&lt;br&gt;\nC：SynchronousQueue&lt;br&gt;\nA和B可指定队列存储元素的多少，C是为同步队列，不存储元素&lt;/p&gt;\n&lt;p&gt;ThreadPoolExecutor拒绝策略&lt;br&gt;\nAbortPolicy：当任务添加到线程池中被拒绝时，它将抛出RejectedExecutionException异常&lt;br&gt;\nCallerRunsPolicy：当任务添加到线程池中被拒绝时，会使用调用线程池的Thread对象来处理该被决绝的任务&lt;br&gt;\n// 也就是说谁发起来这个任务，谁就要负责该任务的执行&lt;br&gt;\nDiscardOldestPolicy：当任务添加到线程池被拒绝时，线程池会放弃等待队列中最旧的未处理的任务，然后将被拒绝的任务添加到等待队列中&lt;br&gt;\nDiscardPolicy：当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务&lt;/p&gt;\n&lt;p&gt;注：线程池ThreadPoolExecutor的执行等待队列中的任务是安顺序去除，执行却是乱序的&lt;/p&gt;\n&lt;p&gt;参数说明&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;getCorePoolSize()获取核心线程数\ngetMaximunPoolSize()获取最大线程数\ngetPoolSize()当前池中线程数\ngetQueue().size()当前等待执行的线程数\ngetActiveCount()当前有多少个线程正在执行任务\ngetCompletedTaskCount()获取已经执行完成的任务数\ngetTaskCount()获取有多少个任务发送给了线程池\nshutdown()当前未执行完的线程继续执行，而不再添加新的任务；方法不会阻塞\nshutdownNow()中断所有的任务Task\n// 并且抛出InterruptedException异常\n// 前提时Runnable中使用if (Thread.currentThread().isInterrupted() == true)语句来判断当前线程的中断状态\n// 而在队列中等待执行的线程不再执行，也就是从等待队列中清除\n// 如果线程中没有if (Thread.currentThread().isInterrupted() == true)语句及抛出异常的代码，正在执行的线程会正常执行完毕\n// 该方法还会返回被清除的线程列表\nisShutdown()判断线程池是否已经关闭\nisTerminating()可以理解为线程池是否正在关闭\n// 当调用shutdown()或shutdownNow()之后处于正在终止但尚未完全终止的过程中时，该方法返回true\nisTerminated()线程池是否已经关闭\nawaitTermination(long timeout, TimeUnit unit)等待指定时间内，返回线程池是否已经终止工作，\nsetRejectedExecutionHandler(RejectedExecutionHandler handler)设置任务被拒绝执行时的策略\nallowCoreThreadTimeOut(boolean value)设置核心线程数是否也有超时效果\nprestartCoreThread()每调用一次就创建一个核心线程，返回是否创建成功\nprestartAllCoreThreads()启用全部核心线程，返回实际启动的核心线程数量\n// 线程池可重写以下两个方法对线程池中执行的线程对象实现监控\nbeforeExecute(Thread t, Runnable r)任务执行前\nafterExecute(Runnable r, Throwable t)任务执行完成后\nremove(Runnable task)删除尚未被执行的Runnable任务\n// 但是这个方法需要注意的是，如果通过execute()方法进行提交的任务，且在等待队列中时，才可被删除\n// 如果时通过submit()方法提交的任务，且在等待队列中时，不能被删除【原因时submit方法对任务进行了包装】\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;Executor-ThreadPoolExecutor&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;在开发服务端软件项目时，经常需要处理时间很短而数目却非常巨大的请求，如果为每一个请求创建一个新的线程，会导致性能上的瓶颈，因为线程对象的创建和销毁需要JVM频繁的处理，如果执行时间很短，可能花在创建和销毁线程对象上的时间将大于真正执行任务的时间，若这样，系统性能将大大降低。&lt;br&gt;\n因此JDK5起提供了线程池的支持，主要作用则时支持高并发的访问处理，并且可以将线程对象进行复用。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Executor与ThreadPoolExecutor的使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;d7I_i0o7n6s&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/d7I_i0o7n6s/&#34;},{&#34;name&#34;:&#34;Executor&#34;,&#34;slug&#34;:&#34;DoYui3pL6kt&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/DoYui3pL6kt/&#34;},{&#34;name&#34;:&#34;ThreadPoolExecutor&#34;,&#34;slug&#34;:&#34;ddjKRmDPaiw&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ddjKRmDPaiw/&#34;}],&#34;date&#34;:&#34;2018-05-05 21:30:11&#34;,&#34;dateFormat&#34;:&#34;2018-05-05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/Executor-ThreadPoolExecutor/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:381000,&#34;words&#34;:1674,&#34;minutes&#34;:7},&#34;description&#34;:&#34;在开发服务端软件项目时，经常需要处理时间很短而数目却非常巨大的请求，如果为每一个请求创建一个新的线程，会导致性能上的瓶颈，因为线程对象的创建和销毁需要JVM频繁的处理，如果执行时间很短，可能花在创建和销毁线程对象上的时间将大于真正执行任务的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-executors\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\nExecutors&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#newcachedthreadpool\&#34;&gt;newCachedThreadPool()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#newcachedthreadpoolthreadfactory-threadfactory\&#34;&gt;newCachedThreadPool(ThreadFactory threadFactory)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#newfixedthreadpoolint-nthreads\&#34;&gt;newFixedThreadPool(int nThreads)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#newfixedthreadpoolint-nthreads-threadfactory-threadfactory\&#34;&gt;newFixedThreadPool(int nThreads, ThreadFactory threadFactory)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A2%9E%E5%8A%A0%E5%AE%9A%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E6%9C%89%E7%95%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0newsinglethreadexecutor\&#34;&gt;增加定制线程功能的有界线程池&lt;br&gt;\nnewSingleThreadExecutor()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#newsinglethreadexecutorthreadfactory-threadfactory\&#34;&gt;newSingleThreadExecutor(ThreadFactory threadFactory)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#threadpoolexecutor%E7%9A%84%E4%BD%BF%E7%94%A8\&#34;&gt;ThreadPoolExecutor的使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Phaser提供动态增减parties(屏障点)计数，这点币CyclicBarrier类操作parties更加方便，通过若干个方法来控制多个线程之间同步运行的效果，还可以实现针对某一个线程取消同步运行的效果，而且支持在指定屏障处等待，在等待时还支持中断或非中断等功能。对线程并发进行分组同步控制时，它比CyclicBarrier类功能更加强大，更建议使用。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;简单示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser(3);\n        Runnable r1 = () -&amp;gt; {\n            System.out.println(Thread.currentThread().getName() + &amp;quot; A1 begin=&amp;quot; + System.currentTimeMillis());\n            phaser.arriveAndAwaitAdvance();\n            System.out.println(Thread.currentThread().getName() + &amp;quot; A1 end=&amp;quot; + System.currentTimeMillis());\n            System.out.println(Thread.currentThread().getName() + &amp;quot; A2 begin=&amp;quot; + System.currentTimeMillis());\n            phaser.arriveAndAwaitAdvance();\n            System.out.println(Thread.currentThread().getName() + &amp;quot; A2 end=&amp;quot; + System.currentTimeMillis());\n        };\n        Runnable r2 = () -&amp;gt; {\n            try {\n                System.out.println(Thread.currentThread().getName() + &amp;quot; A1 begin=&amp;quot; + System.currentTimeMillis());\n                Thread.sleep(2000);\n                phaser.arriveAndAwaitAdvance();\n                System.out.println(Thread.currentThread().getName() + &amp;quot; A1 end=&amp;quot; + System.currentTimeMillis());\n                System.out.println(Thread.currentThread().getName() + &amp;quot; A2 begin=&amp;quot; + System.currentTimeMillis());\n                Thread.sleep(2000);\n                phaser.arriveAndAwaitAdvance();\n                System.out.println(Thread.currentThread().getName() + &amp;quot; A2 end=&amp;quot; + System.currentTimeMillis());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n        new Thread(r1, &amp;quot;A&amp;quot;).start();\n        new Thread(r1, &amp;quot;B&amp;quot;).start();\n        new Thread(r2, &amp;quot;C&amp;quot;).start();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;A A1 begin=1525358412447\nB A1 begin=1525358412447\nC A1 begin=1525358412447\nC A1 end=1525358414450\nC A2 begin=1525358414451\nB A1 end=1525358414451\nA A1 end=1525358414451\nB A2 begin=1525358414451\nA A2 begin=1525358414451\nC A2 end=1525358416456\nB A2 end=1525358416456\nA A2 end=1525358416456\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;移除代码中的18-21行的内容&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// System.out.println(Thread.currentThread().getName() + &amp;quot; A2 begin=&amp;quot; + System.currentTimeMillis());\n// Thread.sleep(2000);\n// phaser.arriveAndAwaitAdvance();\n// System.out.println(Thread.currentThread().getName() + &amp;quot; A2 end=&amp;quot; + System.currentTimeMillis());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;br&gt;\n[image]&lt;br&gt;\n&lt;img src=\&#34;/images/image01.jpg\&#34; alt=\&#34;运行结果\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n从运行结果看，因为某一个线程达到屏障点，导致另外两个线程一直等待。&lt;/p&gt;\n&lt;p&gt;为了解决上面的问题，不再继续向下一个屏障点执行的线程调用&lt;br&gt;\narriveAndDeregister()，可以实现将当前线程退出该屏障，并且将屏障点(parties)值减1.&lt;br&gt;\n将上述Runnable r2代码改为：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Runnable r2 = () -&amp;gt; {\n    try {\n        System.out.println(Thread.currentThread().getName() + &amp;quot; A1 begin=&amp;quot; + System.currentTimeMillis());\n        Thread.sleep(2000);\n        System.out.println(&amp;quot;A:&amp;quot; + phaser.getRegisteredParties());\n        phaser.arriveAndDeregister();\n        System.out.println(&amp;quot;B:&amp;quot; + phaser.getRegisteredParties());\n        System.out.println(Thread.currentThread().getName() + &amp;quot; A1 end=&amp;quot; + System.currentTimeMillis());\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;A A1 begin=1525359548165\nC A1 begin=1525359548165\nB A1 begin=1525359548165\nA:3\nB:2\nC A1 end=1525359550168\nA A1 end=1525359550168\nB A1 end=1525359550168\nA A2 begin=1525359550169\nB A2 begin=1525359550169\nB A2 end=1525359550169\nA A2 end=1525359550169\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;arriveAndAwaitAdvance()当前线程已经到达屏障，在此等待条件满足后继续向后执行\narriveAndDeregister()当前线程退出该屏障，并且将屏障点(parties)值减1\ngetRegisteredParties()当前phaser注册的屏障点数\nregister()没执行一次该方法就动态添加一个parties值\ngetPhase()获取已经到达第几个屏障\nonAdvance()通过新的屏障时调用\n// 该方法返回true表示不等待类，Phaser呈无效/销毁状态\n// 该方法返回false表示Phaser继续工作\nbulkRegister()批量增加parties值\ngetArrivedParties()获取已经被使用的parties个数\ngetUnarrivedParties()获取未被使用的parties个数\narrive()使到达屏障的线程数加1，且当前线程不在屏障处等待，直接向下面的代码继续运行，并且Phaser到达的线程达到parties时会重置计数\nawaitAdvance(int phase)如果传入的phase值和当前getPhase()方法返回值一样，则在屏障处等待，否则继续向下运行。类似于旁观者的作用，当观察的条件满足了就等待(旁观)，如果条件不满足，则程序向下继续运行\nawaitAdvance(int phase)不可中断\nawaitAdvanceInterruptibly(int phase)可中断的\nawaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)指定最大的等待时间\nforceTermination()是Phaser对象的屏障功能失效，并且处于屏障处等待的线程继续执行，并不抛出一场\nisTerminated()判断Phaser对象是否已经呈销毁状态\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;Phaser&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Phaser提供动态增减parties(屏障点)计数，这点币CyclicBarrier类操作parties更加方便，通过若干个方法来控制多个线程之间同步运行的效果，还可以实现针对某一个线程取消同步运行的效果，而且支持在指定屏障处等待，在等待时还支持中断或非中断等功能。对线程并发进行分组同步控制时，它比CyclicBarrier类功能更加强大，更建议使用。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Phaser的使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;Phaser&#34;,&#34;slug&#34;:&#34;3GfpM8L9B0d&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/3GfpM8L9B0d/&#34;}],&#34;date&#34;:&#34;2018-05-03 21:14:42&#34;,&#34;dateFormat&#34;:&#34;2018-05-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/Phaser/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:256000,&#34;words&#34;:945,&#34;minutes&#34;:5},&#34;description&#34;:&#34;Phaser提供动态增减parties(屏障点)计数，这点币CyclicBarrier类操作parties更加方便，通过若干个方法来控制多个线程之间同步运行的效果，还可以实现针对某一个线程取消同步运行的效果，而且支持在指定屏障处等待，在等待...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;CountDownLatch类可以实现两种角色的线程等待对方的效果；&lt;br&gt;\nCyclicBarrier类可以使同类现成互相等待达到同步的效果；&lt;br&gt;\n这两个类可以更加完善的实现现成对象之间的同步性，对线程对象执行的轨迹控制更加方便。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;countdownlatch的使用\&#34;&gt;CountDownLatch的使用&lt;/h1&gt;\n&lt;p&gt;它所提供的功能是判断count计数不为0时则当前线程呈wait状态，也就是屏障处等待。&lt;br&gt;\n它也是一个同步功能的辅助类，使用效果是给定一个计数，当使用这个CountDownLatch类的线程计数不为0时，则呈wait状态，如果为0时则继续运行。&lt;br&gt;\n实现等待与继续运行的效果分别需要使用await()和countDown()方法来进行。调用await()方法时判断计数是否为0，如果不为0则呈等待状态，其他线程可以调用countDown()方法将计数减1，当计数减到0时，呈等待状态的线程继续运行。&lt;br&gt;\n这里还有一个问题是它的计数是无法被重置的，仅仅是减法操作。&lt;/p&gt;\n&lt;p&gt;简单示例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) throws Exception {\n        CountDownLatch latch = new CountDownLatch(1);\n        new TestThread(latch).start();\n        Thread.sleep(2000);\n        System.out.println(&amp;quot;XX&amp;quot;);\n        latch.countDown();\n    }\n}\nclass TestThread extends Thread {\n    private CountDownLatch latch;\n    public TestThread(CountDownLatch latch) {\n        this.latch = latch;\n    }\n    @Override\n    public void run() {\n        try {\n            System.out.println(&amp;quot;A&amp;quot;);\n            latch.await();\n            System.out.println(&amp;quot;B&amp;quot;);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;A\nXX\nB\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;await(long timeout, TimeUnit unit)可设置最大等待时间\ngetCount()获取当前的计数个数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;cyclicbarrier的使用\&#34;&gt;CyclicBarrier的使用&lt;/h1&gt;\n&lt;p&gt;它不进有CountDownLatch所具有的功能，还可以实现屏障等待的功能，也就是阶段性同步，它在使用上的意义在于可以循环的实现线程要一起做任务的目标，而不是像CountDownLatch一样，仅仅支持一次线程与同步点阻塞的特性。&lt;br&gt;\n它也是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点，这些线程必须实时的互相等待，同时它的公共屏障点可以重用，所以类名中包含Cyclic一词。&lt;/p&gt;\n&lt;p&gt;简单示例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) throws Exception {\n        CyclicBarrier cb = new CyclicBarrier(5, new Runnable() {\n            @Override public void run() {\n                System.out.println(&amp;quot;都到了&amp;quot;);\n            }\n        });\n        for (int i = 0; i &amp;lt; 5; i ++) {\n            new TestThread(cb).start();\n        }\n    }\n}\nclass TestThread extends Thread {\n    private CyclicBarrier cb;\n    public TestThread(CyclicBarrier cb) {\n        this.cb = cb;\n    }\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(((int) Math.random()) * 1000);\n            System.out.println(Thread.currentThread().getName() + &amp;quot;到了，time=&amp;quot; + System.currentTimeMillis());\n            cb.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Thread-0到了，time=1525274424626\nThread-4到了，time=1525274424627\nThread-2到了，time=1525274424626\nThread-1到了，time=1525274424627\nThread-3到了，time=1525274424627\n都到了\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里演示的时线程个数等于屏障个数的情况，&lt;br&gt;\n下面示例线程数大于屏障个数时，分批处理：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) throws Exception {\n        CyclicBarrier cb = new CyclicBarrier(2, new Runnable() {\n            @Override public void run() {\n                System.out.println(&amp;quot;都到了&amp;quot;);\n            }\n        });\n        for (int i = 0; i &amp;lt; 4; i ++) {\n            new TestThread(cb).start();\n            Thread.sleep(500);\n        }\n    }\n}\nclass TestThread extends Thread {\n    private CyclicBarrier cb;\n    public TestThread(CyclicBarrier cb) {\n        this.cb = cb;\n    }\n    @Override\n    public void run() {\n        try {\n            System.out.println(Thread.currentThread().getName() + &amp;quot;到了，等待凑齐两个，time=&amp;quot; + System.currentTimeMillis());\n            cb.await();\n            System.out.println(Thread.currentThread().getName() + &amp;quot;已经凑齐两个，time=&amp;quot; + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Thread-0到了，等待凑齐两个，time=1525274766393\nThread-1到了，等待凑齐两个，time=1525274766895\n都到了\nThread-1已经凑齐两个，time=1525274766896\nThread-0已经凑齐两个，time=1525274766896\nThread-2到了，等待凑齐两个，time=1525274767398\nThread-3到了，等待凑齐两个，time=1525274767901\n都到了\nThread-3已经凑齐两个，time=1525274767901\nThread-2已经凑齐两个，time=1525274767902\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;getParties()取得屏障点个数\ngetNumberWaiting()获取当前有几个线程已经达到屏障点\nisBroken()查询此屏障是否处于损坏状态\n这里需要注意的是CyclicBarrier对于线程的中断interrupte处理会使用全有或者全无的破坏模型\n意思是如果一个线程处于中断或超时提前离开屏障点，其他所有屏障点等待的线程均会跑出BrokenBarrierException或者InterruptedException，并且离开屏障点。\nawait(long timeout, TimeUnit unit)指定在屏障点的最大等待时间，超时将抛出TimeoutException\nreset()重置屏障\n处于屏障点等待的线程将抛出BrokenBarrierException\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;CountDownLatch-And-CyclicBarrier&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;CountDownLatch类可以实现两种角色的线程等待对方的效果；&lt;br&gt;\nCyclicBarrier类可以使同类现成互相等待达到同步的效果；&lt;br&gt;\n这两个类可以更加完善的实现现成对象之间的同步性，对线程对象执行的轨迹控制更加方便。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;CountDownLatch和CyclicBarrier&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;CountDownLatch&#34;,&#34;slug&#34;:&#34;4BICs7VscOW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4BICs7VscOW/&#34;},{&#34;name&#34;:&#34;CyclicBarrier&#34;,&#34;slug&#34;:&#34;traRp3-pXh3&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/traRp3-pXh3/&#34;}],&#34;date&#34;:&#34;2018-05-02 22:06:49&#34;,&#34;dateFormat&#34;:&#34;2018-05-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/CountDownLatch-And-CyclicBarrier/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:278000,&#34;words&#34;:1091,&#34;minutes&#34;:5},&#34;description&#34;:&#34;CountDownLatch类可以实现两种角色的线程等待对方的效果；\nCyclicBarrier类可以使同类现成互相等待达到同步的效果；\n这两个类可以更加完善的实现现成对象之间的同步性，对线程对象执行的轨迹控制更加方便。\n\nCountDow...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#countdownlatch%E7%9A%84%E4%BD%BF%E7%94%A8\&#34;&gt;CountDownLatch的使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cyclicbarrier%E7%9A%84%E4%BD%BF%E7%94%A8\&#34;&gt;CyclicBarrier的使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;类Semaphore的主要作用是限制并发执行的线程数，它具有synchronized所不具有的强大功能，比如等待获取许可的同时可以加入等待时间，还有尝试是否可以持有锁等这类扩展功能，可以说它是强有力的控制并发线程个数的解决方案之一。&lt;br&gt;\nExchanger是线程间传输数据的方式之一，而且在传输数据类型上没有任何限制。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-semaphore\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\nSemaphore&lt;/h1&gt;\n&lt;p&gt;Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。&lt;/p&gt;\n&lt;p&gt;构造函数&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public Semaphore(int permits)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中permits指同时运行的线程数量&lt;br&gt;\n可通过控制构造函数的permits，控制并发执行的线程数。&lt;/p&gt;\n&lt;p&gt;单线程示例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(1);\n        Single single = new Single(semaphore);\n        for (int i = 0; i &amp;lt; 3; i ++) {\n            new TestThread(&amp;quot;Test-&amp;quot; + i, single).start();;\n        }\n    }\n}\nclass TestThread extends Thread {\n    private Single single;\n    public TestThread(String name, Single single) {\n        super(name);\n        this.single = single;\n    }\n    @Override\n    public void run() {\n        single.test();\n    }\n    \n}\nclass Single {\n    private Semaphore semaphore;\n    public Single(Semaphore semaphore) {\n        this.semaphore = semaphore;\n    }\n    public void test() {\n        try {\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName() + &amp;quot; start at &amp;quot; + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + &amp;quot; stop at &amp;quot; + System.currentTimeMillis());\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Test-0 start at 1524806263164\nTest-0 stop at 1524806264166\nTest-2 start at 1524806264166\nTest-2 stop at 1524806265167\nTest-1 start at 1524806265167\nTest-1 stop at 1524806266167\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;acquire(int permits)还可以每次调用获取permits个许可。\nacquireUninterruptibly()方法的作用是使进入等待许可的线程，不允许被中断。\navailablePermits()返回当前可用的许可数量\ndrainPermits()获取并返回当前可用的许可数量，并将可用许可数置0\ngetQueueLength()获取等待许可的线程数\nhasQueuedThreads()判断是否还有线程在等待这个许可\ntryAcquire()尝试获取一个许可，无阻塞\ntryAcquire(int permits)尝试获取permits个许可，无阻塞\ntryAcquire(long timeout, TimeUnit unit)在指定时间内尝试获取一个许可以\ntryAcquire(int permits, long timeout, TimeUnit unit)在指定时间内尝试获取permits个许可以\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该类还支持公平和非公平许可：默认非公平&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public Semaphore(int permits, boolean fair)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注：Semaphore并不能保证线程安全性，因此还是有可能会出现多个线程共同访问实例变量，导致出现脏数据的情况。&lt;/strong&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;exchanger\&#34;&gt;Exchanger&lt;/h1&gt;\n&lt;p&gt;Exchanger的功能可以使2个线程之间传输数据，它比生产者/消费者模式产生的wait/notify要更加方便。&lt;/p&gt;\n&lt;p&gt;代码示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class App {\n    public static void main(String[] args) {\n        Exchanger&amp;lt;String&amp;gt; exchanger = new Exchanger&amp;lt;&amp;gt;();\n        Single single = new Single(exchanger);\n        for (int i = 0; i &amp;lt; 2; i ++) {\n            new TestThread(&amp;quot;Test-&amp;quot; + i, single).start();;\n        }\n    }\n}\nclass TestThread extends Thread {\n    private Single single;\n    public TestThread(String name, Single single) {\n        super(name);\n        this.single = single;\n    }\n    @Override\n    public void run() {\n        single.test(Thread.currentThread().getName());\n    }\n    \n}\nclass Single {\n    private Exchanger&amp;lt;String&amp;gt; exchanger;\n    public Single(Exchanger&amp;lt;String&amp;gt; exchanger) {\n        this.exchanger = exchanger;\n    }\n    public void test(String s) {\n        try {\n            System.out.println(&amp;quot;send=&amp;quot; + s + &amp;quot; and receive=&amp;quot; + exchanger.exchange(s));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;send=Test-0 and receive=Test-1\nsend=Test-1 and receive=Test-0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;方法介绍&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;exchange(V x, long timeout, TimeUnit unit) 指定时间内没有其他线程获取数据，则出现超时异常\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;Semaphore-and-Exchanger&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;类Semaphore的主要作用是限制并发执行的线程数，它具有synchronized所不具有的强大功能，比如等待获取许可的同时可以加入等待时间，还有尝试是否可以持有锁等这类扩展功能，可以说它是强有力的控制并发线程个数的解决方案之一。&lt;br&gt;\nExchanger是线程间传输数据的方式之一，而且在传输数据类型上没有任何限制。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Semaphore和Exchanger&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;Semaphore&#34;,&#34;slug&#34;:&#34;-57KzEC9uby&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/-57KzEC9uby/&#34;},{&#34;name&#34;:&#34;Exchanger&#34;,&#34;slug&#34;:&#34;_RX3mTOP6xp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/_RX3mTOP6xp/&#34;}],&#34;date&#34;:&#34;2018-04-27 12:56:49&#34;,&#34;dateFormat&#34;:&#34;2018-04-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/Semaphore-and-Exchanger/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:215000,&#34;words&#34;:796,&#34;minutes&#34;:4},&#34;description&#34;:&#34;类Semaphore的主要作用是限制并发执行的线程数，它具有synchronized所不具有的强大功能，比如等待获取许可的同时可以加入等待时间，还有尝试是否可以持有锁等这类扩展功能，可以说它是强有力的控制并发线程个数的解决方案之一。\nExc...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-semaphore\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\nSemaphore&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#exchanger\&#34;&gt;Exchanger&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;IDEA快捷键，Mac、Windows和Linux对照&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;Remember these Shortcuts&lt;br&gt;\n记住这些快捷键&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Smart code completion&lt;/td&gt;\n&lt;td&gt;智能代码补全&lt;/td&gt;\n&lt;td&gt;⌃⇧Space&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Search everywhere&lt;/td&gt;\n&lt;td&gt;搜索所有文件&lt;/td&gt;\n&lt;td&gt;Double⇧&lt;/td&gt;\n&lt;td&gt;Double Shift&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Show intention actions and quick-fixes&lt;/td&gt;\n&lt;td&gt;显示意向操作和快捷修复&lt;/td&gt;\n&lt;td&gt;⌘↩︎&lt;/td&gt;\n&lt;td&gt;Alt + Enter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Generate code&lt;/td&gt;\n&lt;td&gt;生成代码&lt;/td&gt;\n&lt;td&gt;⌘N,⌃↩︎&lt;/td&gt;\n&lt;td&gt;Alt + Ins&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extend selection&lt;/td&gt;\n&lt;td&gt;展开选择&lt;/td&gt;\n&lt;td&gt;⌥⌘↑&lt;/td&gt;\n&lt;td&gt;Ctrl + W&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Shrink selection&lt;/td&gt;\n&lt;td&gt;收起选择&lt;/td&gt;\n&lt;td&gt;⌥⌘↓&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + W&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Recent files popup&lt;/td&gt;\n&lt;td&gt;最近打开的文件&lt;/td&gt;\n&lt;td&gt;⌘E&lt;/td&gt;\n&lt;td&gt;Ctrl + E&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Rename&lt;/td&gt;\n&lt;td&gt;重命名&lt;/td&gt;\n&lt;td&gt;⇧F6&lt;/td&gt;\n&lt;td&gt;Shift + F6&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;General&lt;br&gt;\n常规&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Open corresponding tool window&lt;/td&gt;\n&lt;td&gt;打开相应的工具窗口&lt;/td&gt;\n&lt;td&gt;⌘0…⌘9&lt;/td&gt;\n&lt;td&gt;Alt + #[0-9]&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Save all&lt;/td&gt;\n&lt;td&gt;保存所有&lt;/td&gt;\n&lt;td&gt;⌘S&lt;/td&gt;\n&lt;td&gt;Ctrl+S&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Synchronize&lt;/td&gt;\n&lt;td&gt;同步&lt;/td&gt;\n&lt;td&gt;⌘⌥Y&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+Y&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Toggle maximizing editor&lt;/td&gt;\n&lt;td&gt;切换最大化编辑窗口&lt;/td&gt;\n&lt;td&gt;⌘⇧F12&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + F12&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Inspect current file with current profile&lt;/td&gt;\n&lt;td&gt;用当前配置文件检查当前文件&lt;/td&gt;\n&lt;td&gt;⌥⇧I&lt;/td&gt;\n&lt;td&gt;Alt+Shift+I&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Quick switch current scheme&lt;/td&gt;\n&lt;td&gt;快速切换当前方案&lt;/td&gt;\n&lt;td&gt;⌃§,⌃&lt;code&gt;| Ctrl + BackQuote (&lt;/code&gt;)&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Open Settings dialog&lt;/td&gt;\n&lt;td&gt;打开设置弹框&lt;/td&gt;\n&lt;td&gt;⌘,&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + S&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Open Project Structure dialog&lt;/td&gt;\n&lt;td&gt;打开项目结构弹框&lt;/td&gt;\n&lt;td&gt;⌘;&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + Shift + S&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Find Action&lt;/td&gt;\n&lt;td&gt;找到行动&lt;/td&gt;\n&lt;td&gt;⌘⇧A&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + A&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Debugging&lt;br&gt;\n调试&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Step over / into&lt;/td&gt;\n&lt;td&gt;单步退出或进入&lt;/td&gt;\n&lt;td&gt;F8 / F7&lt;/td&gt;\n&lt;td&gt;F8/F7&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Smart step into / Step out&lt;/td&gt;\n&lt;td&gt;智能单步进入或退出&lt;/td&gt;\n&lt;td&gt;⇧F7/⇧F8&lt;/td&gt;\n&lt;td&gt;Shift+F7/Shift+ F8&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Run to cursor&lt;/td&gt;\n&lt;td&gt;运行到下一行&lt;/td&gt;\n&lt;td&gt;⌥F9&lt;/td&gt;\n&lt;td&gt;Alt+F9&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Evaluate expression&lt;/td&gt;\n&lt;td&gt;计算表达式&lt;/td&gt;\n&lt;td&gt;⌥F8&lt;/td&gt;\n&lt;td&gt;Alt+F8&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Toggle breakpoint&lt;/td&gt;\n&lt;td&gt;执行到下一个断点&lt;/td&gt;\n&lt;td&gt;⌘F8&lt;/td&gt;\n&lt;td&gt;Ctrl + F8&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;View breakpoints&lt;/td&gt;\n&lt;td&gt;查看所有断点&lt;/td&gt;\n&lt;td&gt;⌘⇧F8&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + F8&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Search / Replace&lt;br&gt;\n查找/替换&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Search everywhere&lt;/td&gt;\n&lt;td&gt;搜索所有文件&lt;/td&gt;\n&lt;td&gt;Double⇧&lt;/td&gt;\n&lt;td&gt;Double Shift&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Find&lt;/td&gt;\n&lt;td&gt;查找&lt;/td&gt;\n&lt;td&gt;⌘F&lt;/td&gt;\n&lt;td&gt;Ctrl + F&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Find next / previous&lt;/td&gt;\n&lt;td&gt;查找下一个/上一个&lt;/td&gt;\n&lt;td&gt;⌘G/⌘⇧G&lt;/td&gt;\n&lt;td&gt;F3/Shift+F3&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Replace&lt;/td&gt;\n&lt;td&gt;替换&lt;/td&gt;\n&lt;td&gt;⌘R&lt;/td&gt;\n&lt;td&gt;Ctrl+R&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Find in path&lt;/td&gt;\n&lt;td&gt;在指定路径查找&lt;/td&gt;\n&lt;td&gt;⌘⇧F&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+F&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Replace in path&lt;/td&gt;\n&lt;td&gt;在指定路径替换&lt;/td&gt;\n&lt;td&gt;⌘⇧R&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+R&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Select next occurrence&lt;/td&gt;\n&lt;td&gt;选择下一个发生&lt;/td&gt;\n&lt;td&gt;⌃G&lt;/td&gt;\n&lt;td&gt;Alt+J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Select all occurrences&lt;/td&gt;\n&lt;td&gt;选择所有的发生&lt;/td&gt;\n&lt;td&gt;⌃⇧G&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+Shift+J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Unselect occurrence&lt;/td&gt;\n&lt;td&gt;取消选择&lt;/td&gt;\n&lt;td&gt;⌃G&lt;/td&gt;\n&lt;td&gt;Alt+Shift+J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Editing&lt;br&gt;\n编辑&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Basic code completion&lt;/td&gt;\n&lt;td&gt;基本代码补全&lt;/td&gt;\n&lt;td&gt;⌃Space&lt;/td&gt;\n&lt;td&gt;Ctrl + Space&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Smart code completion&lt;/td&gt;\n&lt;td&gt;智能代码补全&lt;/td&gt;\n&lt;td&gt;⌃⇧Space&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Complete statement&lt;/td&gt;\n&lt;td&gt;完整的声明&lt;/td&gt;\n&lt;td&gt;⌘⇧↩︎&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Parameter info (within method call arguments)&lt;/td&gt;\n&lt;td&gt;参数说明-在方法调用参数中&lt;/td&gt;\n&lt;td&gt;⌘P&lt;/td&gt;\n&lt;td&gt;Ctrl+P&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Quick documentation lookup&lt;/td&gt;\n&lt;td&gt;快速查找文档&lt;/td&gt;\n&lt;td&gt;⌃J,&lt;/td&gt;\n&lt;td&gt;Ctrl+Q&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;External Doc&lt;/td&gt;\n&lt;td&gt;外部文档&lt;/td&gt;\n&lt;td&gt;⌘F1&lt;/td&gt;\n&lt;td&gt;Shift + F1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Brief Info&lt;/td&gt;\n&lt;td&gt;简要信息&lt;/td&gt;\n&lt;td&gt;⌘+mouse&lt;/td&gt;\n&lt;td&gt;Ctrl + mouse&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Show descriptions of error at caret&lt;/td&gt;\n&lt;td&gt;在插入符号处显示错误的描述&lt;/td&gt;\n&lt;td&gt;⌘F1&lt;/td&gt;\n&lt;td&gt;Ctrl + F1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Generate code...&lt;/td&gt;\n&lt;td&gt;生成代码&lt;/td&gt;\n&lt;td&gt;⌘N,⌃↩︎&lt;/td&gt;\n&lt;td&gt;Alt + Insert&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Override methods&lt;/td&gt;\n&lt;td&gt;覆盖方法&lt;/td&gt;\n&lt;td&gt;⌃O&lt;/td&gt;\n&lt;td&gt;Ctrl + O&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Implement methods&lt;/td&gt;\n&lt;td&gt;实现方法&lt;/td&gt;\n&lt;td&gt;⌃I&lt;/td&gt;\n&lt;td&gt;Ctrl + I&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Surround with...&lt;/td&gt;\n&lt;td&gt;被XXX包含&lt;/td&gt;\n&lt;td&gt;⌘⌥T&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + T&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Comment / uncomment with line comment&lt;/td&gt;\n&lt;td&gt;注释/取消行注释&lt;/td&gt;\n&lt;td&gt;⌘/&lt;/td&gt;\n&lt;td&gt;Ctrl + /&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Comment / uncomment with block comment&lt;/td&gt;\n&lt;td&gt;注释/取消块注释&lt;/td&gt;\n&lt;td&gt;⌘⌥/&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+/&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extend selection&lt;/td&gt;\n&lt;td&gt;展开选择&lt;/td&gt;\n&lt;td&gt;⌥↑&lt;/td&gt;\n&lt;td&gt;Ctrl + W&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Shrink selection&lt;/td&gt;\n&lt;td&gt;收起选择&lt;/td&gt;\n&lt;td&gt;⌥↓&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + W&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Context info&lt;/td&gt;\n&lt;td&gt;上下文信息&lt;/td&gt;\n&lt;td&gt;⌃⇧Q&lt;/td&gt;\n&lt;td&gt;Alt + Q&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Show intention actions and quick-fixes&lt;/td&gt;\n&lt;td&gt;显示意向操作和快捷修复&lt;/td&gt;\n&lt;td&gt;⌘↩︎&lt;/td&gt;\n&lt;td&gt;Alt + Enter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Reformat code&lt;/td&gt;\n&lt;td&gt;重新格式化代码&lt;/td&gt;\n&lt;td&gt;⌘⌥L&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + L&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Optimize imports&lt;/td&gt;\n&lt;td&gt;优化导入&lt;/td&gt;\n&lt;td&gt;⌃⌥O&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + O&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Auto-indent line(s)&lt;/td&gt;\n&lt;td&gt;自动缩进&lt;/td&gt;\n&lt;td&gt;⌃⌥I&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + I&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Indent / unindent selected lines&lt;/td&gt;\n&lt;td&gt;增加/减小缩进&lt;/td&gt;\n&lt;td&gt;⇥/⇧⇥&lt;/td&gt;\n&lt;td&gt;Tab / Shift + Tab&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Cut current line to clipboard&lt;/td&gt;\n&lt;td&gt;剪切当前行&lt;/td&gt;\n&lt;td&gt;⌘X&lt;/td&gt;\n&lt;td&gt;Ctrl + X , Shift + Delete&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Copy current line to clipboard&lt;/td&gt;\n&lt;td&gt;复制当前行&lt;/td&gt;\n&lt;td&gt;⌘C&lt;/td&gt;\n&lt;td&gt;Ctrl + C , Ctrl + Insert&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Paste from clipboard&lt;/td&gt;\n&lt;td&gt;粘贴&lt;/td&gt;\n&lt;td&gt;⌘V&lt;/td&gt;\n&lt;td&gt;Ctrl + V , Shift + Insert&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Paste from recent buffers...&lt;/td&gt;\n&lt;td&gt;从最近的缓冲区粘贴&lt;/td&gt;\n&lt;td&gt;⌘⇧V&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + V&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Duplicate current line&lt;/td&gt;\n&lt;td&gt;快速复制并粘贴当前行&lt;/td&gt;\n&lt;td&gt;⌘D&lt;/td&gt;\n&lt;td&gt;Ctrl + D&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Delete line at caret&lt;/td&gt;\n&lt;td&gt;删除选中的行&lt;/td&gt;\n&lt;td&gt;⌘⌫&lt;/td&gt;\n&lt;td&gt;Ctrl + Y&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Smart line join&lt;/td&gt;\n&lt;td&gt;智能组合行&lt;/td&gt;\n&lt;td&gt;⌃⇧J&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Smart line split&lt;/td&gt;\n&lt;td&gt;智能拆分行&lt;/td&gt;\n&lt;td&gt;⌘↩︎&lt;/td&gt;\n&lt;td&gt;Ctrl + Enter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Start new line&lt;/td&gt;\n&lt;td&gt;开始新的一行&lt;/td&gt;\n&lt;td&gt;⇧↩︎&lt;/td&gt;\n&lt;td&gt;Shift + Enter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Toggle case for word at caret or selected block&lt;/td&gt;\n&lt;td&gt;在插入符号或选择块上切换单词大小写&lt;/td&gt;\n&lt;td&gt;⌘⇧U&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+U&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Select till code block end / start&lt;/td&gt;\n&lt;td&gt;选择直到代码块的结束/开始&lt;/td&gt;\n&lt;td&gt;⌘⇧]/⌘⇧[&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+]/[&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Delete to word end&lt;/td&gt;\n&lt;td&gt;删除到单词的结尾&lt;/td&gt;\n&lt;td&gt;⌥⌦&lt;/td&gt;\n&lt;td&gt;Ctrl + Delete&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Delete to word start&lt;/td&gt;\n&lt;td&gt;删除到单词的开始&lt;/td&gt;\n&lt;td&gt;⌥⌫&lt;/td&gt;\n&lt;td&gt;Ctrl + Backspace&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Expand / collapse code block&lt;/td&gt;\n&lt;td&gt;展开/折叠代码块&lt;/td&gt;\n&lt;td&gt;⌘+/⌘-&lt;/td&gt;\n&lt;td&gt;Ctrl + NumPad+ / -&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Expand all&lt;/td&gt;\n&lt;td&gt;展开所有&lt;/td&gt;\n&lt;td&gt;⌘⇧+&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + NumPad+&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Collapse all&lt;/td&gt;\n&lt;td&gt;折叠所有&lt;/td&gt;\n&lt;td&gt;⌘⇧-&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + NumPad-&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Close active editor tab&lt;/td&gt;\n&lt;td&gt;关闭活动编辑页&lt;/td&gt;\n&lt;td&gt;⌘W&lt;/td&gt;\n&lt;td&gt;Ctrl + F4&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Refactoring&lt;br&gt;\n重构&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Copy&lt;/td&gt;\n&lt;td&gt;复制&lt;/td&gt;\n&lt;td&gt;F5&lt;/td&gt;\n&lt;td&gt;F5&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Move&lt;/td&gt;\n&lt;td&gt;移动&lt;/td&gt;\n&lt;td&gt;F6&lt;/td&gt;\n&lt;td&gt;F6&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Safe Delete&lt;/td&gt;\n&lt;td&gt;安全删除&lt;/td&gt;\n&lt;td&gt;⌘⌫&lt;/td&gt;\n&lt;td&gt;Alt + Delete&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Rename&lt;/td&gt;\n&lt;td&gt;重命名&lt;/td&gt;\n&lt;td&gt;⇧F6&lt;/td&gt;\n&lt;td&gt;Shift + F6&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Refactor this&lt;/td&gt;\n&lt;td&gt;重构当前&lt;/td&gt;\n&lt;td&gt;⌃T&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+Shift+T&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Change Signature&lt;/td&gt;\n&lt;td&gt;更改签名&lt;/td&gt;\n&lt;td&gt;⌘F6&lt;/td&gt;\n&lt;td&gt;Ctrl + F6&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Inline&lt;/td&gt;\n&lt;td&gt;内联&lt;/td&gt;\n&lt;td&gt;⌘⌥N&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+N&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extract Method&lt;/td&gt;\n&lt;td&gt;提取方法&lt;/td&gt;\n&lt;td&gt;⌘⌥M&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + M&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extract Variable&lt;/td&gt;\n&lt;td&gt;提取变量&lt;/td&gt;\n&lt;td&gt;⌘⌥V&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + V&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extract Field&lt;/td&gt;\n&lt;td&gt;提取自断&lt;/td&gt;\n&lt;td&gt;⌘⌥F&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+F&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extract Constant&lt;/td&gt;\n&lt;td&gt;提取常量&lt;/td&gt;\n&lt;td&gt;⌘⌥C&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+C&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Extract Parameter&lt;/td&gt;\n&lt;td&gt;提取参数&lt;/td&gt;\n&lt;td&gt;⌘⌥P&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+P&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Navigation&lt;br&gt;\n导航&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to class&lt;/td&gt;\n&lt;td&gt;去到到某个类&lt;/td&gt;\n&lt;td&gt;⌘O&lt;/td&gt;\n&lt;td&gt;Ctrl + N&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to file&lt;/td&gt;\n&lt;td&gt;去到到某个文件&lt;/td&gt;\n&lt;td&gt;⌘⇧O&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+N&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to symbol&lt;/td&gt;\n&lt;td&gt;去到某个符号&lt;/td&gt;\n&lt;td&gt;⌘⌥O&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+Shift+N&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to next / previous editor tab&lt;/td&gt;\n&lt;td&gt;去到前/后一个标签页&lt;/td&gt;\n&lt;td&gt;⌃←/⌃→&lt;/td&gt;\n&lt;td&gt;Alt + Right/Left&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go back to previous tool window&lt;/td&gt;\n&lt;td&gt;返回前一个工具窗口&lt;/td&gt;\n&lt;td&gt;F12&lt;/td&gt;\n&lt;td&gt;Alt + Right/Left&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to editor (from tool window)&lt;/td&gt;\n&lt;td&gt;转到编辑器（从工具窗口）&lt;/td&gt;\n&lt;td&gt;⎋&lt;/td&gt;\n&lt;td&gt;Esc&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Hide active or last active window&lt;/td&gt;\n&lt;td&gt;隐藏活动或上一个活动窗口&lt;/td&gt;\n&lt;td&gt;⇧⎋&lt;/td&gt;\n&lt;td&gt;Shift + Esc&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to line&lt;/td&gt;\n&lt;td&gt;去到某一个行&lt;/td&gt;\n&lt;td&gt;⌘L&lt;/td&gt;\n&lt;td&gt;Ctrl + G&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Recent files popup&lt;/td&gt;\n&lt;td&gt;最近打开的文件&lt;/td&gt;\n&lt;td&gt;⌘E&lt;/td&gt;\n&lt;td&gt;Ctrl + E&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Navigate back / forward&lt;/td&gt;\n&lt;td&gt;导航后退/前进&lt;/td&gt;\n&lt;td&gt;⌘⌥←/→&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + Left/Right&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Navigate to last edit location&lt;/td&gt;\n&lt;td&gt;导航到最后一个编辑的位置&lt;/td&gt;\n&lt;td&gt;⌘⇧⌫&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + Backspace&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Select current file or symbol in any view&lt;/td&gt;\n&lt;td&gt;在任何视图中选择当前文件或符号&lt;/td&gt;\n&lt;td&gt;⌥F1&lt;/td&gt;\n&lt;td&gt;Alt + F1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to declaration&lt;/td&gt;\n&lt;td&gt;去到声明的位置&lt;/td&gt;\n&lt;td&gt;⌘B/⌘Click&lt;/td&gt;\n&lt;td&gt;Ctrl + B , Ctrl + Click&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to implementation(s)&lt;/td&gt;\n&lt;td&gt;去到实现的类&lt;/td&gt;\n&lt;td&gt;⌘⌥B&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + B&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Open quick definition lookup&lt;/td&gt;\n&lt;td&gt;打开快速定义查找&lt;/td&gt;\n&lt;td&gt;⌥Space/⌘Y&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + I&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to type declaration&lt;/td&gt;\n&lt;td&gt;去到类型声明&lt;/td&gt;\n&lt;td&gt;⌃⇧B&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+B&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to super-method / super-class&lt;/td&gt;\n&lt;td&gt;去到父方法/类&lt;/td&gt;\n&lt;td&gt;⌘U&lt;/td&gt;\n&lt;td&gt;Ctrl+U&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to previous / next method&lt;/td&gt;\n&lt;td&gt;去到下一个/上一个方法&lt;/td&gt;\n&lt;td&gt;⌃↑/↓&lt;/td&gt;\n&lt;td&gt;Alt + Up/Down&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Move to code block end / start&lt;/td&gt;\n&lt;td&gt;移动到代码块结束/开始&lt;/td&gt;\n&lt;td&gt;⌘]/⌘[&lt;/td&gt;\n&lt;td&gt;Ctrl + ]/[&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;File structure popup&lt;/td&gt;\n&lt;td&gt;弹出文件结构&lt;/td&gt;\n&lt;td&gt;⌘F12&lt;/td&gt;\n&lt;td&gt;Ctrl + F12&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Type hierarchy&lt;/td&gt;\n&lt;td&gt;类型层次&lt;/td&gt;\n&lt;td&gt;⌃H&lt;/td&gt;\n&lt;td&gt;Ctrl+H&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Method hierarchy&lt;/td&gt;\n&lt;td&gt;方法层次&lt;/td&gt;\n&lt;td&gt;⌘⇧H&lt;/td&gt;\n&lt;td&gt;Ctrl+Shift+H&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Call hierarchy&lt;/td&gt;\n&lt;td&gt;调用层次&lt;/td&gt;\n&lt;td&gt;⌃⌥H&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+H&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Next / previous highlighted error&lt;/td&gt;\n&lt;td&gt;下一个/上一个高亮错误&lt;/td&gt;\n&lt;td&gt;F2/⇧F2&lt;/td&gt;\n&lt;td&gt;F2/Shift+F2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Edit source / View source&lt;/td&gt;\n&lt;td&gt;编辑/查看源文件&lt;/td&gt;\n&lt;td&gt;F4/⌘↓&lt;/td&gt;\n&lt;td&gt;F4 / Ctrl + Enter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Show navigation bar&lt;/td&gt;\n&lt;td&gt;显示导航栏&lt;/td&gt;\n&lt;td&gt;⌥Home&lt;/td&gt;\n&lt;td&gt;Alt + Home&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Toggle bookmark&lt;/td&gt;\n&lt;td&gt;切换书签&lt;/td&gt;\n&lt;td&gt;F3&lt;/td&gt;\n&lt;td&gt;F11&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Toggle bookmark with mnemonic&lt;/td&gt;\n&lt;td&gt;用助记符切换书签&lt;/td&gt;\n&lt;td&gt;⌥F3&lt;/td&gt;\n&lt;td&gt;Ctrl + F11&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Go to numbered bookmark&lt;/td&gt;\n&lt;td&gt;转到对应编号书签&lt;/td&gt;\n&lt;td&gt;⌃0…⌃9&lt;/td&gt;\n&lt;td&gt;Ctrl + #[0-9]&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Show bookmarks&lt;/td&gt;\n&lt;td&gt;显示书签&lt;/td&gt;\n&lt;td&gt;⌘F3&lt;/td&gt;\n&lt;td&gt;Shift + F11&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Compile and Run&lt;br&gt;\n编译和运行&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Make project&lt;/td&gt;\n&lt;td&gt;编译项目&lt;/td&gt;\n&lt;td&gt;⌘F9&lt;/td&gt;\n&lt;td&gt;Ctrl + F9&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Compile selected file, package or module&lt;/td&gt;\n&lt;td&gt;编译选中的文件/包/模块&lt;/td&gt;\n&lt;td&gt;⌘⇧F9&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + F9&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Select configuration and run / debug&lt;/td&gt;\n&lt;td&gt;选中配置并运行/调试&lt;/td&gt;\n&lt;td&gt;⌃⌥R/D&lt;/td&gt;\n&lt;td&gt;Alt + Shift + F10/F9&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Run/Debug&lt;/td&gt;\n&lt;td&gt;运行/调试&lt;/td&gt;\n&lt;td&gt;⌃R/D&lt;/td&gt;\n&lt;td&gt;Shift+F10/F9&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Run context configuration from editor&lt;/td&gt;\n&lt;td&gt;从编辑器运行上下文配置&lt;/td&gt;\n&lt;td&gt;⌃⇧R/D&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + F10&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Usage Search&lt;br&gt;\n用法搜索&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Find usages / Find usages in file&lt;/td&gt;\n&lt;td&gt;查找用法/查找文件中的用法&lt;/td&gt;\n&lt;td&gt;⌥F7/⌘F7&lt;/td&gt;\n&lt;td&gt;Alt + F7 / Ctrl + F7&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Highlight usages in file&lt;/td&gt;\n&lt;td&gt;高亮使用的文件&lt;/td&gt;\n&lt;td&gt;⌘⇧F7&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + F7&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Show usages&lt;/td&gt;\n&lt;td&gt;显示用法&lt;/td&gt;\n&lt;td&gt;⌘⌥F7&lt;/td&gt;\n&lt;td&gt;Ctrl + Alt + F7&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;VCS / Local History&lt;br&gt;\n版本控制/本地历史&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Commit project to VCS&lt;/td&gt;\n&lt;td&gt;提交项目到版本控制&lt;/td&gt;\n&lt;td&gt;⌘K&lt;/td&gt;\n&lt;td&gt;Ctrl + K&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Update project from VCS&lt;/td&gt;\n&lt;td&gt;从版本控制更新项目&lt;/td&gt;\n&lt;td&gt;⌘T&lt;/td&gt;\n&lt;td&gt;Ctrl + T&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Push commits&lt;/td&gt;\n&lt;td&gt;推送提交&lt;/td&gt;\n&lt;td&gt;⌘⇧K&lt;/td&gt;\n&lt;td&gt;Ctrl + Shift + K&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;‘VCS’ quick popup&lt;/td&gt;\n&lt;td&gt;快速弹出版本控制&lt;/td&gt;\n&lt;td&gt;⌃V&lt;/td&gt;\n&lt;td&gt;Alt + BackQuote (`)&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Live Templates&lt;br&gt;\n实时模版&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;En&lt;/th&gt;\n&lt;th&gt;CN&lt;/th&gt;\n&lt;th&gt;MAC&lt;/th&gt;\n&lt;th&gt;Win,Linux&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Surround with Live Template&lt;/td&gt;\n&lt;td&gt;环绕实时模版&lt;/td&gt;\n&lt;td&gt;⌘⌥J&lt;/td&gt;\n&lt;td&gt;Ctrl+Alt+J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Insert Live Template&lt;/td&gt;\n&lt;td&gt;插入实时模版&lt;/td&gt;\n&lt;td&gt;⌘J&lt;/td&gt;\n&lt;td&gt;Ctrl+J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&#34;,&#34;fileName&#34;:&#34;idea-keywords&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;IDEA快捷键，Mac、Windows和Linux对照&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;idea快捷键&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;IDEA&#34;,&#34;slug&#34;:&#34;NC3X30kYTYj&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/NC3X30kYTYj/&#34;},{&#34;name&#34;:&#34;IDEA快捷键&#34;,&#34;slug&#34;:&#34;tpl39zS4jnR&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/tpl39zS4jnR/&#34;}],&#34;date&#34;:&#34;2018-04-23 20:21:10&#34;,&#34;dateFormat&#34;:&#34;2018-04-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/idea-keywords/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:520000,&#34;words&#34;:1791,&#34;minutes&#34;:9},&#34;description&#34;:&#34;IDEA快捷键，Mac、Windows和Linux对照\n\nRemember these Shortcuts\n记住这些快捷键\n\n\n\nEn\nCN\nMAC\nWin,Linux\n\n\n\n\nSmart code completion\n智能代码补全\n⌃⇧...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;随着业务的数据量的不断增大，MySQL数据库的查询统计压力不断增加，不得不将数据的查询和统计功能转移到类似搜索引擎的应用服务器中。&lt;br&gt;\n将数据转存到SolrCloud中，以前将介绍怎么使用Solr实现类似MySQL的基础查询功能。&lt;!-- more --&gt;&lt;/p&gt;\n&lt;p&gt;设计如下数据结构&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; desc call_record;\n+-------------+-------------+------+-----+---------+----------------+\n| Field       | Type        | Null | Key | Default | Extra          |\n+-------------+-------------+------+-----+---------+----------------+\n| id          | int(11)     | NO   | PRI | NULL    | auto_increment |\n| fm          | varchar(64) | YES  |     | NULL    |                |\n| vm          | varchar(11) | YES  | MUL | NULL    |                |\n| tm          | varchar(64) | YES  |     | NULL    |                |\n| status      | int(11)     | YES  |     | NULL    |                |\n| startTime   | datetime    | YES  |     | NULL    |                |\n| endTime     | datetime    | YES  |     | NULL    |                |\n| callMinutes | int(11)     | YES  |     | 0       |                |\n+-------------+-------------+------+-----+---------+----------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面通过给出相关SQL查询统计语句，然后对方翻译成Solr查询语句。&lt;/p&gt;\n&lt;h1 id=\&#34;普通查询\&#34;&gt;普通查询&lt;/h1&gt;\n&lt;p&gt;SQL查询语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;select id,fm,vm,tm,callMinutes from call_record where \n    status=0 and startTime&amp;gt;=&#39;2017-03-31&#39; order by id desc limit 0,10;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询URL：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?\n    q=status:0&amp;amp;fq=startTime[2017-03-31T00:00:00 TO *]&amp;amp;fl=id,fm,vm,tm,callMinutes\n    &amp;amp;sort=id desc&amp;amp;start=0&amp;amp;rows=10&amp;amp;wt=xml&amp;amp;indent=true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;统计\&#34;&gt;统计&lt;/h1&gt;\n&lt;p&gt;SQL查询语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;select sum(callMinutes),avg(callMinutes),max(callMinutes),min(callMinutes) \n    from call_record where status=0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询URL：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?\n    q=status:0&amp;amp;rows=0&amp;amp;wt=xml&amp;amp;indent=true&amp;amp;stats=on&amp;amp;stats.field=callMinutes\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询的结果包括以下统计数据：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;min             最小值\nmax             最大值\nsum             总和\ncount           记录数，也就是多少行记录\nmissing         结果集中，有多少条记录是空值\nsumOfSquares    平方和（x1^2 + x2^2+xn^2）\nmean            平均数（x1+x2+xn）/n\nstddev          标准差\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;in查询\&#34;&gt;IN查询&lt;/h1&gt;\n&lt;p&gt;SQL查询语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;select * from call_record where status in (0,1) order by id desc limit 0,10;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询URL：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?\n    q=(status:0 OR status:1)&amp;amp;fl=id,fm,vm,tm,callMinutes\n    &amp;amp;sort=id desc&amp;amp;start=0&amp;amp;rows=10&amp;amp;wt=xml&amp;amp;indent=true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;字段分组统计次数\&#34;&gt;字段分组统计次数&lt;/h1&gt;\n&lt;p&gt;SQL查询语句:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;select fm,count(callMinutes) from call_record where status=0 group by fm\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询URL-01：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?\n    q=status:0&amp;amp;rows=0&amp;amp;wt=json&amp;amp;indent=true&amp;amp;facet=on&amp;amp;facet.field=fm&amp;amp;facet.limit=-1\n\n注：\n    facet.limit=-1表示查询出所有的记录\n    这个查询查询比较耗费资源不建议键facet.limit设置为-1\n    这里的结果集默认按照count降序排列，还可设置facet.solr=index表示按照fm进行自然排序\n    当然Solr还支持只查询出次数大于10次的记录facet.mincount=10\n    需要查询fm的数量时会相对比较麻烦，只能将所有的结果查询出来；\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询URL-02&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?\n    q=status:0&amp;amp;rows=10&amp;amp;wt=json&amp;amp;indent=true&amp;amp;group=true&amp;amp;group.field=fm&amp;amp;group.limit=1\n\n注：\n    如果对于集群应用时，不能使用group进行查询，结果集会不准确\n    如果自行控制，将需要group的数据存放在同一个分片中时才能使用；\n    不支持结果集排序\n    不支持查询出次数大于10次的记录\n    需要查询fm的数量时比较方便，增加group.ngrouops=true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;字段分组统计\&#34;&gt;字段分组统计&lt;/h1&gt;\n&lt;p&gt;SQL查询语句:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;select fm,count(callMinutes),sum(callMinutes),avg(callMinutes),\n    max(callMinutes),min(callMinutes) from call_record where status=0 group by fm\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Solr查询URL：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;http://SolrCloud01:9002/solr/call_record_shard1_replica1/select?\n    q=status:0&amp;amp;rows=0&amp;amp;wt=json&amp;amp;indent=true&amp;amp;stats=on\n    &amp;amp;stats.field={!tag=piv1}callMinutes\n    &amp;amp;facet=on&amp;amp;facet.pivot={!stats=piv1}fm&amp;amp;facet.mincount=1&amp;amp;facet.limit=10\n\n注：\n    不支持排序\n    需要查询出fm的数量只能查询出全量数据\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;use-solr-to-achieve-MySQL-based-query&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用Solr实现MySQL基础查询&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Solr查询&#34;,&#34;slug&#34;:&#34;Pe8ojV7MtRT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Pe8ojV7MtRT/&#34;},{&#34;name&#34;:&#34;MySQL查询&#34;,&#34;slug&#34;:&#34;TTL8iQbZ6vH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/TTL8iQbZ6vH/&#34;}],&#34;date&#34;:&#34;2017-03-31 13:19:39&#34;,&#34;dateFormat&#34;:&#34;2017-03-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/use-solr-to-achieve-MySQL-based-query/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:237000,&#34;words&#34;:836,&#34;minutes&#34;:4},&#34;description&#34;:&#34;随着业务的数据量的不断增大，MySQL数据库的查询统计压力不断增加，不得不将数据的查询和统计功能转移到类似搜索引擎的应用服务器中。\n将数据转存到SolrCloud中，以前将介绍怎么使用Solr实现类似MySQL的基础查询功能。\n设计如下数据...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9A%E6%9F%A5%E8%AF%A2\&#34;&gt;普通查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1\&#34;&gt;统计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#in%E6%9F%A5%E8%AF%A2\&#34;&gt;IN查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1%E6%AC%A1%E6%95%B0\&#34;&gt;字段分组统计次数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1\&#34;&gt;字段分组统计&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是容易不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对Java中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;懒汉式-非线程安全\&#34;&gt;懒汉式-非线程安全&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Singleton {\n\tprivate static Singleton instance = null;\n\tprivate Singleton() { }\n\tpublic static Singleton getInstance() {\n\t\tif (null == instance)\n\t\t\tinstance = new Singleton();\n\t\treturn instance;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种方法可以实现延时加载，但是有一个致命弱点：&lt;strong&gt;线程不安全&lt;/strong&gt;。如果有两条线程同时调用getInstance()方法，就有很大可能导致重复创建对象。&lt;/p&gt;\n&lt;p&gt;懒汉式-线程安全&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Singleton {\n\tprivate volatile static Singleton instance = null;\n\tprivate Singleton() { }\n\tpublic staitc Singleton getInstance() {\n\t\tif (null == instance) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif (null == instance) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;饿汉式\&#34;&gt;饿汉式&lt;/h1&gt;\n&lt;p&gt;顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Singleton {\n\tprivate static instance = new Singleton();\n\tprivate Singleton() { }\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样做的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载就需要懒汉式单例模式。&lt;/p&gt;\n&lt;h1 id=\&#34;饿汉式-static-final\&#34;&gt;饿汉式-static final&lt;/h1&gt;\n&lt;p&gt;这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Singleton {\n\tprivate static final Singleton instance = new Singleton();\n\tprivate Singleton() { }\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式，单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。&lt;br&gt;\n饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。&lt;/p&gt;\n&lt;h1 id=\&#34;静态内部类\&#34;&gt;静态内部类&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Singleton {\n\tprivate Singleton() { }\n\tprivate static class Holder {\n\t\tprivate static Singleton instance = new Singleton();\n\t}\n\tpublic static Singleton getInstance() {\n\t\treturn Holder.instance;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;\n&lt;h1 id=\&#34;枚举\&#34;&gt;枚举&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public enum Singleton {\n\tINSTANCE;\n\tprivate String name;\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName() {\n\t\tthis.name = name;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，推荐尽可能地使用枚举来实现单例。&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;除枚举外其他的实现都有两个共同的缺点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;都需要额外的工作来实现序列化，否则反序列化时都会创建一个新的实例&lt;/li&gt;\n&lt;li&gt;可能会有人使用反射强行调用我们的私有构造器&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;一般程序而言，一般直接使用饿汉式(静态常量)即可，如果需要懒加载倾向使用静态内部类，如果确实需要反序列化时可以试着使用枚举来实现；&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-singleton&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是容易不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对Java中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;java 单例模式&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;单例模式&#34;,&#34;slug&#34;:&#34;4j90M52FmDg&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4j90M52FmDg/&#34;},{&#34;name&#34;:&#34;Java单例模式&#34;,&#34;slug&#34;:&#34;wymTxeWUzj-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/wymTxeWUzj-/&#34;}],&#34;date&#34;:&#34;2017-03-19 22:08:51&#34;,&#34;dateFormat&#34;:&#34;2017-03-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/java-singleton/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:196000,&#34;words&#34;:868,&#34;minutes&#34;:4},&#34;description&#34;:&#34;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是容易不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对Java中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。\n\n懒汉式-非线程安全\nclas...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%87%92%E6%B1%89%E5%BC%8F-%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\&#34;&gt;懒汉式-非线程安全&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A5%BF%E6%B1%89%E5%BC%8F\&#34;&gt;饿汉式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A5%BF%E6%B1%89%E5%BC%8F-static-final\&#34;&gt;饿汉式-static final&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\&#34;&gt;静态内部类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%9A%E4%B8%BE\&#34;&gt;枚举&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Java语言包括两种同步机制：同步块和volatile变量，都是为了实现线程的安全性。其中volatile同步性相对弱一些，所以相对容易出错；&lt;/p&gt;\n&lt;h1 id=\&#34;-more-volatile变量\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\nvolatile变量&lt;/h1&gt;\n&lt;p&gt;volitile关键字用来修饰字段，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性；&lt;br&gt;\n通过同步锁实现volatile效果示例理解：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class VolatileFeaturesExample {\n\tvolatile long vl = 0L;\n\tpublic void set(long vl) {\n\t\tthis.vl = vl;\n\t}\n\tpublic void getAndIncrement() {\n\t\tvl ++;\n\t}\n\tpublic long get() {\n\t\treturn vl;\n\t}\n}\nclass VolatileFeaturesExample {\n\tlong vl = 0L;\n\tpublic synchronized void set(long vl) {\n\t\tthis.vl = vl;\n\t}\n\tpublic void getAndIncrement() {\n\t\tlong temp = get();\n\t\ttemp += 1L;\n\t\tset(temp);\n\t}\n\tpublic synchronized long get() {\n\t\treturn vl;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;正确使用volatile变量的条件\&#34;&gt;正确使用volatile变量的条件&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;对变量的写操作不依赖于当前值&lt;/li&gt;\n&lt;li&gt;该变量没有包含在具有其他变量的不变式中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;综上所述：被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。&lt;/p&gt;\n&lt;h1 id=\&#34;使用volatile关键字的场景\&#34;&gt;使用volatile关键字的场景&lt;/h1&gt;\n&lt;h2 id=\&#34;状态标记量\&#34;&gt;状态标记量&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;volatile boolean flag;\npublic void setFlag(boolean flag) {\n\tthis.flag = flag;\n}\npublic void doWork() {\n\twhile (!flag) {\n\t\t// do stuff\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;一次性安全发布\&#34;&gt;一次性安全发布&lt;/h2&gt;\n&lt;p&gt;在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。&lt;br&gt;\n实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。示例清单如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Singleton {\n\tprivate volatile static Singleton instance = null;\n\tprivate Singleton() { }\n\tpublic static Singleton getInstance() {\n\t\tif (null == instance) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif (null == instance) \n\t\t\t\t\tinstance = new Singleton();\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里为什么需要instance变量使用volatile关键字修饰，因为变量的创建分为两步：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1、分配对象的内存空间&lt;/li&gt;\n&lt;li&gt;2、初始化对象&lt;/li&gt;\n&lt;li&gt;3、设置变量指向内存地址&lt;br&gt;\n然而在一些JIT编译器上，上述流程中的2、3步可能会被重排序。&lt;br&gt;\n根据Java语言规范，所有线程在执行Java程序时必须要遵守intra-thread semantics。&lt;br&gt;\nintra-thread semantics 保证重排序不会改变单线程内的程序执行过程。换句话说，intra-thread semantics 允许哪些在单线程内，不会改变单线程程序执行结果的重排序。故上述流程的2和3之间虽然重排序了，但这个重排序不会违反intra-thread semantics 。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;开销较低的读-写锁策略\&#34;&gt;开销较低的读－写锁策略&lt;/h2&gt;\n&lt;p&gt;volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。&lt;br&gt;\n然而，如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。代码清单如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class CheeysCounter {\n\tprivate volatile int value;\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic synchronized int increment() {\n\t\treturn value ++;\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器，所以必须使用锁。&lt;br&gt;\n故可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-volatile&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Java语言包括两种同步机制：同步块和volatile变量，都是为了实现线程的安全性。其中volatile同步性相对弱一些，所以相对容易出错；&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;java volatile 关键字理解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;同步机制&#34;,&#34;slug&#34;:&#34;4yySEk_D-Kb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/4yySEk_D-Kb/&#34;},{&#34;name&#34;:&#34;volatile关键字&#34;,&#34;slug&#34;:&#34;N0k2_CQy8le&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/N0k2_CQy8le/&#34;}],&#34;date&#34;:&#34;2017-03-19 15:38:35&#34;,&#34;dateFormat&#34;:&#34;2017-03-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/java-volatile/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:199000,&#34;words&#34;:864,&#34;minutes&#34;:4},&#34;description&#34;:&#34;Java语言包括两种同步机制：同步块和volatile变量，都是为了实现线程的安全性。其中volatile同步性相对弱一些，所以相对容易出错；\n\nvolatile变量\nvolitile关键字用来修饰字段，告知程序任何对该变量的访问均需要从共...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-volatile%E5%8F%98%E9%87%8F\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\nvolatile变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8volatile%E5%8F%98%E9%87%8F%E7%9A%84%E6%9D%A1%E4%BB%B6\&#34;&gt;正确使用volatile变量的条件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%9C%BA%E6%99%AF\&#34;&gt;使用volatile关键字的场景&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8A%B6%E6%80%81%E6%A0%87%E8%AE%B0%E9%87%8F\&#34;&gt;状态标记量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83\&#34;&gt;一次性安全发布&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E9%94%80%E8%BE%83%E4%BD%8E%E7%9A%84%E8%AF%BB-%E5%86%99%E9%94%81%E7%AD%96%E7%95%A5\&#34;&gt;开销较低的读－写锁策略&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;用过Maven的应该都遇到过，当网速不好或者源有问题的时候，Maven的依赖包经常下载失败。 下载失败后在本地仓库对应的文件夹中有一个以.lastUpdated结尾的文件，如果不手动删除这个文件，就不能重新更新依赖，重新下载对应的jar包。&lt;!--more--&gt;&lt;/p&gt;\n&lt;p&gt;一般情况下遇到的时候可能直接手动找到目录删除。&lt;/p&gt;\n&lt;p&gt;当出现很多这样的情况时，一个个找起来也很麻烦。&lt;/p&gt;\n&lt;p&gt;因此本文提供一个小工具，就是一段Java代码，通过这段代码来删除。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.io.File;\n\npublic class CleanMvnFailure {\n\n\tpublic static void main(String[] args) {\n\t\tif (args.length != 1) {\n\t\t\tSystem.out.println(&amp;quot;please input maven factory path:&amp;quot;);\n\t\t}\n\t\tfindAndDelete(new File(args[0]));\n\t}\n\n\tprivate static boolean findAndDelete(File file) {\n\t\tif (!file.exists()) {\n\t\t} else if (file.isFile()) {\n\t\t\tif (file.getName().endsWith(&amp;quot;lastUpdated&amp;quot;)) {\n\t\t\t\tdeleteFile(file.getParentFile());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (file.isDirectory()) {\n\t\t\tFile[] files = file.listFiles();\n\t\t\tfor (File f : files) {\n\t\t\t\tif (findAndDelete(f)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static void deleteFile(File file) {\n\t\tif (!file.exists()) {\n\t\t} else if (file.isFile()) {\n\t\t\tprint(&amp;quot;删除文件:&amp;quot; + file.getAbsolutePath());\n\t\t\tfile.delete();\n\t\t} else if (file.isDirectory()) {\n\t\t\tFile[] files = file.listFiles();\n\t\t\tfor (File f : files) {\n\t\t\t\tdeleteFile(f);\n\t\t\t}\n\t\t\tprint(&amp;quot;删除文件夹:&amp;quot; + file.getAbsolutePath());\n\t\t\tprint(&amp;quot;====================================&amp;quot;);\n\t\t\tfile.delete();\n\t\t}\n\t}\n\n\tprivate static void print(String msg) {\n\t\tSystem.out.println(msg);\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果在工具上运行该段代码，则自行修改传入本地仓库路径的方法；&lt;/p&gt;\n&lt;p&gt;如果在命令行下运行则：&lt;br&gt;\n首先编译java文件：javac CleanMvnFailure.java&lt;br&gt;\n再运行对应的class文件：java CleanMvnFailure &amp;quot;D:\\Program Files\\maven_factory&amp;quot;&lt;br&gt;\n因为路径中带空格，须用引号引起来&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;delete-maven-failure-jar&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;批量删除Maven下载失败的文件夹&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;java&#34;,&#34;slug&#34;:&#34;O7RJpoZ0a7D&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/O7RJpoZ0a7D/&#34;},{&#34;name&#34;:&#34;maven&#34;,&#34;slug&#34;:&#34;rgfrKmU1i-l&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/rgfrKmU1i-l/&#34;}],&#34;date&#34;:&#34;2017-02-23 14:57:31&#34;,&#34;dateFormat&#34;:&#34;2017-02-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/delete-maven-failure-jar/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:101000,&#34;words&#34;:379,&#34;minutes&#34;:2},&#34;description&#34;:&#34;用过Maven的应该都遇到过，当网速不好或者源有问题的时候，Maven的依赖包经常下载失败。 下载失败后在本地仓库对应的文件夹中有一个以.lastUpdated结尾的文件，如果不手动删除这个文件，就不能重新更新依赖，重新下载对应的jar包。...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;单机安装zookeeper\&#34;&gt;单机安装zookeeper&lt;/h2&gt;\n&lt;p&gt;1、下载响应版本的zookeeper&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、解压安装文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;tar -xzvf zookeeper-3.4.6.tar.gz\nmv zookeeper-3.4.6 zookeeper\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!--more--&gt;\n&lt;p&gt;3、配置zoo.cfg&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;cd zookeeper/conf\ncp zoo_sample.cfg zoo.cfg\nvim zoo.cfg\n\ttickTime=2000 \n\tdataDir=/opt/server/zookeeper/data \n\tclientPort=2181\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**tickTime：**这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。&lt;br&gt;\n**dataDir：**Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。&lt;br&gt;\n**clientPort：**这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。&lt;/p&gt;\n&lt;h2 id=\&#34;集群安装zookeeper\&#34;&gt;集群安装zookeeper&lt;/h2&gt;\n&lt;p&gt;1、下载响应版本的zookeeper&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、解压安装文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;tar -xzvf zookeeper-3.4.6.tar.gz\nmv zookeeper-3.4.6 zookeeper\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、配置zoo.cfg&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;cd zookeeper/conf\ncp zoo_sample.cfg zoo.cfg\nvim zoo.cfg\n\ttickTime=2000 \n\tinitLimit=5\n\tsyncLimit=2\n\tdataDir=/opt/server/zookeeper/data\n\tclientPort=2181\n\tserver.1=192.168.1.111:2888:3888\n\tserver.2=192.168.1.112:2888:3888\n\tserver.3=192.168.1.113:2888:3888\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中tickTime，dataDir，clientPort参数与单机模式一致；&lt;br&gt;\n**initLimit：**这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5&lt;em&gt;2000=10 秒。&lt;br&gt;\n**syncLimit：**这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个tickTime的时间长度，总的时间长度就是 2&lt;/em&gt;2000=4 秒。&lt;br&gt;\n&lt;strong&gt;server.A=B：C：D&lt;/strong&gt;，其中：&lt;br&gt;\nA 是一个数字，表示第几号服务器；&lt;br&gt;\nB 该服务器IP地址；&lt;br&gt;\nC 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口&lt;br&gt;\nD表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;注意：如果是伪集群的配置方式，由于 B 都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;4、在dataDir对应的目录下建立名为myid的文件，内容值为A值&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;vim /opt/server/zookeeper/data/myid\n\t1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;所有参与集群的主机按照上面配置，唯一不同即myid的值，与zoo.cfg中A值对应即可。&lt;br&gt;\n&lt;strong&gt;注意：这里的A值与之前配置的server.x对应，各个节点对应各自的myid&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;zookeeper配置jvm\&#34;&gt;zookeeper配置JVM&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;vim /opt/server/zookeeper/bin/zkServer.sh \n\tstart)\n\t    echo  -n &amp;quot;Starting zookeeper ... &amp;quot;\n\t    if [ -f &amp;quot;$ZOOPIDFILE&amp;quot; ]; then\n\t      if kill -0 `cat &amp;quot;$ZOOPIDFILE&amp;quot;` &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then\n\t         echo $command already running as process `cat &amp;quot;$ZOOPIDFILE&amp;quot;`.\n\t         exit 0\n\t      fi\n\t    fi\n\t    nohup &amp;quot;$JAVA&amp;quot; &amp;quot;-Dzookeeper.log.dir=${ZOO_LOG_DIR}&amp;quot; &amp;quot;-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}&amp;quot; \\\n\t    -cp &amp;quot;$CLASSPATH&amp;quot; -server -Xms128m -Xmx256m -Xmn64m -XX:PermSize=65m $ZOOMAIN &amp;quot;$ZOOCFG&amp;quot; &amp;gt; &amp;quot;$_ZOO_DAEMON_OUT&amp;quot; 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;\n\t    #-cp &amp;quot;$CLASSPATH&amp;quot; $JVMFLAGS $ZOOMAIN &amp;quot;$ZOOCFG&amp;quot; &amp;gt; &amp;quot;$_ZOO_DAEMON_OUT&amp;quot; 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;\n\t    #对应修改以上两行，注意这里不能在-cp之前使用注释之类的行，它对前一行一起作为命令执行\n\t    if [ $? -eq 0 ]\n\t    then\n\t      if /bin/echo -n $! &amp;gt; &amp;quot;$ZOOPIDFILE&amp;quot;\n\t      then\n\t        sleep 1\n\t        echo STARTED\n\t      else\n\t        echo FAILED TO WRITE PID\n\t        exit 1\n\t      fi\n\t    else\n\t      echo SERVER DID NOT START\n\t      exit 1\n\t    fi\n\t    ;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;启动zookeeper后可使用jmap -heap [pid]命令查看当前进程内存使用情况：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ps -ef | grep zookeeper\n找到对应的[pid]\njmap -heap 8761\n\tAttaching to process ID 8761, please wait...\n\tDebugger attached successfully.\n\tServer compiler detected.\n\tJVM version is 24.79-b02\n\n\tusing thread-local object allocation.\n\tParallel GC with 4 thread(s)\n\n\tHeap Configuration:\n\t   MinHeapFreeRatio = 0\n\t   MaxHeapFreeRatio = 100\n\t   MaxHeapSize      = 268435456 (256.0MB)\n\t   NewSize          = 67108864 (64.0MB)\n\t   MaxNewSize       = 67108864 (64.0MB)\n\t   OldSize          = 5439488 (5.1875MB)\n\t   NewRatio         = 2\n\t   SurvivorRatio    = 8\n\t   PermSize         = 68157440 (65.0MB)\n\t   MaxPermSize      = 85983232 (82.0MB)\n\t   G1HeapRegionSize = 0 (0.0MB)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;启动并测试zookeeper\&#34;&gt;启动并测试zookeeper&lt;/h2&gt;\n&lt;p&gt;1、启动zookeeper服务&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;cd /opt/server/zookeeper/bin\n./zkServer.sh start\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、查看zookeeper服务状态&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;./zkServer.sh status\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、停止zookeeper服务&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;./zkServer.sh stop\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;zookeeper-install&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;单机安装zookeeper\&#34;&gt;单机安装zookeeper&lt;/h2&gt;\n&lt;p&gt;1、下载响应版本的zookeeper&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、解压安装文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;tar -xzvf zookeeper-3.4.6.tar.gz\nmv zookeeper-3.4.6 zookeeper\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;zookeeper 安装&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;zookeeper&#34;,&#34;slug&#34;:&#34;YGfJDaU98eQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/YGfJDaU98eQ/&#34;},{&#34;name&#34;:&#34;zookeeper安装&#34;,&#34;slug&#34;:&#34;ETqBbPI8kXz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ETqBbPI8kXz/&#34;}],&#34;date&#34;:&#34;2017-01-24 15:00:24&#34;,&#34;dateFormat&#34;:&#34;2017-01-24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/zookeeper-install/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:299000,&#34;words&#34;:1096,&#34;minutes&#34;:5},&#34;description&#34;:&#34;单机安装zookeeper\n1、下载响应版本的zookeeper\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3....&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85zookeeper\&#34;&gt;单机安装zookeeper&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85zookeeper\&#34;&gt;集群安装zookeeper&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#zookeeper%E9%85%8D%E7%BD%AEjvm\&#34;&gt;zookeeper配置JVM&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E5%B9%B6%E6%B5%8B%E8%AF%95zookeeper\&#34;&gt;启动并测试zookeeper&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;DEFAULT(col_name)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：将数字 X 的格式写为 &#39;#,###,###.##&#39;, 以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若   D 为 0, 则返回结果不带有小数点，或不含小数部分。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;GET_LOCK(str ,timeout)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：设法使用字符串 str 给定的名字得到一个锁， 超时为 timeout 秒。若成功得到锁，则返回 1 ，若操作超时则返回 0 ( 例如 , 由于另一个客户端已提前封锁了这个名字 ), 若发生错误则返回 NULL ( 诸如缺乏记忆或线程 mysqladmin kill 被断开 ) 。假如你有一个用 GET_LOCK() 得到的锁，当你执行 RELEASE_LOCK() 或你的连接断开 ( 正常或非正常 ) 时，这个锁就会解除&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;INET_ATON(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是 4 或 8 比特地址。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;INET_NTOA(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：给定一个数字网络地址 (4 或 8 比特 ), 返回作为字符串的该地址的电地址表示&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;IS_FREE_LOCK(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：检查名为 str 的锁是否可以使用 ( 换言之 , 没有被封锁 ) 。若锁可以使用，则返回   1 ( 没有人在用这个锁 ), 若这个锁正在被使用，则返回 0 ，出现错误则返回 NULL ( 诸如不正确的参数 ) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;IS_USED_LOCK(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：检查名为 str 的锁是否正在被使用 ( 换言之 , 被封锁 ) 。若被封锁，则返回使用该锁的客户端的连接标识符。否则返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MASTER_POS_WAIT(log_name ,log_pos [,timeout ])&lt;/strong&gt;&lt;br&gt;\n函数使用说明：该函数对于控制主从同步很有用处。它会持续封锁，直到从设备阅读和应用主机记录中所有补充资料到指定的位置。返回值是其为到达指定位置而必须等待的记录事件的数目。若从设备 SQL 线程没有被启动、从设备主机信息尚未初始化、参数不正确或出现任何错误，则该函数返回 NULL 。若超时时间被超过，则返回 -1 。若在 MASTER_POS_WAIT() 等待期间，从设备 SQL 线程中止，则该函数返回 NULL 。若从设备由指定位置通过，则函数会立即返回结果。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;NAME_CONST(name ,value)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回给定值。 当用来产生一个结果集合列时 , NAME_CONST() 促使该列使用给定名称。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RELEASE_LOCK(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：解开被 GET_LOCK() 获取的，用字符串 str 所命名的锁。若锁被解开，则返回   1 ，若改线程尚未创建锁，则返回 0 ( 此时锁没有被解开 ), 若命名的锁不存在，则返回 NULL 。若该锁从未被对 GET_LOCK() 的调用获取，或锁已经被提前解开，则该锁不存在。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SLEEP(duration)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：睡眠 ( 暂停 ) 时间为 duration 参数给定的秒数，然后返回 0 。若 SLEEP() 被中断 , 它会返回 1 。 duration 或许或包括一个给定的以微秒为单位的分数部分。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UUID()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个通用唯一标识符 (UUID) ， UUID 被设计成一个在时间和空间上都独一无二的数字。 2 个对 UUID() 的调用应产生 2 个不同的值，即使这些调用的执行是在两个互不相连的单独电脑上进行。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;VALUES(col_name)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：在一个 INSERT … ON DUPLICATE KEY UPDATE … 语句中，你可以在 UPDATE 子句中使用 VALUES(col_name ) 函数，用来访问来自该语句的 INSERT 部分的列值。换言之， UPDATE 子句中的 VALUES(col_name ) 访问需要被插入的 col_name 的值 , 并不会发生重复键冲突。这个函数在多行插入中特别有用。   VALUES() 函数只在 INSERT ... UPDATE 语句中有意义，而在其它情况下只会返回 NULL&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-other-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;DEFAULT(col_name)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：将数字 X 的格式写为 &#39;#,###,###.##&#39;, 以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若   D 为 0, 则返回结果不带有小数点，或不含小数部分。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 其他函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;函数&#34;,&#34;slug&#34;:&#34;yjMLI-n2vWG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/yjMLI-n2vWG/&#34;}],&#34;date&#34;:&#34;2017-01-17 22:15:00&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-other-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:222000,&#34;words&#34;:1032,&#34;minutes&#34;:4},&#34;description&#34;:&#34;DEFAULT(col_name)\n函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。\nFORMAT(X ,D)\n函数使用说明：将数字 X 的格式写为 &#39;#,###,###.##&#39;, 以四舍五入的方式保留小数点后 D 位， ...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;AVG([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;BIT_AND(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 中所有比特的 bitwise AND 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则这个函数返回18446744073709551615 。( 这是无符号 BIGINT 值，所有比特被设置为 1 ）。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;BIT_OR(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 中所有比特的bitwise OR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;BIT_XOR(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 中所有比特的bitwise XOR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;COUNT(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回SELECT 语句检索到的行中非NULL 值的数目。若找不到匹配的行，则COUNT() 返回 0&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;COUNT(DISTINCT expr ,[expr ...])&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回不同的非NULL 值数目。若找不到匹配的项，则COUNT(DISTINCT) 返回 0&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;GROUP_CONCAT(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：该函数返回带有来自一个组的连接的非NULL 值的字符串结果。其完整的语法如下所示：&lt;br&gt;\nGROUP_CONCAT([DISTINCT] expr [,expr ...] [ORDER BY {unsigned_integer | col_name | expr } [ASC | DESC] [,col_name ...]] [SEPARATOR str_val ])&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MIN([DISTINCT] expr), MAX([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 expr 的最小值和最大值。 MIN() 和 MAX() 的取值可以是一个字符串参数；在这些情况下， 它们返回最小或最大字符串值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;STD(expr) STDDEV(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 expr 的总体标准偏差。这是标准 SQL 的延伸。这个函数的 STDDEV() 形式用来提供和 Oracle 的兼容性。可使用标准 SQL 函数 STDDEV_POP() 进行代替&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;STDDEV_POP(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 的总体标准偏差(VAR_POP() 的平方根) 。你也可以使用 STD() 或STDDEV(), 它们具有相同的意义，然而不是标准的 SQL 。若找不到匹配的行，则STDDEV_POP() 返回 NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;STDDEV_SAMP(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 的样本标准差 ( VAR_SAMP() 的平方根) 。若找不到匹配的行，则STDDEV_SAMP() 返回 NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SUM([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 的总数。 若返回集合中无任何行，则 SUM() 返回NULL 。DISTINCT 关键词可用于 MySQL 5.1 中，求得expr 不同值的总和。 若找不到匹配的行，则SUM() 返回 NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;VAR_POP(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 expr 总体标准方差。它将行视为总体，而不是一个样本， 所以它将行数作为分母。你也可以使用 VARIANCE(), 它具有相同的意义然而不是 标准的 SQL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;VAR_SAMP(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 的样本方差。更确切的说，分母的数字是行数减去1 。若找不到匹配的行，则VAR_SAMP() 返回NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;VARIANCE(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 的总体标准方差。这是标准SQL 的延伸。可使用标准SQL 函数 VAR_POP() 进行代替。若找不到匹配的项，则VARIANCE() 返回NULL&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-aggregate-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;AVG([DISTINCT] expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;BIT_AND(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回expr 中所有比特的 bitwise AND 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则这个函数返回18446744073709551615 。( 这是无符号 BIGINT 值，所有比特被设置为 1 ）。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 聚合函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;聚合函数&#34;,&#34;slug&#34;:&#34;jsr_n12Xo1S&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/jsr_n12Xo1S/&#34;}],&#34;date&#34;:&#34;2017-01-17 22:08:17&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-aggregate-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:173000,&#34;words&#34;:756,&#34;minutes&#34;:3},&#34;description&#34;:&#34;AVG([DISTINCT] expr)\n函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。\nBIT_AND(expr)\n函数使用说明：返回expr 中所有比特的 bitwise AND...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;BENCHMARK(count ,expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算   MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户端内部 , 能够报告问询执行的次数&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CHARSET(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串自变量的字符集。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;COERCIBILITY(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串自变量的整序可压缩性值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;COLLATION(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串参数的排序方式。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CONNECTION_ID()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回对于连接的连接 ID ( 线程 ID) 。每个连接都有各自的唯一 ID 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURRENT_USER, CURRENT_USER()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前话路被验证的用户名和主机名组合。这个值符合确定你的存取权限的 MySQL 账户。在被指定 SQL SECURITY DEFINER 特征的存储程序内， CURRENT_USER() 返回程序的创建者&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DATABASE()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回使用 utf8 字符集的默认 ( 当前 ) 数据库名。在存储程序里，默认数据库是同该程序向关联的数据库，但并不一定与调用语境的默认数据库相同。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FOUND_ROWS()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： A SELECT 语句可能包括一个 LIMIT 子句，用来限制服务器返回客户端的行数。在有些情况下，需要不用再次运行该语句而得知在没有 LIMIT 时到底该语句返回了多少行。为了知道这个行数 , 包括在 SELECT 语句中选择   SQL_CALC_FOUND_ROWS ，随后调用 FOUND_ROWS()&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LAST_INSERT_ID() LAST_INSERT_ID(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：自动返回最后一个 INSERT 或 UPDATE 问询为 AUTO_INCREMENT 列设置的第一个 发生的值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ROW_COUNT()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： ROW_COUNT() 返回被前面语句升级的、插入的或删除的行数。 这个行数和 mysql 客户端显示的行数及 mysql_affected_rows() C API 函数返回的值相同。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SCHEMA()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：这个函数和 DATABASE() 具有相同的意义&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SESSION_USER()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： SESSION_USER() 和 USER() 具有相同的意义。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SYSTEM_USER()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： SYSTEM_USER() 合 USER() 具有相同的意义&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;USER()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前 MySQL 用户名和机主名&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;VERSION()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回指示 MySQL 服务器版本的字符串。这个字符串使用 utf8 字符集。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-information-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;BENCHMARK(count ,expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算   MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户端内部 , 能够报告问询执行的次数&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CHARSET(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串自变量的字符集。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 信息函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;信息函数&#34;,&#34;slug&#34;:&#34;ZVeI9JCUAwU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ZVeI9JCUAwU/&#34;}],&#34;date&#34;:&#34;2017-01-17 18:16:14&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-information-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:127000,&#34;words&#34;:586,&#34;minutes&#34;:3},&#34;description&#34;:&#34;BENCHMARK(count ,expr)\n函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算   MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;AES_ENCRYPT(str ,key_str) , AES_DECRYPT(crypt_str ,key_str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “Rijndael” 。 保密关键字的长度为 128 比特，不过你可以通过改变源而将其延长到 256 比特。我们选择了 128 比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DECODE(crypt_str ,pass_str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：使用 pass_str 作为密码，解密加密字符串 crypt_str ， crypt_str 应该是由 ENCODE() 返回的字符串。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;ENCODE(str ,pass_str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：使用 pass_str 作为密码，解密 str 。 使用 DECODE() 解密结果。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DES_DECRYPT(crypt_str [,key_str ])&lt;/strong&gt;&lt;br&gt;\n函数使用说明：使用 DES_ENCRYPT() 加密一个字符串。若出现错误，这个函数会返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DES_ENCRYPT(str [,(key_num |key_str )])&lt;/strong&gt;&lt;br&gt;\n函数使用说明：用 Triple-DES 算法给出的关键字加密字符串。若出现错误，这个函数会返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ENCRYPT(str [,salt ])&lt;/strong&gt;&lt;br&gt;\n函数使用说明：使用 Unix crypt() 系统调用加密 str 。 salt 参数应为一个至少包含 2 个字符的字符串。若没有给出 salt 参数，则使用任意值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MD5(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：为字符串算出一个 MD5 128 比特检查和。该值以 32 位十六进制数字的二进制字符串的形式返回 , 若参数为 NULL 则会返回 NULL 。例如，返回值可被用作散列关键字&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;OLD_PASSWORD(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：当 PASSWORD() 的执行变为改善安全性时， OLD_PASSWORD() 会被添加到 MySQL 。 OLD_PASSWORD() 返回从前的 PASSWORD() 执行值 ( 4.1 之前 ) ，同时允许你为任何 4.1 之前的需要连接到你的 5.1 版本 MySQL 服务器前客户端设置密码，从而不至于将它们切断&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;PASSWORD(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：从原文密码str 计算并返回密码字符串，当参数为 NULL 时返回 NULL 。这个函数用于用户授权表的Password 列中的加密MySQL 密码存储&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-enctyption-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;AES_ENCRYPT(str ,key_str) , AES_DECRYPT(crypt_str ,key_str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “Rijndael” 。 保密关键字的长度为 128 比特，不过你可以通过改变源而将其延长到 256 比特。我们选择了 128 比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DECODE(crypt_str ,pass_str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：使用 pass_str 作为密码，解密加密字符串 crypt_str ， crypt_str 应该是由 ENCODE() 返回的字符串。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 加密函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;加密函数&#34;,&#34;slug&#34;:&#34;mLhKQ62sgPK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/mLhKQ62sgPK/&#34;}],&#34;date&#34;:&#34;2017-01-17 18:07:23&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-enctyption-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:116000,&#34;words&#34;:521,&#34;minutes&#34;:2},&#34;description&#34;:&#34;AES_ENCRYPT(str ,key_str) , AES_DECRYPT(crypt_str ,key_str)\n函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “R...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])&lt;/strong&gt;&lt;br&gt;\n使用Mysql全文检索fulltext的先决条件&lt;br&gt;\n表的类型必须是MyISAM&lt;br&gt;\n建立全文检索的字段类型必须是char,varchar,text&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;建立全文检索先期配置&lt;br&gt;\nft_wordlist_charset 表示词典的字符集, 目前支持良好的有(UTF-8, gbk, gb2312, big5)&lt;br&gt;\nft_wordlist_file 是词表文件, 每行包括一个词及其词频(用若干制表符或空格分开,消岐专用)&lt;br&gt;\nft_stopword_file 表示过滤掉不索引的词表, 一行一个.&lt;br&gt;\nft_min_word_len     加入索引的词的最小长度, 缺省是 4, 为了支持中文单字故改为 2&lt;/p&gt;\n&lt;p&gt;建立全文检索&lt;br&gt;\n在建表中用FullText关键字标识字段,已存在的表用 ALTER TABLE (或 CREATE INDEX) 创建索引&lt;br&gt;\nCREATE fulltext INDEX index_name ON table_name(colum_name);&lt;/p&gt;\n&lt;p&gt;使用全文检索&lt;br&gt;\n在SELECT的WHERE字句中用MATCH函数,索引的关键词用AGAINST标识,IN BOOLEAN MODE是只有含有关键字就行,不用在乎位置,是不是起启位置.&lt;br&gt;\nSELECT * FROM articles WHERE MATCH (tags) AGAINST (&#39;旅游&#39; IN BOOLEAN MODE);&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-full-text-search-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])&lt;/strong&gt;&lt;br&gt;\n使用Mysql全文检索fulltext的先决条件&lt;br&gt;\n表的类型必须是MyISAM&lt;br&gt;\n建立全文检索的字段类型必须是char,varchar,text&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 全文检索函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;检索函数&#34;,&#34;slug&#34;:&#34;uZugyIWay4x&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/uZugyIWay4x/&#34;},{&#34;name&#34;:&#34;全文检索&#34;,&#34;slug&#34;:&#34;S3HS10umY0x&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/S3HS10umY0x/&#34;}],&#34;date&#34;:&#34;2017-01-17 17:59:44&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-full-text-search-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:61000,&#34;words&#34;:260,&#34;minutes&#34;:2},&#34;description&#34;:&#34;MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])\n使用Mysql全文检索fulltext的先决条件\n表的类型必须是MyISAM\n建立全...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;ADDDATE(date ,INTERVAL expr type) ADDDATE(expr ,days)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数 SUBDATE() 则是 DATE_SUB() 的同义词。对于 INTERVAL 参数上的信息 ，请参见关于 DATE_ADD() 的论述。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ADDTIME(expr ,expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： ADDTIME() 将 expr2 添加至 expr 然后返回结果。 expr 是一个时间或时间日期表达式，而 expr2 是一个时间表达式。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;CONVERT_TZ(dt ,from_tz ,to_tz)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： CONVERT_TZ() 将时间日期值 dt 从 from_tz 给出的时区转到 to_tz 给出的时区，然后返回结果值。关于可能指定的时区的详细论述，若自变量无效，则这个函数会返回 NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURDATE()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：将当前日期按照 &#39;YYYY-MM-DD&#39; 或 YYYYMMDD 格式的值返回，具体格式根据函数用在字符串或是数字语境中而定&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURRENT_DATE CURRENT_DATE()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： CURRENT_DATE 和 CURRENT_DATE() 是的同义词&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURTIME()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 将当前时间以 &#39;HH:MM:SS&#39; 或 HHMMSS 的格式返回， 具体格式根据函数用在字符串或是数字语境中而定。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURRENT_TIME, CURRENT_TIME()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： CURRENT_TIME 和 CURRENT_TIME() 是 CURTIME() 的同义词。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURRENT_TIMESTAMP, CURRENT_TIMESTAMP()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： CURRENT_TIMESTAMP 和 CURRENT_TIMESTAMP() 是 NOW() 的同义词&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DATE(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 提取日期或时间日期表达式 expr 中的日期部分。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DATEDIFF(expr ,expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： DATEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的天数。 Expr 和 expr2 为日期或 date-and-time 表达式。计算中只用到这些值的日期部分。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DATE_ADD(date ,INTERVAL expr type) DATE_SUB(date ,INTERVAL expr type)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：这些函数执行日期运算。 date 是一个 DATETIME 或 DATE 值，用来指定起始时间。 expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。   Expr 是一个字符串 ; 对于负值的时间间隔，它可以以一个 ‘-’ 开头。 type 为关键词，它指示了表达式被解释的方式。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DATE_FORMAT(date ,format)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：根据 format 字符串安排 date 值的格式。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DAY(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： DAY() 和 DAYOFMONTH() 的意义相同&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DAYNAME(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date 对应的工作日名称。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DAYOFMONTH(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date 对应的该月日期，范围是从 1 到 31&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DAYOFWEEK(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date (1 = 周日 , 2 = 周一 , ..., 7 = 周六 ) 对应的工作日索引。这些索引值符合 ODBC 标准&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DAYOFYEAR(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回date 对应的一年中的天数，范围是从 1 到366 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;EXTRACT(type FROM date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： EXTRACT() 函数所使用的时间间隔类型说明符同 DATE_ADD() 或 DATE_SUB() 的相同 , 但它从日期中提取其部分，而不是执行日期运算。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FROM_DAYS(N)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 给定一个天数N , 返回一个 DATE 值。&lt;/p&gt;\n&lt;p&gt;** FROM_UNIXTIME(unix_timestamp )ROM_UNIXTIME(unix_timestamp ,format)**&lt;br&gt;\n函数使用说明：返回&#39;YYYY-MM-DD HH:MM:SS&#39; 或YYYYMMDDHHMMSS 格式值的unix_timestamp 参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。 若format 已经给出，则结果的格式是根据format 字符串而定。 format 可以包含同DATE_FORMAT() 函数输入项列表中相同的说明符。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;GET_FORMAT(DATE|TIME|DATETIME, &#39;EUR&#39;|&#39;USA&#39;|&#39;JIS&#39;|&#39;ISO&#39;|&#39;INTERNAL&#39;)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个格式字符串。这个函数在同 DATE_FORMAT() 及 STR_TO_DATE() 函数结合时很有用&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;HOUR(time)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 time 对应的小时数。对于日时值的返回值范围是从 0 到 23&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LAST_DAY(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOCALTIME, LOCALTIME()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： LOCALTIME 及 LOCALTIME() 和 NOW() 具有相同意义。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOCALTIMESTAMP, LOCALTIMESTAMP()&lt;/strong&gt;&lt;br&gt;\n函数使用说明： LOCALTIMESTAMP 和 LOCALTIMESTAMP() 和 NOW() 具有相同意义。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MAKEDATE(year ,dayofyear)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：给出年份值和一年中的天数值，返回一个日期。 dayofyear 必须大于 0 ，否则结果为 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MAKETIME(hour ,minute ,second)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回由 hour 、 minute 和 second 参数计算得出的时间值&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CROSECOND(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：从时间或日期时间表达式 expr 返回微秒值，其数字范围从 0 到 999999 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MINUTE(time)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 time 对应的分钟数 , 范围是从 0 到 59 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MONTH(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date 对应的月份，范围时从 1 到 12 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MONTHNAME(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回 date 对应月份的全名&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;NOW()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前日期和时间值，其格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ， 具体格式取决于该函数是否用在字符串中或数字语境中。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;PERIOD_ADD(P ,N)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：添加 N 个月至周期 P ( 格式为 YYMM 或 YYYYMM) ，返回值的格式为 YYYYMM 。注意周期参数 P 不是 日期值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;PERIOD_DIFF(P1 ,P2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回周期 P1 和 P2 之间的月份数。 P1 和 P2 的格式应该为 YYMM 或 YYYYMM 。注意周期参数 P1 和 P2 不是 日期值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;QUARTER(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date 对应的一年中的季度值，范围是从 1 到 4&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SECOND(time)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 time 对应的秒数 , 范围是从 0 到 59 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SEC_TO_TIME(seconds)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回被转化为小时、 分钟和秒数的 seconds 参数值 , 其格式为 &#39;HH:MM:SS&#39; 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境中而定&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;STR_TO_DATE(str ,format)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：这是 DATE_FORMAT() 函数的倒转。它获取一个字符串 str 和一个格式字符串 format 。若格式字符串包含日期和时间部分，则 STR_TO_DATE() 返回一个 DATETIME 值， 若该字符串只包含日期部分或时间部分，则返回一个 DATE 或 TIME 值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SUBDATE(date ,INTERVAL expr type) SUBDATE(expr ,days)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：当被第二个参数的 INTERVAL 型式调用时 , SUBDATE() 和 DATE_SUB() 的意义相同。对于有关 INTERVAL 参数的信息， 见有关 DATE_ADD() 的讨论。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SUBTIME(expr ,expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： SUBTIME() 从 expr 中提取 expr2 ，然后返回结果。 expr 是一个时间或日期时间表达式，而 xpr2 是一个时间表达式。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SYSDATE()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前日期和时间值，格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ， 具体格式根据函数是否用在字符串或数字语境而定。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIME(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：提取一个时间或日期时间表达式的时间部分，并将其以字符串形式返回。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIMEDIFF(expr ,expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： TIMEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的时间。 expr 和 expr2 为时间或 date-and-time 表达式 , 两个的类型必须一样。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIMESTAMP(expr) , TIMESTAMP(expr ,expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 对于一个单参数 , 该函数将日期或日期时间表达式 expr 作为日期时间值返回 . 对于两个参数 , 它将时间表达式 expr2 添加到日期或日期时间表达式 expr 中，将 theresult 作为日期时间值返回。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIMESTAMPADD(interval ,int_expr ,datetime_expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：将整型表达式int_expr 添加到日期或日期时间表达式 datetime_expr 中。 int_expr 的单位被时间间隔参数给定，该参数必须是以下值的其中一个： FRAC_SECOND 、SECOND 、 MINUTE 、 HOUR 、 DAY 、 WEEK 、 MONTH 、 QUARTER 或 YEAR 。可使用所显示的关键词指定Interval 值，或使用SQL_TSI_ 前缀。例如, DAY 或SQL_TSI_DAY 都是正确的&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIMESTAMPDIFF(interval ,datetime_expr1 ,datetime_expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回日期或日期时间表达式 datetime_expr1 和 datetime_expr2 the 之间的整数差。其结果的单位由 interval 参数给出。 interval 的法定值同 TIMESTAMPADD() 函数说明中所列出的相同。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIME_FORMAT(time ,format)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：其使用和 DATE_FORMAT() 函数相同 , 然而 format 字符串可能仅会包含处理小时、分钟和秒的格式说明符。其它说明符产生一个 NULL 值或 0 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TIME_TO_SEC(time)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回已转化为秒的 time 参数&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TO_DAYS(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：给定一个日期 date , 返回一个天数 ( 从年份 0 开始的天数 ) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：若无参数调用，则返回一个 Unix timestamp (&#39;1970-01-01 00:00:00&#39; GMT 之后的秒数 ) 作为无符号整数。若用 date 来调用 UNIX_TIMESTAMP() ，它会将参数值以 &#39;1970-01-01 00:00:00&#39; GMT 后的秒数的形式返回。 date 可以是一个 DATE 字符串、一个 DATETIME 字符串、一个 TIMESTAMP 或一个当地时间的 YYMMDD 或 YYYMMDD 格式的数字。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UTC_DATE, UTC_DATE()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前 UTC 日期值，其格式为 &#39;YYYY-MM-DD&#39; 或 YYYYMMDD ，具体格式取决于函数是否用在字符串或数字语境中。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UTC_TIME, UTC_TIME()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前 UTC 值，其格式为   &#39;HH:MM:SS&#39; 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UTC_TIMESTAMP, UTC_TIMESTAMP()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回当前 UTC 日期及时间值，格式为 &#39;YYYY-MM-DD HH:MM:SS&#39; 或 YYYYMMDDHHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;WEEK(date [,mode ])&lt;/strong&gt;&lt;br&gt;\n函数使用说明：该函数返回 date 对应的星期数。 WEEK() 的双参数形式允许你指定该星期是否起始于周日或周一， 以及返回值的范围是否为从 0 到 53 或从 1 到 53 。若 mode 参数被省略，则使用 default_week_format 系统自变量的值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;WEEKDAY(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date (0 = 周一 , 1 = 周二 , ... 6 = 周日 ) 对应的工作日索引   weekday index for&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;WEEKOFYEAR(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：将该日期的阳历周以数字形式返回，范围是从 1 到 53 。它是一个兼容度函数，相当于 WEEK(date ,3) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;YEAR(date)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 date 对应的年份 , 范围是从 1000 到 9999 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;YEARWEEK(date), YEARWEEK(date ,start)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个日期对应的年或周。 start 参数的工作同 start 参数对 WEEK() 的工作相同。结果中的年份可以和该年的第一周和最后一周对应的日期参数有所不同。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-date-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;ADDDATE(date ,INTERVAL expr type) ADDDATE(expr ,days)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数 SUBDATE() 则是 DATE_SUB() 的同义词。对于 INTERVAL 参数上的信息 ，请参见关于 DATE_ADD() 的论述。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ADDTIME(expr ,expr2)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： ADDTIME() 将 expr2 添加至 expr 然后返回结果。 expr 是一个时间或时间日期表达式，而 expr2 是一个时间表达式。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 日期函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;日期函数&#34;,&#34;slug&#34;:&#34;gFdZt25pB2_&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/gFdZt25pB2_/&#34;}],&#34;date&#34;:&#34;2017-01-17 16:40:16&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-date-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:594000,&#34;words&#34;:2584,&#34;minutes&#34;:10},&#34;description&#34;:&#34;ADDDATE(date ,INTERVAL expr type) ADDDATE(expr ,days)\n函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;ABS(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的绝对值&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ACOS(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ASIN（X）&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回X 的反正弦，即，正弦为X 的值。若X   若X 不在-1 到 1 的范围之内，则返回 NULL 。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;ATAN(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的反正切，即，正切为 X 的值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ATAN(Y ,X ) , ATAN2(Y ,X )&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回两个变量 X 及 Y 的反正切。 它类似于 Y 或 X 的反正切计算 , 除非两个参数的符号均用于确定结果所在象限。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CEILING(X ) CEIL(X )&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回不小于 X 的最小整数值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;函数COS(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的余弦，其中 X 在弧度上已知。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;COT(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的余切&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CRC32(expr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：计算循环冗余码校验值并返回一个 32 比特无符号值。若参数为 NULL ，则结果为 NULL 。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能）&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;DEGREES(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回参数 X , 该参数由弧度被转化为度。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;EXP(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 e 的 X 乘方后的值 ( 自然对数的底 ) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FLOOR(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回不大于 X 的最大整数值 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：将数字 X 的格式写成 &#39;#,###,###.##&#39; 格式 , 即保留小数点后 D 位，而第 D 位的保留方式为四舍五入，然后将结果以字符串的形式返回&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LN(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的自然对数 , 即 , X 相对于基数 e 的对数&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOG(X) LOG(B ,X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：若用一个参数调用，这个函数就会返回 X 的自然对数。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOG2(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的基数为 2 的对数。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOG10(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的基数为 10 的对数。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MOD(N ,M ) , N % M N MOD M&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 模操作。返回 N 被 M 除后的余数。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;PI()&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 ϖ (pi) 的值。默认的显示小数位数是 7 位 , 然而 MySQL 内部会使用完全双精度值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;POW(X ,Y) , POWER(X ,Y)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的 Y 乘方的结果值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RADIANS(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回由度转化为弧度的参数 X , ( 注意 ϖ 弧度等于 180 度）。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RAND() RAND(N)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个随机浮点值 v ，范围在 0 到 1 之间 ( 即 , 其范围为 0 ≤ v ≤ 1.0) 。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ROUND(X) ROUND(X ,D)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回参数 X , 其值接近于最近似的整数。在有两个参数的情况下，返回 X ，其值保留到小数点后 D 位，而第 D 位的保留方式为四舍五入。若要接保留 X 值小数点左边的 D 位，可将 D 设为负值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SIGN(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回参数作为 -1 、 0 或 1 的符号，该符号取决于 X 的值为负、零或正。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SIN(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 正弦，其中 X 在弧度中被给定。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SQRT(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回非负数 X 的二次方根。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TAN(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回 X 的正切，其中 X 在弧度中被给定。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TRUNCATE(X ,D)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回被舍去至小数点后 D 位的数字 X 。若 D 的值为 0, 则结果不带有小数点或不带有小数部分。可以将 D 设为负数 , 若要截去 ( 归零 ) X 小数点左起第 D 位开始后面所有低位的值&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-mathematical-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;ABS(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 的绝对值&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ACOS(X)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ASIN（X）&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回X 的反正弦，即，正弦为X 的值。若X   若X 不在-1 到 1 的范围之内，则返回 NULL 。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 数学函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;数学函数&#34;,&#34;slug&#34;:&#34;IBLF9_ZFVG9&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IBLF9_ZFVG9/&#34;}],&#34;date&#34;:&#34;2017-01-17 16:08:16&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-mathematical-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:224000,&#34;words&#34;:980,&#34;minutes&#34;:4},&#34;description&#34;:&#34;ABS(X)\n函数使用说明：返回 X 的绝对值\nACOS(X)\n函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。\nASIN（X）\n函数使用说明：返回X 的反正弦，即，...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;ascii(str)&lt;/strong&gt;&lt;br&gt;\n函数用法说明：返回值为字符串 str 的最左字符的数值。&lt;br&gt;\n假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;BIN(N)&lt;/strong&gt;&lt;br&gt;\n函数用法说明：返回值为 N 的二进制值的字符串表示，其中N 为一个 longlong (BIGINT) 数字。这等同于 CONV(N ,10,2) 。假如 N 为 NULL ，则返回值为 NULL 。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;CHAR(N ,... [USING charset ])&lt;/strong&gt;&lt;br&gt;\n函数用法说明： CHAR() 将每个参数 N 理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。 NULL 值被省略。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CHAR_LENGTH(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回值为字符串 str 的长度，长度的单位为字符。&lt;br&gt;\n一个多字节字符算作一个单字符。对于一个 包含五个二字节字符集 , LENGTH() 返回值为 10, 而 CHAR_LENGTH() 的返回值为 5&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CHARACTER_LENGTH(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： CHARACTER_LENGTH() 是 CHAR_LENGTH() 的同义词。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;COMPRESS(string_to_compress)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： COMPRESS( 压缩一个字符串。这个函数要求 MySQL 已经用一个诸如 zlib 的压缩库压缩过。否则，返回值始终是 NULL 。 UNCOMPRESS() 可将压缩过的字符串进行解压缩 ) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CONCAT(str1 ,str2 ,...)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回结果为连接参数产生的字符串。&lt;br&gt;\n如有任何一个参数为 NULL ，则返回值为 NULL 。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col)&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CONCAT_WS(separator ,str1 ,str2 ,...)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： CONCAT_WS() 代表 CONCAT With Separator ，是 CONCAT() 的特殊形式。&lt;br&gt;\n第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL ，则结果为 NULL 。函数会忽略任何分隔符参数后的 NULL 值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CONV(N from_base, to_base)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：不同数基间转换数字。&lt;br&gt;\n返回值为数字的 N 字符串表示，由 from_base 基转化为 to_base 基。如有任意一个参数为 NULL ，则返回值为 NULL 。自变量 N 被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为 2 ，而最大基数则为 36 。 If to_base 是一个负数，则 N 被看作一个带符号数。否则， N 被看作无符号数。 CONV() 的运行精确度为 64 比特。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;ELT(N ,str1 ,str2 ,str3 ,...)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：若 N = 1 ，则返回值为   str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。&lt;br&gt;\n若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是   FIELD() 的补数&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;EXPORT_SET(bits ,on ,off [,separator [,number_of_bits ]])&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回值为一个字符串，其中对于 bits 值中的每个位组，可以得到一个 on 字符串，而对于每个清零比特位，可以得到一个 off 字符串。 bits 中的比特值按照从右到左的顺序接受检验 ( 由低位比特到高位比特 ) 。字符串被分隔字符串分开 ( 默认为逗号 ‘,’) ，按照从左到右的顺序被添加到结果中。 number_of_bits 会给出被检验的二进制位数 ( 默认为 64) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FIELD(str, str1, str2, str3, …...)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回值为 str1 , str2 , str3 ,…… 列表中的 str 指数。在找不到 str 的情况下，返回值为 0 。如果所有对于 FIELD() 的参数均为字符串，则所有参数均按照字符串进行比较。如果所有的参数均为数字，则按照数字进行比较。否则，参数按照双倍进行比较。如果 str 为 NULL ，则返回值为 0 ，原因是 NULL 不能同任何值进行同等比较。 FIELD() 是 ELT() 的补数。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FIND_IN_SET(str, strlist)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 假如字符串 str 在由 N 子链组成的字符串列表 strlist 中， 则返回值的范围在 1 到 N 之间 。一个字符串列表就是一个由一些被 ‘,’ 符号分开的自链组成的字符串。如果第一个参数是一个常数字符串，而第二个是 type SET 列，则    FIND_IN_SET() 函数被优化，使用比特计算。如果 str 不在 strlist 或 strlist 为空字符串，则返回值为 0 。如任意一个参数为 NULL ，则返回值为 NULL 。 这个函数在第一个参数包含一个逗号 (‘,’) 时将无法正常运行。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FORMAT(X ,D)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 将 number X 设置为格式 &#39;#,###,###.##&#39;, 以四舍五入的方式保留到小数点后 D 位 , 而返回结果为一个字符串。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;HEX(N_or_S)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：如果N_OR_S 是一个数字，则返回一个 十六进制值 N 的 字符串表示&lt;br&gt;\n如果N_OR_S 是一个longlong (BIGINT) 数。这相当于 CONV(N,10,16)&lt;br&gt;\n如果N_OR_S 是一个字符串，则返回值为一个N_OR_S 的十六进制字符串表示，其中每个N_OR_S 里的每个字符被转化为两个十六进制数字。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;INSTR(str,substr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str 中子字符串的第一个出现位置。这和LOCATE() 的双参数形式相同，除非参数的顺序被颠倒。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LCASE(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：LCASE() 是 LOWER() 的同义词&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LEFT(str,len)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回从字符串str 开始的len 最左字符&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LENGTH(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回值为字符串 str 的长度，单位为字节。一个多字节字符算作多字节。这意味着 对于一个包含 5 个 2 字节字符的字符串， LENGTH() 的返回值为 10, 而 CHAR_LENGTH() 的返回值则为5 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOAD_FILE(file_name)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：读取文件并将这一文件按照字符串的格式返回。 文件的位置必须在服务器上 , 你必须为文件制定路径全名，而且你还必须拥有 FILE 特许权。文件必须可读取，文件容量必须小于 max_allowed_packet 字节。若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为 NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOCATE(substr ,str ) , LOCATE(substr ,str ,pos )&lt;/strong&gt;&lt;br&gt;\n函数使用说明：第一个语法返回字符串 str 中子字符串substr 的第一个出现位置。第二个语法返回字符串 str 中子字符串substr 的第一个出现位置, 起始位置在pos 。如若substr 不在str 中，则返回值为0 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LOWER(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str 以及所有根据最新的字符集映射表变为小写字母的字符&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LPAD(str ,len ,padstr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str , 其左边由字符串padstr 填补到len 字符长度。假如str 的长度大于len , 则返回值被缩短至 len 字符。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;LTRIM(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str ，其引导空格字符被删除。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MAKE_SET(bits ,str1 ,str2 ,...)&lt;/strong&gt;&lt;br&gt;\n数使用说明： 返回一个设定值 ( 一个包含被 ‘,’ 号分开的字字符串的字符串 ) ，由在 bits 组中具有相应的比特的字符串组成。 str1 对应比特 0, str2 对应比特 1, 以此类推。 str1 , str2 , ... 中的 NULL 值不会被添加到结果中。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;MID(str ,pos ,len)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： MID(str ,pos ,len ) 是 SUBSTRING(str ,pos ,len ) 的同义词。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;OCT(N)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个 N 的八进制值的字符串表示，其中 N 是一个 longlong (BIGINT) 数。这等同于 CONV(N,10,8) 。若 N 为 NULL ，则返回值为 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;OCTET_LENGTH(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： OCTET_LENGTH() 是 LENGTH() 的同义词。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;函数ORD(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：若字符串str 的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出:&lt;br&gt;\n(1st byte code) + (2nd byte code × 256) + (3rd byte code × 2562) ...&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;POSITION(substr IN str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：POSITION(substr IN str ) 是 LOCATE(substr ,str ) 同义词&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;QUOTE(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：引证一个字符串，由此产生一个在SQL 语句中可用作完全转义数据值的结果。 返回的字符串由单引号标注，每例都带有单引号 (‘&#39;’) 、 反斜线符号 (‘\\’) 、 ASCII NUL 以及前面有反斜线符号的Control-Z 。如果自变量的值为NULL, 则返回不带单引号的单词 “NULL” 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;REPEAT(str ,count)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个由重复的字符串str 组成的字符串，字符串str 的数目等于count 。 若 count &amp;lt;= 0, 则返回一个空字符串。若str 或 count 为 NULL ，则返回 NULL 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;REPLACE(str ,from_str ,to_str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串str 以及所有被字符串to_str 替代的字符串from_str 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;REVERSE(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str ，顺序和字符顺序相反。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RIGHT(str ,len)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：从字符串str 开始，返回最右len 字符。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RPAD(str ,len ,padstr)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串str , 其右边被字符串 padstr 填补至len 字符长度。假如字符串str 的长度大于 len , 则返回值被缩短到与 len 字符相同长度&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RTRIM(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str ，结尾空格字符被删去。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SOUNDEX(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：从str 返回一个soundex 字符串。 两个具有几乎同样探测的字符串应该具有同样的 soundex 字符串。一个标准的soundex 字符串的长度为4 个字符，然而SOUNDEX() 函数会返回一个人以长度的字符串。 可使用结果中的SUBSTRING() 来得到一个标准 soundex 字符串。在str 中， 会忽略所有未按照字母顺序排列的字符。所有不在A-Z 范围之内的国际字母符号被视为元音字母。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;expr1 SOUNDS LIKE expr2&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 这相当于SOUNDEX(expr1 ) = SOUNDEX(expr2 ) 。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SPACE(N)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回一个由N 间隔符号组成的字符串&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SUBSTRING(str ,pos) , SUBSTRING(str FROM pos) SUBSTRING(str ,pos ,len) , SUBSTRING(str FROM pos FOR len)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：不带有len 参数的格式从字符串str 返回一个子字符串，起始于位置 pos 。带有len 参数的格式从字符串str 返回一个长度同len 字符相同的子字符串，起始于位置 pos 。 使用 FROM 的格式为标准 SQL 语法。也可能对pos 使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;SUBSTRING_INDEX(str ,delim ,count)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：在定界符 delim 以及count 出现前，从字符串str 返回自字符串。若count 为正值, 则返回最终定界符( 从左边开始) 左边的一切内容。若count 为负值，则返回定界符（从右边开始）右边的一切内容。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TRIM([{BOTH | LEADING | TRAILING} [remstr ] FROM] str) TRIM(remstr FROM] str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str ， 其中所有remstr 前缀和/ 或后缀都已被删除。若分类符BOTH 、LEADIN 或TRAILING 中没有一个是给定的, 则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UCASE(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：UCASE() 是UPPER() 的同义词&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UNCOMPRESS(string_to_uncompress)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：对经COMPRESS() 函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为 NULL 。这个函数要求 MySQL 已被诸如zlib 之类的压缩库编译过。否则, 返回值将始终是 NULL&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UNCOMPRESSED_LENGTH(compressed_string)&lt;/strong&gt;&lt;br&gt;\n函数使用说明： 返回压缩字符串压缩前的长度。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UNHEX(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：执行从 HEX(str ) 的反向操作。就是说，它将参数中的每一对十六进制数字理解为一个数字，并将其转化为该数字代表的字符。结果字符以二进制字符串的形式返回&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;UPPER(str)&lt;/strong&gt;&lt;br&gt;\n函数使用说明：返回字符串 str ， 以及根据最新字符集映射转化为大写字母的字符&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-string-comparison-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;ascii(str)&lt;/strong&gt;&lt;br&gt;\n函数用法说明：返回值为字符串 str 的最左字符的数值。&lt;br&gt;\n假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;BIN(N)&lt;/strong&gt;&lt;br&gt;\n函数用法说明：返回值为 N 的二进制值的字符串表示，其中N 为一个 longlong (BIGINT) 数字。这等同于 CONV(N ,10,2) 。假如 N 为 NULL ，则返回值为 NULL 。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 字符串比较函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;字符串函数&#34;,&#34;slug&#34;:&#34;GESkkxqIDA4&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/GESkkxqIDA4/&#34;},{&#34;name&#34;:&#34;字符串比较&#34;,&#34;slug&#34;:&#34;VEW2GMFfzvj&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/VEW2GMFfzvj/&#34;}],&#34;date&#34;:&#34;2017-01-17 14:15:23&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-string-comparison-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;12 min read&#34;,&#34;time&#34;:703000,&#34;words&#34;:3126,&#34;minutes&#34;:12},&#34;description&#34;:&#34;ascii(str)\n函数用法说明：返回值为字符串 str 的最左字符的数值。\n假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符\nB...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;**CASE WHEN THEN **&lt;br&gt;\n语法： CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ] END CASE WHEN [condition] THEN result [WHEN[condition] THEN result ……] [ELSE result] END ;&lt;br&gt;\n函数用法说明：在第一个方案的返回结果中， value =compare-value 。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为 ELSE 后的结果，如果没有 ELSE 部分，则返回值为 NULL&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;**IF **&lt;br&gt;\n语法： IF(expr1,expr2,expr3)&lt;br&gt;\n函数用法说明：如果 expr1 是 TRUE (expr1 &amp;lt;&amp;gt; 0 and expr1 &amp;lt;&amp;gt; NULL) ，则 IF() 的返回值为 expr2 ; 否则返回值则为 expr3 。 IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定&lt;/p&gt;\n&lt;p&gt;**IFNULL **&lt;br&gt;\n语法： IFNULL(expr1,expr2)&lt;br&gt;\n函数用法说明：假如 expr1 不为 NULL ，则 IFNULL() 的返回值为 expr1 ; 否则其返回值为 expr2 。 IFNULL() 的返回值是数字或是字符串，具体情况取决于其所使用的语境&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-control-flow-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;**CASE WHEN THEN **&lt;br&gt;\n语法： CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ] END CASE WHEN [condition] THEN result [WHEN[condition] THEN result ……] [ELSE result] END ;&lt;br&gt;\n函数用法说明：在第一个方案的返回结果中， value =compare-value 。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为 ELSE 后的结果，如果没有 ELSE 部分，则返回值为 NULL&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql 控制流程函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;流程函数&#34;,&#34;slug&#34;:&#34;bCCJnefnzvF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/bCCJnefnzvF/&#34;},{&#34;name&#34;:&#34;控制流程&#34;,&#34;slug&#34;:&#34;q7Kc5gsHdri&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/q7Kc5gsHdri/&#34;}],&#34;date&#34;:&#34;2017-01-17 14:08:19&#34;,&#34;dateFormat&#34;:&#34;2017-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-control-flow-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:59000,&#34;words&#34;:239,&#34;minutes&#34;:1},&#34;description&#34;:&#34;**CASE WHEN THEN **\n语法： CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ]...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;DAYOFWEEK(date)&lt;/strong&gt;&lt;br&gt;\n返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DAYOFWEEK(&#39;2017-01-06&#39;);\n+-------------------------+\n| DAYOFWEEK(&#39;2017-01-06&#39;) |\n+-------------------------+\n|                       6 |\n+-------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;WEEKDAY(date)&lt;/strong&gt;&lt;br&gt;\n返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select WEEKDAY(&#39;2017-01-06&#39;);\n+-----------------------+\n| WEEKDAY(&#39;2017-01-06&#39;) |\n+-----------------------+\n|                     4 |\n+-----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;DAYOFMONTH(date)&lt;/strong&gt;&lt;br&gt;\n返回date的月份中日期，在1到31范围内。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DAYOFMONTH(&#39;2017-01-06&#39;);\n+--------------------------+\n| DAYOFMONTH(&#39;2017-01-06&#39;) |\n+--------------------------+\n|                        6 |\n+--------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;DAYOFYEAR(date)&lt;/strong&gt;&lt;br&gt;\n返回date在一年中的日数, 在1到366范围内。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DAYOFYEAR(&#39;2016-12-31&#39;);\n+-------------------------+\n| DAYOFYEAR(&#39;2016-12-31&#39;) |\n+-------------------------+\n|                     366 |\n+-------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;MONTH(date)&lt;/strong&gt;&lt;br&gt;\n返回date的月份，范围1到12。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select MONTH(&#39;2017-01-06&#39;);\n+---------------------+\n| MONTH(&#39;2017-01-06&#39;) |\n+---------------------+\n|                   1 |\n+---------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;DAYNAME(date)&lt;/strong&gt;&lt;br&gt;\n返回date的星期名字。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DAYNAME(&amp;quot;2017-01-06&amp;quot;);\n+-----------------------+\n| DAYNAME(&amp;quot;2017-01-06&amp;quot;) |\n+-----------------------+\n| Friday                |\n+-----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;MONTHNAME(date)&lt;/strong&gt;&lt;br&gt;\n返回date的月份名字。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select MONTHNAME(&amp;quot;2017-01-06&amp;quot;);\n+-------------------------+\n| MONTHNAME(&amp;quot;2017-01-06&amp;quot;) |\n+-------------------------+\n| January                 |\n+-------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;QUARTER(date)&lt;/strong&gt;&lt;br&gt;\n返回date一年中的季度，范围1到4。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select QUARTER(&#39;2016-12-31&#39;);\n+-----------------------+\n| QUARTER(&#39;2016-12-31&#39;) |\n+-----------------------+\n|                     4 |\n+-----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;WEEK(date)、WEEK(date,first)&lt;/strong&gt;&lt;br&gt;\n对于星期天是一周的第一天的地方，有一个单个参数，返回date的周数，范围在0到52。2个参数形式WEEK()允许你指定星期是否开始于星期天或星期一。如果第二个参数是0，星期从星期天开始，如果第二个参数是1，从星期一开始。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select WEEK(&#39;2017-01-08&#39;);  \n+--------------------+\n| WEEK(&#39;2017-01-08&#39;) |\n+--------------------+\n|                  2 |\n+--------------------+\nmysql&amp;gt; select WEEK(&#39;2017-01-08&#39;,0);\n+----------------------+\n| WEEK(&#39;2017-01-08&#39;,0) |\n+----------------------+\n|                    2 |\n+----------------------+\nmysql&amp;gt; select WEEK(&#39;2017-01-08&#39;,1);\n+----------------------+\n| WEEK(&#39;2017-01-08&#39;,1) |\n+----------------------+\n|                    1 |\n+----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;YEAR(date)&lt;/strong&gt;&lt;br&gt;\n返回date的年份，范围在1000到9999。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select YEAR(&#39;2017-01-06&#39;);\n+--------------------+\n| YEAR(&#39;2017-01-06&#39;) |\n+--------------------+\n|               2017 |\n+--------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;HOUR(time)&lt;/strong&gt;&lt;br&gt;\n返回time的小时，范围是0到23。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select HOUR(&#39;12:05:03&#39;);\n+------------------+\n| HOUR(&#39;12:05:03&#39;) |\n+------------------+\n|               12 |\n+------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;MINUTE(time)&lt;/strong&gt;&lt;br&gt;\n返回time的分钟，范围是0到59。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select MINUTE(&#39;2017-01-06 12:05:03&#39;);\n+-------------------------------+\n| MINUTE(&#39;2017-01-06 12:05:03&#39;) |\n+-------------------------------+\n|                             5 |\n+-------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SECOND(time)&lt;/strong&gt;&lt;br&gt;\n回来time的秒数，范围是0到59。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SECOND(&#39;12:05:03&#39;);\n+--------------------+\n| SECOND(&#39;12:05:03&#39;) |\n+--------------------+\n|                  3 |\n+--------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;PERIOD_ADD(P,N)&lt;/strong&gt;&lt;br&gt;\n增加N个月到阶段P（以格式YYMM或YYYYMM)。以格式YYYYMM返回值。注意阶段参数P不是日期值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select PERIOD_ADD(201701,2); \n+----------------------+\n| PERIOD_ADD(201701,2) |\n+----------------------+\n|               201703 |\n+----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;PERIOD_DIFF(P1,P2)&lt;/strong&gt;&lt;br&gt;\n返回在时期P1和P2之间月数，P1和P2应该以格式YYMM或YYYYMM。注意，时期参数P1和P2不是日期值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select PERIOD_DIFF(1602,201701);\n+--------------------------+\n| PERIOD_DIFF(1602,201701) |\n+--------------------------+\n|                      -11 |\n+--------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;DATE_ADD(date,INTERVAL expr type)、DATE_SUB(date,INTERVAL expr type)、ADDDATE(date,INTERVAL expr type)、SUBDATE(date,INTERVAL expr type)&lt;/strong&gt;&lt;br&gt;\n这些功能执行日期运算。对于MySQL 3.22，他们是新的。ADDDATE()和SUBDATE()是DATE_ADD()和DATE_SUB()的同义词。在MySQL 3.23中，你可以使用+和-而不是DATE_ADD()和DATE_SUB()。（见例子）date是一个指定开始日期的DATETIME或DATE值，expr是指定加到开始日期或从开始日期减去的间隔值一个表达式，expr是一个字符串；它可以以一个“-”开始表示负间隔。type是一个关键词，指明表达式应该如何被解释。EXTRACT(type FROM date)函数从日期中返回“type”间隔。下表显示了type和expr参数怎样被关联： type值 含义 期望的expr格式&lt;br&gt;\nSECOND 秒 SECONDS&lt;br&gt;\nMINUTE 分钟 MINUTES&lt;br&gt;\nHOUR 时间 HOURS&lt;br&gt;\nDAY 天 DAYS&lt;br&gt;\nMONTH 月 MONTHS&lt;br&gt;\nYEAR 年 YEARS&lt;br&gt;\nMINUTE_SECOND 分钟和秒 &amp;quot;MINUTES:SECONDS&amp;quot;&lt;br&gt;\nHOUR_MINUTE 小时和分钟 &amp;quot;HOURS:MINUTES&amp;quot;&lt;br&gt;\nDAY_HOUR 天和小时 &amp;quot;DAYS HOURS&amp;quot;&lt;br&gt;\nYEAR_MONTH 年和月 &amp;quot;YEARS-MONTHS&amp;quot;&lt;br&gt;\nHOUR_SECOND 小时, 分钟， &amp;quot;HOURS:MINUTES:SECONDS&amp;quot;&lt;br&gt;\nDAY_MINUTE 天, 小时, 分钟 &amp;quot;DAYS HOURS:MINUTES&amp;quot;&lt;br&gt;\nDAY_SECOND 天, 小时, 分钟, 秒 &amp;quot;DAYS HOURS:MINUTES:SECONDS&amp;quot;&lt;br&gt;\nMySQL在expr格式中允许任何标点分隔符。表示显示的是建议的分隔符。如果date参数是一个DATE值并且你的计算仅仅包含YEAR、MONTH和DAY部分(即，没有时间部分)，结果是一个DATE值。否则结果是一个DATETIME值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; SELECT &amp;quot;2017-01-06 12:05:03&amp;quot; + INTERVAL 1 SECOND;                 \n+-------------------------------------------+\n| &amp;quot;2017-01-06 12:05:03&amp;quot; + INTERVAL 1 SECOND |\n+-------------------------------------------+\n| 2017-01-06 12:05:04                       |\n+-------------------------------------------+\nmysql&amp;gt; SELECT INTERVAL 1 DAY + &amp;quot;2017-01-06&amp;quot;;\n+-------------------------------+\n| INTERVAL 1 DAY + &amp;quot;2017-01-06&amp;quot; |\n+-------------------------------+\n| 2017-01-07                    |\n+-------------------------------+\nmysql&amp;gt; SELECT &amp;quot;2017-01-06&amp;quot; - INTERVAL 1 SECOND;          \n+----------------------------------+\n| &amp;quot;2017-01-06&amp;quot; - INTERVAL 1 SECOND |\n+----------------------------------+\n| 2017-01-05 23:59:59              |\n+----------------------------------+\nmysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 SECOND);                   \n+----------------------------------------------------+\n| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 SECOND) |\n+----------------------------------------------------+\n| 2017-01-06 12:05:04                                |\n+----------------------------------------------------+\nmysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 DAY);                   \n+-------------------------------------------------+\n| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL 1 DAY) |\n+-------------------------------------------------+\n| 2017-01-07 12:05:03                             |\n+-------------------------------------------------+\nmysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1:1&amp;quot; MINUTE_SECOND);                   \n+---------------------------------------------------------------+\n| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1:1&amp;quot; MINUTE_SECOND) |\n+---------------------------------------------------------------+\n| 2017-01-06 12:06:04                                           |\n+---------------------------------------------------------------+\nmysql&amp;gt; SELECT DATE_SUB(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1 1:1:1&amp;quot; DAY_SECOND);                   \n+----------------------------------------------------------------+\n| DATE_SUB(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;1 1:1:1&amp;quot; DAY_SECOND) |\n+----------------------------------------------------------------+\n| 2017-01-05 11:04:02                                            |\n+----------------------------------------------------------------+\nmysql&amp;gt; SELECT DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;-1 10&amp;quot; DAY_HOUR);                   \n+------------------------------------------------------------+\n| DATE_ADD(&amp;quot;2017-01-06 12:05:03&amp;quot;, INTERVAL &amp;quot;-1 10&amp;quot; DAY_HOUR) |\n+------------------------------------------------------------+\n| 2017-01-05 02:05:03                                        |\n+------------------------------------------------------------+\nmysql&amp;gt; SELECT DATE_SUB(&amp;quot;2017-01-06&amp;quot;, INTERVAL 31 DAY);          \n+-----------------------------------------+\n| DATE_SUB(&amp;quot;2017-01-06&amp;quot;, INTERVAL 31 DAY) |\n+-----------------------------------------+\n| 2016-12-06                              |\n+-----------------------------------------+\nmysql&amp;gt; SELECT EXTRACT(YEAR FROM &amp;quot;2017-01-06&amp;quot;);\n+---------------------------------+\n| EXTRACT(YEAR FROM &amp;quot;2017-01-06&amp;quot;) |\n+---------------------------------+\n|                            2017 |\n+---------------------------------+\nmysql&amp;gt; SELECT EXTRACT(YEAR_MONTH FROM &amp;quot;2017-01-06 12:05:03&amp;quot;);\n+------------------------------------------------+\n| EXTRACT(YEAR_MONTH FROM &amp;quot;2017-01-06 12:05:03&amp;quot;) |\n+------------------------------------------------+\n|                                         201701 |\n+------------------------------------------------+\nmysql&amp;gt; SELECT EXTRACT(DAY_MINUTE FROM &amp;quot;2017-01-06 12:05:03&amp;quot;);\n+------------------------------------------------+\n| EXTRACT(DAY_MINUTE FROM &amp;quot;2017-01-06 12:05:03&amp;quot;) |\n+------------------------------------------------+\n|                                          61205 |\n+------------------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果你指定太短的间隔值(不包括type关键词期望的间隔部分)，MySQL假设你省掉了间隔值的最左面部分。例如，如果你指定一个type是DAY_SECOND，值expr被希望有天、小时、分钟和秒部分。如果你象&amp;quot;1:10&amp;quot;这样指定值，MySQL假设日子和小时部分是丢失的并且值代表分钟和秒。换句话说，&amp;quot;1:10&amp;quot; DAY_SECOND以它等价于&amp;quot;1:10&amp;quot; MINUTE_SECOND的方式解释，这对那MySQL解释TIME值表示经过的时间而非作为一天的时间的方式有二义性。如果你使用确实不正确的日期，结果是NULL。如果你增加MONTH、YEAR_MONTH或YEAR并且结果日期大于新月份的最大值天数，日子在新月用最大的天调整。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DATE_ADD(&#39;2017-01-06&#39;, Interval 1 month);          \n+------------------------------------------+\n| DATE_ADD(&#39;2017-01-06&#39;, Interval 1 month) |\n+------------------------------------------+\n| 2017-02-06                               |\n+------------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意，从前面的例子中词INTERVAL和type关键词不是区分大小写的。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;TO_DAYS(date)&lt;/strong&gt;&lt;br&gt;\n给出一个日期date，返回一个天数(从0年的天数)。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select TO_DAYS(170106);\n+-----------------+\n| TO_DAYS(170106) |\n+-----------------+\n|          736700 |\n+-----------------+\nmysql&amp;gt; select TO_DAYS(&#39;2017-01-06&#39;);\n+-----------------------+\n| TO_DAYS(&#39;2017-01-06&#39;) |\n+-----------------------+\n|                736700 |\n+-----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;FROM_DAYS(N)&lt;/strong&gt;&lt;br&gt;\n给出一个天数N，返回一个DATE值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select FROM_DAYS(736700);\n+-------------------+\n| FROM_DAYS(736700) |\n+-------------------+\n| 2017-01-06        |\n+-------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;DATE_FORMAT(date,format)&lt;/strong&gt;&lt;br&gt;\n根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December)&lt;br&gt;\n%W 星期名字(Sunday……Saturday)&lt;br&gt;\n%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）&lt;br&gt;\n%Y 年, 数字, 4 位&lt;br&gt;\n%y 年, 数字, 2 位&lt;br&gt;\n%a 缩写的星期名字(Sun……Sat)&lt;br&gt;\n%d 月份中的天数, 数字(00……31)&lt;br&gt;\n%e 月份中的天数, 数字(0……31)&lt;br&gt;\n%m 月, 数字(01……12)&lt;br&gt;\n%c 月, 数字(1……12)&lt;br&gt;\n%b 缩写的月份名字(Jan……Dec)&lt;br&gt;\n%j 一年中的天数(001……366)&lt;br&gt;\n%H 小时(00……23)&lt;br&gt;\n%k 小时(0……23)&lt;br&gt;\n%h 小时(01……12)&lt;br&gt;\n%I 小时(01……12)&lt;br&gt;\n%l 小时(1……12)&lt;br&gt;\n%i 分钟, 数字(00……59)&lt;br&gt;\n%r 时间,12 小时(hh:mm:ss [AP]M)&lt;br&gt;\n%T 时间,24 小时(hh:mm:ss)&lt;br&gt;\n%S 秒(00……59)&lt;br&gt;\n%s 秒(00……59)&lt;br&gt;\n%p AM或PM&lt;br&gt;\n%w 一个星期中的天数(0=Sunday ……6=Saturday ）&lt;br&gt;\n%U 星期(0……52), 这里星期天是星期的第一天&lt;br&gt;\n%u 星期(0……52), 这里星期一是星期的第一天&lt;br&gt;\n%% 一个文字“%”。&lt;/p&gt;\n&lt;p&gt;所有的其他字符不做解释被复制到结果中。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%W %M %Y&#39;);                   \n+------------------------------------------------+\n| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%W %M %Y&#39;) |\n+------------------------------------------------+\n| Friday January 2017                            |\n+------------------------------------------------+\nmysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H:%i:%s&#39;);                   \n+------------------------------------------------+\n| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H:%i:%s&#39;) |\n+------------------------------------------------+\n| 12:05:03                                       |\n+------------------------------------------------+\nmysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%D %y %a %d %m %b %j&#39;);                   \n+------------------------------------------------------------+\n| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%D %y %a %d %m %b %j&#39;) |\n+------------------------------------------------------------+\n| 6th 17 Fri 06 01 Jan 006                                   |\n+------------------------------------------------------------+\nmysql&amp;gt; select DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H %k %I %r %T %S %w&#39;);                   \n+------------------------------------------------------------+\n| DATE_FORMAT(&#39;2017-01-06 12:05:03&#39;, &#39;%H %k %I %r %T %S %w&#39;) |\n+------------------------------------------------------------+\n| 12 12 12 12:05:03 PM 12:05:03 03 5                         |\n+------------------------------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;TIME_FORMAT(time,format)&lt;/strong&gt;&lt;br&gt;\n这象上面的DATE_FORMAT()函数一样使用，但是format字符串只能包含处理小时、分钟和秒的那些格式修饰符。其他修饰符产生一个NULL值或0。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;CURDATE()、CURRENT_DATE&lt;/strong&gt;&lt;br&gt;\n以&#39;YYYY-MM-DD&#39;或YYYYMMDD格式返回今天日期值，取决于函数是在一个字符串还是数字上下文被使用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select CURDATE();\n+------------+\n| CURDATE()  |\n+------------+\n| 2017-01-06 |\n+------------+\nmysql&amp;gt; select CURDATE()+2; \n+-------------+\n| CURDATE()+2 |\n+-------------+\n|    20170108 |\n+-------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;CURRENT_TIME&lt;/strong&gt;&lt;br&gt;\n以&#39;HH:MM:SS&#39;或HHMMSS格式返回当前时间值，取决于函数是在一个字符串还是在数字的上下文被使用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select CURTIME();\n+-----------+\n| CURTIME() |\n+-----------+\n| 13:55:04  |\n+-----------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;NOW()、SYSDATE()、CURRENT_TIMESTAMP&lt;/strong&gt;&lt;br&gt;\n以&#39;YYYY-MM-DD HH:MM:SS&#39;或YYYYMMDDHHMMSS格式返回当前的日期和时间，取决于函数是在一个字符串还是在数字的上下文被使用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select NOW();\n+---------------------+\n| NOW()               |\n+---------------------+\n| 2017-01-06 13:57:02 |\n+---------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;UNIX_TIMESTAMP()、UNIX_TIMESTAMP(date)&lt;/strong&gt;&lt;br&gt;\n如果没有参数调用，返回一个Unix时间戳记(从&#39;1970-01-01 00:00:00&#39;GMT开始的秒数)。如果UNIX_TIMESTAMP()用一个date参数被调用，它返回从&#39;1970-01-01 00:00:00&#39; GMT开始的秒数值。date可以是一个DATE字符串、一个DATETIME字符串、一个TIMESTAMP或以YYMMDD或YYYYMMDD格式的本地时间的一个数字。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select UNIX_TIMESTAMP();\n+------------------+\n| UNIX_TIMESTAMP() |\n+------------------+\n|       1483682742 |\n+------------------+\nmysql&amp;gt; select UNIX_TIMESTAMP(&#39;2017-01-06 12:05:03&#39;);\n+---------------------------------------+\n| UNIX_TIMESTAMP(&#39;2017-01-06 12:05:03&#39;) |\n+---------------------------------------+\n|                            1483675503 |\n+---------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当UNIX_TIMESTAMP被用于一个TIMESTAMP列，函数将直接接受值，没有隐含的“string-to-unix-timestamp”变换。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;FROM_UNIXTIME(unix_timestamp)&lt;/strong&gt;&lt;br&gt;\n以&#39;YYYY-MM-DD HH:MM:SS&#39;或YYYYMMDDHHMMSS格式返回unix_timestamp参数所表示的值，取决于函数是在一个字符串还是或数字上下文中被使用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select FROM_UNIXTIME(1483682742);\n+---------------------------+\n| FROM_UNIXTIME(1483682742) |\n+---------------------------+\n| 2017-01-06 14:05:42       |\n+---------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;FROM_UNIXTIME(unix_timestamp,format)&lt;/strong&gt;&lt;br&gt;\n返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(), &#39;%Y %D %M %h:%i:%s %x&#39;);\n+---------------------------------------------------------+\n| FROM_UNIXTIME(UNIX_TIMESTAMP(), &#39;%Y %D %M %h:%i:%s %x&#39;) |\n+---------------------------------------------------------+\n| 2017 6th January 02:23:08 2017                          |\n+---------------------------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SEC_TO_TIME(seconds)&lt;/strong&gt;&lt;br&gt;\n返回seconds参数，变换成小时、分钟和秒，值以&#39;HH:MM:SS&#39;或HHMMSS格式化，取决于函数是在一个字符串还是在数字上下文中被使用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SEC_TO_TIME(2378);\n+-------------------+\n| SEC_TO_TIME(2378) |\n+-------------------+\n| 00:39:38          |\n+-------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;TIME_TO_SEC(time)&lt;/strong&gt;&lt;br&gt;\n返回time参数，转换成秒。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select TIME_TO_SEC(&#39;14:05:42&#39;);         \n+-------------------------+\n| TIME_TO_SEC(&#39;14:05:42&#39;) |\n+-------------------------+\n|                   50742 |\n+-------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-time-function&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;DAYOFWEEK(date)&lt;/strong&gt;&lt;br&gt;\n返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select DAYOFWEEK(&#39;2017-01-06&#39;);\n+-------------------------+\n| DAYOFWEEK(&#39;2017-01-06&#39;) |\n+-------------------------+\n|                       6 |\n+-------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;mysql 时间函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;时间函数&#34;,&#34;slug&#34;:&#34;PUF8Y-HO0Qh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/PUF8Y-HO0Qh/&#34;}],&#34;date&#34;:&#34;2017-01-06 12:54:48&#34;,&#34;dateFormat&#34;:&#34;2017-01-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-time-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;13 min read&#34;,&#34;time&#34;:736000,&#34;words&#34;:2581,&#34;minutes&#34;:13},&#34;description&#34;:&#34;DAYOFWEEK(date)\n返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。\nmysql&amp;gt; select DAYOFWEEK(&#39;2017-01-06&#39;);\n+---------...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;ASCII(str)&lt;/strong&gt;&lt;br&gt;\n返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 &lt;!--more--&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select ASCII(&#39;4&#39;);\n+------------+\n| ASCII(&#39;4&#39;) |\n+------------+\n|         52 |\n+------------+\nmysql&amp;gt; select ASCII(4);\n+----------+\n| ASCII(4) |\n+----------+\n|       52 |\n+----------+\nmysql&amp;gt; select ASCII(&#39;dx&#39;);\n+-------------+\n| ASCII(&#39;ex&#39;) |\n+-------------+\n|         101 |\n+-------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;也可参见ORD()函数。&lt;br&gt;\n**ORD(str) **&lt;br&gt;\n如果字符串str最左面字符是一个多字节字符，通过以格式((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]返回字符的ASCII代码值来返回多字节字符代码。如果最左面的字符不是一个多字节字符。返回与ASCII()函数返回的相同值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select ORD(&#39;3&#39;);\n+----------+\n| ORD(&#39;3&#39;) |\n+----------+\n|       51 |\n+----------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;CONV(N,from_base,to_base)&lt;/strong&gt;&lt;br&gt;\n在不同的数字基之间变换数字。返回数字N的字符串数字，从from_base基变换为to_base基，如果任何参数是NULL，返回NULL。参数N解释为一个整数，但是可以指定为一个整数或一个字符串。最小基是2且最大的基是36。如果to_base是一个负数，N被认为是一个有符号数，否则，N被当作无符号数。 CONV以64位点精度工作。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select CONV(&amp;quot;A&amp;quot;,16,2);\n+----------------+\n| CONV(&amp;quot;A&amp;quot;,16,2) |\n+----------------+\n| 1010           |\n+----------------+\nmysql&amp;gt; select CONV(&amp;quot;6EB&amp;quot;,18,8);\n+------------------+\n| CONV(&amp;quot;6EB&amp;quot;,18,8) |\n+------------------+\n| 4237             |\n+------------------+\nmysql&amp;gt; select CONV(-178,10,-18);\n+-------------------+\n| CONV(-178,10,-18) |\n+-------------------+\n| -9G               |\n+-------------------+\nmysql&amp;gt; select CONV(10+&amp;quot;10&amp;quot;+&#39;10&#39;+0xB,10,10);\n+------------------------------+\n| CONV(10+&amp;quot;10&amp;quot;+&#39;10&#39;+0xB,10,10) |\n+------------------------------+\n| 41                           |\n+------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**BIN(N) **&lt;br&gt;\n返回二进制值N的一个字符串表示，在此N是一个长整数(BIGINT)数字，这等价于CONV(N,10,2)。如果N是NULL，返回NULL。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select BIN(532);\n+------------+\n| BIN(532)   |\n+------------+\n| 1000010100 |\n+------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;OCT(N)&lt;/strong&gt;&lt;br&gt;\n返回八进制值N的一个字符串的表示，在此N是一个长整型数字，这等价于CONV(N,10,8)。如果N是NULL，返回NULL。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select OCT(98);\n+---------+\n| OCT(98) |\n+---------+\n| 142     |\n+---------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;HEX(N)&lt;/strong&gt;&lt;br&gt;\n返回十六进制值N一个字符串的表示，在此N是一个长整型(BIGINT)数字，这等价于CONV(N,10,16)。如果N是NULL，返回NULL。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select HEX(432);\n+----------+\n| HEX(432) |\n+----------+\n| 1B0      |\n+----------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;CHAR(N,...)&lt;/strong&gt;&lt;br&gt;\nCHAR()将参数解释为整数并且返回由这些整数的ASCII代码字符组成的一个字符串。NULL值被跳过。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select CHAR(77, 121, 83, 81,&#39;76&#39;);\n+----------------------------+\n| CHAR(77, 121, 83, 81,&#39;76&#39;) |\n+----------------------------+\n| MySQL                      |\n+----------------------------+\nmysql&amp;gt; select CHAR(77,77.3,&#39;77.3&#39;);\n+----------------------+\n| CHAR(77,77.3,&#39;77.3&#39;) |\n+----------------------+\n| MMM                  |\n+----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;CONCAT(str1,str2,...)&lt;/strong&gt;&lt;br&gt;\n返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select CONCAT(&#39;My&#39;, &#39;S&#39;, &#39;QL&#39;);\n+-------------------------+\n| CONCAT(&#39;My&#39;, &#39;S&#39;, &#39;QL&#39;) |\n+-------------------------+\n| MySQL                   |\n+-------------------------+\nmysql&amp;gt; select CONCAT(&#39;My&#39;, NULL, &#39;QL&#39;);\n+--------------------------+\n| CONCAT(&#39;My&#39;, NULL, &#39;QL&#39;) |\n+--------------------------+\n| NULL                     |\n+--------------------------+\nmysql&amp;gt; select CONCAT(14.3);\n+--------------+\n| CONCAT(14.3) |\n+--------------+\n| 14.3         |\n+--------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LENGTH(str)、OCTET_LENGTH(str)、CHAR_LENGTH(str)、CHARACTER_LENGTH(str)&lt;/strong&gt;&lt;br&gt;\n返回字符串str的长度。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select LENGTH(&#39;hello world&#39;);\n+-----------------------+\n| LENGTH(&#39;hello world&#39;) |\n+-----------------------+\n|                    11 |\n+-----------------------+\nmysql&amp;gt; select OCTET_LENGTH(&#39;hello world&#39;);\n+-----------------------------+\n| OCTET_LENGTH(&#39;hello world&#39;) |\n+-----------------------------+\n|                          11 |\n+-----------------------------+\n注意，对于多字节字符，其CHAR_LENGTH()仅计算一次。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LOCATE(substr,str,pos)、POSITION(substr IN str)&lt;/strong&gt;&lt;br&gt;\n返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0&lt;br&gt;\n如果设置了pos值，那么起始位置将从pos处，否则从1开始。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;);\n+----------------------------+\n| LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;) |\n+----------------------------+\n|                          4 |\n+----------------------------+\nmysql&amp;gt; select LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;, 5);\n+-------------------------------+\n| LOCATE(&#39;bar&#39;, &#39;foobarbar&#39;, 5) |\n+-------------------------------+\n|                             7 |\n+-------------------------------+\n这函数是多字节可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;INSTR(str,substr)&lt;/strong&gt;&lt;br&gt;\n返回子串substr在字符串str中的第一个出现的位置。这与有2个参数形式的LOCATE()相同，除了参数被颠倒。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select INSTR(&#39;foobarbar&#39;, &#39;bar&#39;);\n+---------------------------+\n| INSTR(&#39;foobarbar&#39;, &#39;bar&#39;) |\n+---------------------------+\n|                         4 |\n+---------------------------+\n这函数是多字节可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LPAD(str,len,padstr)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，左面用字符串padstr填补直到str是len个字符长。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select LPAD(&#39;A&#39;,5,&#39;BCD&#39;);\n+-------------------+\n| LPAD(&#39;A&#39;,5,&#39;BCD&#39;) |\n+-------------------+\n| BCDBA             |\n+-------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;RPAD(str,len,padstr)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，右面用字符串padstr填补直到str是len个字符长。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select RPAD(&#39;A&#39;,5,&#39;BCD&#39;);\n+-------------------+\n| RPAD(&#39;A&#39;,5,&#39;BCD&#39;) |\n+-------------------+\n| ABCDB             |\n+-------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LEFT(str,len)&lt;/strong&gt;&lt;br&gt;\n返回字符串str的最左面len个字符。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select LEFT(&#39;hello world&#39;, 7);\n+------------------------+\n| LEFT(&#39;hello world&#39;, 7) |\n+------------------------+\n| hello w                |\n+------------------------+\n该函数是多字节可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;RIGHT(str,len)&lt;/strong&gt;&lt;br&gt;\n返回字符串str的最右面len个字符。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select RIGHT(&#39;hello world&#39;, 7);       \n+-------------------------+\n| RIGHT(&#39;hello world&#39;, 7) |\n+-------------------------+\n| o world                 |\n+-------------------------+\n该函数是多字节可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)、MID(str,pos,len)&lt;/strong&gt;&lt;br&gt;\n从字符串str返回一个len个字符的子串，从位置pos开始。使用FROM的变种形式是ANSI SQL92语法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SUBSTRING(&#39;abcdefghijk&#39;,5,6);  \n+------------------------------+\n| SUBSTRING(&#39;abcdefghijk&#39;,5,6) |\n+------------------------------+\n| efghij                       |\n+------------------------------+\n该函数是多字节可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SUBSTRING(str,pos)、SUBSTRING(str FROM pos)&lt;/strong&gt;&lt;br&gt;\n从字符串str的起始位置pos返回一个子串。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SUBSTRING(&#39;abcdefghijk&#39;,5);  \n+----------------------------+\n| SUBSTRING(&#39;abcdefghijk&#39;,5) |\n+----------------------------+\n| efghijk                    |\n+----------------------------+\n该函数是多字节可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SUBSTRING_INDEX(str,delim,count)&lt;/strong&gt;&lt;br&gt;\n返回从字符串str的第count个出现的分隔符delim之后的子串。如果count是正数，返回最后的分隔符到左边(从左边数) 的所有字符。如果count是负数，返回最后的分隔符到右边的所有字符(从右边数)。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SUBSTRING_INDEX(&#39;http://blog.imarkofu.com&#39;, &#39;.&#39;, 2);         \n+-----------------------------------------------------+\n| SUBSTRING_INDEX(&#39;http://blog.imarkofu.com&#39;, &#39;.&#39;, 2) |\n+-----------------------------------------------------+\n| http://blog.imarkofu                                |\n+-----------------------------------------------------+\n该函数对多字节是可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LTRIM(str)&lt;/strong&gt;&lt;br&gt;\n返回删除了其前置空格字符的字符串str。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select LTRIM(&#39;   hello world   &#39;); \n+----------------------------+\n| LTRIM(&#39;   hello world   &#39;) |\n+----------------------------+\n| hello world                |\n+----------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;RTRIM(str)&lt;/strong&gt;&lt;br&gt;\n返回删除了其拖后空格字符的字符串str。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select RTRIM(&#39;   hello world   &#39;);  \n+----------------------------+\n| RTRIM(&#39;   hello world   &#39;) |\n+----------------------------+\n|    hello world             |\n+----------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，其所有remstr前缀或后缀被删除了。如果没有修饰符BOTH、LEADING或TRAILING给出，BOTH被假定。如果remstr没被指定，空格被删除。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select TRIM(&#39;   hello world   &#39;); \n+---------------------------+\n| TRIM(&#39;   hello world   &#39;) |\n+---------------------------+\n| hello world               |\n+---------------------------+\nmysql&amp;gt; select TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);\n+------------------------------------+\n| TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;) |\n+------------------------------------+\n| barxxx                             |\n+------------------------------------+\nmysql&amp;gt; select TRIM(TRAILING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);       \n+-------------------------------------+\n| TRIM(TRAILING &#39;x&#39; FROM &#39;xxxbarxxx&#39;) |\n+-------------------------------------+\n| xxxbar                              |\n+-------------------------------------+\nmysql&amp;gt; select TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;);        \n+---------------------------------+\n| TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;) |\n+---------------------------------+\n| bar                             |\n+---------------------------------+\n该函数对多字节是可靠的。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SOUNDEX(str)&lt;/strong&gt;&lt;br&gt;\n返回str的一个同音字符串。听起来“大致相同”的2个字符串应该有相同的同音字符串。一个“标准”的同音字符串长是4个字符，但是SOUNDEX()函数返回一个任意长的字符串。你可以在结果上使用SUBSTRING()得到一个“标准”的 同音串。所有非数字字母字符在给定的字符串中被忽略。所有在A-Z之外的字符国际字母被当作元音。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SOUNDEX(&#39;Hello&#39;);\n+------------------+\n| SOUNDEX(&#39;Hello&#39;) |\n+------------------+\n| H400             |\n+------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;SPACE(N)&lt;/strong&gt;&lt;br&gt;\n返回由N个空格字符组成的一个字符串。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select SPACE(32);\n+----------------------------------+\n| SPACE(32)                        |\n+----------------------------------+\n|                                  |\n+----------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;REPLACE(str,from_str,to_str)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，其字符串from_str的所有出现由字符串to_str代替。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select REPLACE(&#39;www.mysql.com&#39;, &#39;w&#39;, &#39;M&#39;); \n+------------------------------------+\n| REPLACE(&#39;www.mysql.com&#39;, &#39;w&#39;, &#39;M&#39;) |\n+------------------------------------+\n| MMM.mysql.com                      |\n+------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;REPEAT(str,count)&lt;/strong&gt;&lt;br&gt;\n返回由重复countTimes次的字符串str组成的一个字符串。如果count &amp;lt;= 0，返回一个空字符串。如果str或count是NULL，返回NULL。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select REPEAT(&#39;MySQL&#39;, 3);\n+--------------------+\n| REPEAT(&#39;MySQL&#39;, 3) |\n+--------------------+\n| MySQLMySQLMySQL    |\n+--------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;REVERSE(str)&lt;/strong&gt;&lt;br&gt;\n返回颠倒字符顺序的字符串str。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select REVERSE(&#39;abc&#39;);\n+----------------+\n| REVERSE(&#39;abc&#39;) |\n+----------------+\n| cba            |\n+----------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;INSERT(str,pos,len,newstr)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，在位置pos起始的子串且len个字符长得子串由字符串newstr代替。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select INSERT(&#39;Quadratic&#39;, 3, 5, &#39;What&#39;); \n+-----------------------------------+\n| INSERT(&#39;Quadratic&#39;, 3, 5, &#39;What&#39;) |\n+-----------------------------------+\n| QuWhatic                          |\n+-----------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;ELT(N,str1,str2,str3,...)&lt;/strong&gt;&lt;br&gt;\n如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select ELT(1, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;);           \n+----------------------------+\n| ELT(1, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;) |\n+----------------------------+\n| A                          |\n+----------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;FIELD(str,str1,str2,str3,...)&lt;/strong&gt;&lt;br&gt;\n返回str在str1, str2, str3, ...清单的索引。如果str没找到，返回0。FIELD()是ELT()反运算。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select FIELD(&#39;F&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;EF&#39;);\n+--------------------------------------+\n| FIELD(&#39;F&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;EF&#39;) |\n+--------------------------------------+\n|                                    0 |\n+--------------------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;FIND_IN_SET(str,strlist)&lt;/strong&gt;&lt;br&gt;\n如果字符串str在由N子串组成的表strlist之中，返回一个1到N的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为SET的列，FIND_IN_SET()函数被优化而使用位运算！如果str不是在strlist里面或如果strlist是空字符串，返回0。如果任何一个参数是NULL，返回NULL。如果第一个参数包含一个“,”，该函数将工作不正常。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; SELECT FIND_IN_SET(&#39;C&#39;,&#39;A,B,C,D&#39;);\n+----------------------------+\n| FIND_IN_SET(&#39;C&#39;,&#39;A,B,C,D&#39;) |\n+----------------------------+\n|                          3 |\n+----------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;MAKE_SET(bits,str1,str2,...)&lt;/strong&gt;&lt;br&gt;\n返回一个集合 (包含由“,”字符分隔的子串组成的一个字符串)，由相应的位在bits集合中的的字符串组成。str1对应于位0，str2对应位1，等等。在str1, str2, ...中的NULL串不添加到结果中。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; SELECT MAKE_SET(4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);\n+-------------------------+\n| MAKE_SET(4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) |\n+-------------------------+\n| c                       |\n+-------------------------+\nmysql&amp;gt; SELECT MAKE_SET(1|4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);\n+---------------------------+\n| MAKE_SET(1|4,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) |\n+---------------------------+\n| a,c                       |\n+---------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;EXPORT_SET(bits,on,off,[separator,[number_of_bits]])&lt;/strong&gt;&lt;br&gt;\n返回一个字符串，在这里对于在“bits”中设定每一位，你得到一个“on”字符串，并且对于每个复位(reset)的位，你得到一个“off”字符串。每个字符串用“separator”分隔(缺省“,”)，并且只有“bits”的“number_of_bits” (缺省64)位被使用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select EXPORT_SET(7,&#39;Y&#39;,&#39;N&#39;,&#39;,&#39;,6);\n+-----------------------------+\n| EXPORT_SET(7,&#39;Y&#39;,&#39;N&#39;,&#39;,&#39;,6) |\n+-----------------------------+\n| Y,Y,Y,N,N,N                 |\n+-----------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LCASE(str)、LOWER(str)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成小写。该函数对多字节是可靠的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select LOWER(&#39;Imarkofu&#39;);     \n+-------------------+\n| LOWER(&#39;Imarkofu&#39;) |\n+-------------------+\n| imarkofu          |\n+-------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;UCASE(str)、UPPER(str)&lt;/strong&gt;&lt;br&gt;\n返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成大写。该函数对多字节是可靠的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select UPPER(&#39;Imarkofu&#39;);\n+-------------------+\n| UPPER(&#39;Imarkofu&#39;) |\n+-------------------+\n| IMARKOFU          |\n+-------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LOAD_FILE(file_name)&lt;/strong&gt;&lt;br&gt;\n读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select load_file(&amp;quot;/abc.txt&amp;quot;);                                        \n+-----------------------+\n| load_file(&amp;quot;/abc.txt&amp;quot;) |\n+-----------------------+\n| ABC\n                  |\n+-----------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;MySQL必要时自动变换数字为字符串，并且反过来也如此：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; SELECT 3+&amp;quot;2&amp;quot;;\n+-------+\n| 3+&amp;quot;2&amp;quot; |\n+-------+\n|     5 |\n+-------+\nmysql&amp;gt; SELECT CONCAT(3+&amp;quot;2&amp;quot;,&#39; total&#39;);\n+------------------------+\n| CONCAT(3+&amp;quot;2&amp;quot;,&#39; total&#39;) |\n+------------------------+\n| 5 total                |\n+------------------------+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。&lt;br&gt;\n如果字符串函数提供一个二进制字符串作为参数，结果字符串也是一个二进制字符串。被变换到一个字符串的数字被当作是一个二进制字符串。这仅影响比较;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-function&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;mysql字符函数详解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;字符函数&#34;,&#34;slug&#34;:&#34;TdLaiC1bqqf&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/TdLaiC1bqqf/&#34;}],&#34;date&#34;:&#34;2016-12-29 15:24:31&#34;,&#34;dateFormat&#34;:&#34;2016-12-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/mysql-function/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;12 min read&#34;,&#34;time&#34;:682000,&#34;words&#34;:2589,&#34;minutes&#34;:12},&#34;description&#34;:&#34;ASCII(str)\n返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 \nmysql&amp;gt; select ASCII(&#39;4&#39;);\n+------------+\n| ASCI...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;date命令是显示或设置系统时间与日期。&lt;br&gt;\n很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。&lt;!--more--&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;选项\&#34;&gt;选项&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;-d&amp;lt;字符串&amp;gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；&lt;br&gt;\n-s&amp;lt;字符串&amp;gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；&lt;br&gt;\n-u：显示GMT；&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;参数\&#34;&gt;参数&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&amp;lt;+时间日期格式&amp;gt;：指定显示时使用的日期时间格式。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;日期格式字符串列表\&#34;&gt;日期格式字符串列表&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;%H 小时，24小时制（00~23）&lt;br&gt;\n%I 小时，12小时制（01~12）&lt;br&gt;\n%k 小时，24小时制（0~23）&lt;br&gt;\n%l 小时，12小时制（1~12）&lt;br&gt;\n%M 分钟（00~59）&lt;br&gt;\n%p 显示出AM或PM&lt;br&gt;\n%r 显示时间，12小时制（hh:mm:ss %p）&lt;br&gt;\n%s 从1970年1月1日00:00:00到目前经历的秒数&lt;br&gt;\n%S 显示秒（00~59）&lt;br&gt;\n%T 显示时间，24小时制（hh:mm:ss）&lt;br&gt;\n%X 显示时间的格式（%H:%M:%S）&lt;br&gt;\n%Z 显示时区，日期域（CST）&lt;br&gt;\n%a 星期的简称（Sun~Sat）&lt;br&gt;\n%A 星期的全称（Sunday~Saturday）&lt;br&gt;\n%h,%b 月的简称（Jan~Dec）&lt;br&gt;\n%B 月的全称（January~December）&lt;br&gt;\n%c 日期和时间（Tue Nov 20 14:12:58 2012）&lt;br&gt;\n%d 一个月的第几天（01~31）&lt;br&gt;\n%x,%D 日期（mm/dd/yy）&lt;br&gt;\n%j 一年的第几天（001~366）&lt;br&gt;\n%m 月份（01~12）&lt;br&gt;\n%w 一个星期的第几天（0代表星期天）&lt;br&gt;\n%W 一年的第几个星期（00~53，星期一为第一天）&lt;br&gt;\n%y 年的最后两个数字（1999则是99）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;实例\&#34;&gt;实例&lt;/h2&gt;\n&lt;p&gt;格式化输出&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date +&amp;quot;%Y-%m-%d&amp;quot;&lt;br&gt;\n2016-12-29&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;输出昨天日期：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -d &amp;quot;1 day ago&amp;quot; +&amp;quot;%Y-%m-%d&amp;quot;&lt;br&gt;\n2016-12-28&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;2秒后输出：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -d &amp;quot;2 second&amp;quot; +&amp;quot;%Y-%m-%d %H:%M.%S&amp;quot;&lt;br&gt;\n2016-12-29 14:37.22&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;传说中的 1234567890 秒：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -d &amp;quot;1970-01-01 1482990408 seconds&amp;quot; +&amp;quot;%Y-%m-%d %H:%m:%S&amp;quot;&lt;br&gt;\n2016-12-29 05:12:48&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;普通转格式：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -d &amp;quot;2016-12-29&amp;quot; +&amp;quot;%Y/%m/%d %H:%M.%S&amp;quot;&lt;br&gt;\n2016/12/29 00:00.00&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;apache格式转换：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -d &amp;quot;Dec 29, 2016 12:00:37 AM&amp;quot; +&amp;quot;%Y-%m-%d %H:%M.%S&amp;quot;&lt;br&gt;\n2016-12-29 00:00.37&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;格式转换后时间游走：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -d &amp;quot;Dec 29, 2016 12:00:37 AM 2 year ago&amp;quot; +&amp;quot;%Y-%m-%d %H:%M.%S&amp;quot;&lt;br&gt;\n2014-12-29 00:00.37&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;加减操作：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;date -s //设置当前时间，只有root权限才能设置，其他只能查看&lt;br&gt;\ndate -s 20161229 //设置成20120523，这样会把具体时间设置成空00:00:00&lt;br&gt;\ndate -s 01:01:01 //设置具体时间，不会对日期做更改&lt;br&gt;\ndate -s &amp;quot;01:01:01 2016-12-29&amp;quot; //这样可以设置全部时间&lt;br&gt;\ndate -s &amp;quot;01:01:01 20161229&amp;quot; //这样可以设置全部时间&lt;br&gt;\ndate -s &amp;quot;2016-12-29 01:01:01&amp;quot; //这样可以设置全部时间&lt;br&gt;\ndate -s &amp;quot;20161229 01:01:01&amp;quot; //这样可以设置全部时间&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-date-command&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;linux date命令&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;linux&#34;,&#34;slug&#34;:&#34;uP-eMausMK8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/uP-eMausMK8/&#34;},{&#34;name&#34;:&#34;date&#34;,&#34;slug&#34;:&#34;153dR0yWTTy&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/153dR0yWTTy/&#34;}],&#34;date&#34;:&#34;2016-12-29 14:19:07&#34;,&#34;dateFormat&#34;:&#34;2016-12-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/linux-date-command/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:212000,&#34;words&#34;:803,&#34;minutes&#34;:4},&#34;description&#34;:&#34;date命令是显示或设置系统时间与日期。\n很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%89%E9%A1%B9\&#34;&gt;选项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E6%95%B0\&#34;&gt;参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8\&#34;&gt;日期格式字符串列表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E4%BE%8B\&#34;&gt;实例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;备份策略\&#34;&gt;备份策略&lt;/h1&gt;\n&lt;p&gt;svn备份一般采用三种方式：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1）svnadmin dump&lt;br&gt;\n2)svnadmin hotcopy&lt;br&gt;\n3)svnsync&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;-more-注意svn备份不宜采用普通的文件拷贝方式除非你备份的时候将库暂停如copy命令-rsync命令-优缺点分析\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n**注意：**svn备份不宜采用普通的文件拷贝方式（除非你备份的时候将库暂停），如copy命令、rsync命令。&lt;br&gt;\n优缺点分析&lt;/h1&gt;\n&lt;p&gt;第一种svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。&lt;br&gt;\n缺点是：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。&lt;br&gt;\n个人建议在版本数比较小的情况下使用这种备份方式。&lt;br&gt;\n第二种svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；&lt;br&gt;\n优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。&lt;br&gt;\n缺点是：比较耗费硬盘，需要有较大的硬盘支持（俺的备份机有1TB空间，呵呵）。&lt;br&gt;\n第三种svnsync实际上是制作2个镜像库，当一个坏了的时候，可以迅速切换到另一个。不过，必须svn1.4版本以上才支持这个功能。&lt;br&gt;\n优点是：当制作成2个镜像库的时候起到双机实时备份的作用；&lt;br&gt;\n缺点是：当作为2个镜像库使用时，没办法做到“想完全抛弃今天的修改恢复到昨晚的样子”；而当作为普通备份机制每日备份时，操作又较前2种方法麻烦。&lt;/p&gt;\n&lt;h1 id=\&#34;备份方案\&#34;&gt;备份方案&lt;/h1&gt;\n&lt;p&gt;以下是个人的备份方案：&lt;br&gt;\n1、定期对线上SVN进行全量备份【目前每月1号】&lt;br&gt;\nsvnadmin dump /仓库路径/仓库名 |gzip &amp;gt; ~/svn/仓库名_yyyyMMdd.gz&lt;br&gt;\n将备份文件统一上传到其他设备的备份目录下进行存档&lt;/p&gt;\n&lt;p&gt;2、定期进行全量备份恢复测试&lt;br&gt;\n解压.gz文件&lt;br&gt;\n建立新的svn仓库&lt;br&gt;\n导入存储库&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;svnadmin load 仓库路径 &amp;lt; 解压的备份文件&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;3、对常用的几个SVN仓库进行热备份&lt;br&gt;\n首先在其他设备上上编译安装SVN&lt;br&gt;\n创建需要备份的仓库（这里以sm为例）&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;svnadmin create 从仓库路径&lt;br&gt;\ncp /从仓库路径/hooks/pre-revprop-change.tmpl /从仓库路径/hooks/pre-revprop-change&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;修改/从仓库路径/hooks/pre-revprop-change的内容，将最后的&amp;quot;exit 1&amp;quot;修改&amp;quot;exit 0&amp;quot;&lt;br&gt;\n增加执行权限&lt;br&gt;\n将主svn的对应仓库目录下的所有配置文件拷贝到从svn的仓库目录下覆盖替换&lt;/p&gt;\n&lt;p&gt;在从SVN上执行如下命令，进行初始化【这里尚未开始进行同步】&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;svnsync init 从仓库地址  主仓库地址&lt;br&gt;\nsvnsync init file:///从仓库路径 主仓库地址&lt;br&gt;\n注意这里是三个/&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;这里会询问当前Linux用户的密码，主SVN用户名，主SVN密码&lt;br&gt;\n输入相应即可，然后会询问是否明文存储【这里建议输入no不存在，每次自行输入】&lt;/p&gt;\n&lt;p&gt;开始同步数据&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;svnsync sync file:///从仓库路径&lt;br&gt;\n这里如果又用户正在提交SVN时，可能会出现获取锁失败的问题，需要清除锁的命令，再继续同步&lt;br&gt;\nsvn propdel svn:sync-lock --revprop -r0  file:///从仓库路径&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;同步完成之后，为了保证后续的SVN更新都能自动同步到从svn中&lt;br&gt;\n需要在主SVN的/仓库路径/hooks下建立post-commit脚本，增加如下内容&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;svnsync sync --non-interactive 从仓库地址 --username 用户名 --password 密码&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;至此双击热备份即完成，可能还需要做的是定期抽查热备是否正常；&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;svn-backup&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;备份策略\&#34;&gt;备份策略&lt;/h1&gt;\n&lt;p&gt;svn备份一般采用三种方式：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1）svnadmin dump&lt;br&gt;\n2)svnadmin hotcopy&lt;br&gt;\n3)svnsync&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;SVN备份方案&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;linux&#34;,&#34;slug&#34;:&#34;uP-eMausMK8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/uP-eMausMK8/&#34;},{&#34;name&#34;:&#34;svn&#34;,&#34;slug&#34;:&#34;m9isOQnn39E&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/m9isOQnn39E/&#34;},{&#34;name&#34;:&#34;svn备份&#34;,&#34;slug&#34;:&#34;WkF0AcVRW5D&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/WkF0AcVRW5D/&#34;}],&#34;date&#34;:&#34;2016-12-01 15:07:43&#34;,&#34;dateFormat&#34;:&#34;2016-12-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/svn-backup/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:211000,&#34;words&#34;:970,&#34;minutes&#34;:4},&#34;description&#34;:&#34;备份策略\nsvn备份一般采用三种方式：\n\n1）svnadmin dump\n2)svnadmin hotcopy\n3)svnsync\n\n\n**注意：**svn备份不宜采用普通的文件拷贝方式（除非你备份的时候将库暂停），如copy命令、rsyn...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5\&#34;&gt;备份策略&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-%E6%B3%A8%E6%84%8Fsvn%E5%A4%87%E4%BB%BD%E4%B8%8D%E5%AE%9C%E9%87%87%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%E9%99%A4%E9%9D%9E%E4%BD%A0%E5%A4%87%E4%BB%BD%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%86%E5%BA%93%E6%9A%82%E5%81%9C%E5%A6%82copy%E5%91%BD%E4%BB%A4-rsync%E5%91%BD%E4%BB%A4-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n**注意：**svn备份不宜采用普通的文件拷贝方式（除非你备份的时候将库暂停），如copy命令、rsync命令。&lt;br&gt;\n优缺点分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88\&#34;&gt;备份方案&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;对于一个专业的运维人员而言，可能收下有很多台设备需要管理，这里不免需要记录各种奇奇怪怪的密码，可能发生最北催的事情，莫过于忘记了自己维护设备的管理密码。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;忘记密码其实还是有解决方案的，只需要拿到一张系统的安装光盘。&lt;br&gt;\n将光盘放入光驱当中，重启电脑，从光驱启动电脑，在选择“安装语言”的位置，按Shite+F10&lt;br&gt;\n此时会弹出一个dos窗口，在这个dos窗口中执行如下命令&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;cd windows\\system32\nren Magnify.exe Magnify1.exe\nren cmd.exe Magnify.exe\nexit\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上命令主要是用于替换掉放大镜窗口&lt;br&gt;\n然后再次重启电脑，正常启动&lt;br&gt;\n在需要输入密码的界面中，点击放大镜，打开放大镜会出现一个dos窗口，这就是我们上面的操作的目的&lt;br&gt;\n然后执行如下命令&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net user administrator Imarkofu123456\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注：这里的Imarkofu123456即为重置的新密码，你可以根据自己的情况设置密码&lt;br&gt;\n还有一点需要注意的是设置密码时不要使用特殊字符，只要数字大小写字母就可以了&lt;br&gt;\n然后关闭窗口&lt;br&gt;\n输入刚刚重置的密码即可登录了&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;windows-forgets-the-administrator-password&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;对于一个专业的运维人员而言，可能收下有很多台设备需要管理，这里不免需要记录各种奇奇怪怪的密码，可能发生最北催的事情，莫过于忘记了自己维护设备的管理密码。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;windows server 2008 R2忘记administrator密码&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Windows忘记密码&#34;,&#34;slug&#34;:&#34;vxT4nu3dwdC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/vxT4nu3dwdC/&#34;},{&#34;name&#34;:&#34;忘记密码&#34;,&#34;slug&#34;:&#34;GQokOM9MKjN&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/GQokOM9MKjN/&#34;}],&#34;date&#34;:&#34;2016-11-30 21:56:45&#34;,&#34;dateFormat&#34;:&#34;2016-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/windows-forgets-the-administrator-password/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:71000,&#34;words&#34;:335,&#34;minutes&#34;:2},&#34;description&#34;:&#34;对于一个专业的运维人员而言，可能收下有很多台设备需要管理，这里不免需要记录各种奇奇怪怪的密码，可能发生最北催的事情，莫过于忘记了自己维护设备的管理密码。\n\n忘记密码其实还是有解决方案的，只需要拿到一张系统的安装光盘。\n将光盘放入光驱当中，重...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;**说明：**经常玩Linux系统的朋友多多少少也知道些系统参数优化和怎样增强系统安全性，系统默认的一些参数都是比较保守的，所以我们可以通过调整系统参数来提高系统内存、CPU、内核资源的占用，通过禁用不必要的服务、端口，来提高系统的安全性，更好的发挥系统的可用性。通过自己对Linux了解，对系统调优做了如下小结：&lt;br&gt;\n**操作系统：**CentOS 6.5_x64最小化安装&lt;/p&gt;\n&lt;h2 id=\&#34;-more-1-主机名设置\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n1、主机名设置&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# vi /etc/sysconfig/network\nHOSTNAME=test.com\n[root@localhost~]# hostname test.com  #临时生效\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-关闭selinux\&#34;&gt;2、关闭SELinux&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# vi /etc/selinux/config\nSELINUX=disabled\n[root@localhost~]# setenforce #临时生效\n[root@localhost~]# getenforce #查看selinux状态\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-清空防火墙并设置规则\&#34;&gt;3、清空防火墙并设置规则&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# iptables -F   #清楚防火墙规则\n[root@localhost~]# iptables -L   #查看防火墙规则\n[root@localhost~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT\n[root@localhost~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT\n[root@localhost~]# iptables -A INPUT -p tcp --dport 53 -j ACCEPT\n[root@localhost~]# iptables -A INPUT -p udp --dport 53 -j ACCEPT\n[root@localhost~]# iptables -A INPUT -p udp --dport 123 -j ACCEPT\n[root@localhost~]# iptables -A INPUT -p icmp -j ACCEPT\n[root@localhost~]# iptables -P INPUT DROP\n[root@localhost~]# /etc/init.d/iptables save\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;根据需求开启相应端口4-添加普通用户并进行sudo授权管理\&#34;&gt;根据需求开启相应端口&lt;br&gt;\n4、添加普通用户并进行sudo授权管理&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# useradd user\n[root@localhost~]# echo &amp;quot;123456&amp;quot; | passwd --stdin user  #设置密码\n[root@localhost~]# vi /etc/sudoers  #或visudo打开，添加user用户所有权限\nroot    ALL=(ALL)       ALL\nuser    ALL=(ALL)       ALL\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;5-禁用root远程登录\&#34;&gt;5、禁用root远程登录&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# vi /etc/ssh/sshd_config\nPermitRootLogin no\nPermitEmptyPasswords no #禁止空密码登录\nUseDNS no #关闭DNS查询\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;6-关闭不必要开机自启动服务\&#34;&gt;6、关闭不必要开机自启动服务&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# chkconfig auditd off\n[root@localhost~]# chkconfig blk-availablility off\n[root@localhost~]# chkconfig ip6tables off\n[root@localhost~]# chkconfig lvm2-monitor off\n[root@localhost~]# chkconfig netfs off\n[root@localhost~]# chkconfig udev-post off\n[root@localhost~]# chkconfig --list | grep 3:on\ncrond          0:off   1:off   2:on   3:on   4:on   5:on   6:off\nnetwork        0:off   1:off   2:on   3:on   4:on   5:on   6:off\npostfix        0:off   1:off   2:on   3:on   4:on   5:on   6:off\nrsyslog        0:off   1:off   2:on   3:on   4:on   5:on   6:off\nsshd           0:off   1:off   2:on   3:on   4:on   5:on   6:off\n[root@localhost~]# \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;7-删除不必要的系统用户\&#34;&gt;7、删除不必要的系统用户&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost~]# awk -F&amp;quot;:&amp;quot; &#39;{print $1}&#39; /etc/passwd\nroot\nbin\ndaemon\nadm\nlp\nsync\nshutdown\nhalt\nmail\nuucp\noperator\ngames\ngopher\nftp\nnobody\nvcsa\nsaslauth\npostfix\nsshd\nntp\n[root@localhost~]# userdel adm\n[root@localhost~]# userdel lp\n[root@localhost~]# userdel shutdown\n[root@localhost~]# userdel halt\n[root@localhost~]# userdel uucp\n[root@localhost~]# userdel operator\n[root@localhost~]# userdel games\n[root@localhost~]# userdel gopher\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;8-关闭重启ctl-alt-delete组合键\&#34;&gt;8、关闭重启ctl-alt-delete组合键&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost ~]# vi /etc/init/control-alt-delete.conf\n#exec /sbin/shutdown -r now &amp;quot;Control-Alt-Deletepressed&amp;quot;  #注释掉\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;9-调整文件描述符大小\&#34;&gt;9、调整文件描述符大小&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ulimit –n #默认是1024\n1024\n[root@localhost ~]# echo &amp;quot;ulimit -SHn 102400&amp;quot;&amp;gt;&amp;gt; /etc/rc.local   #设置开机自动生效\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;11-修改history记录\&#34;&gt;11、修改history记录&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost ~]# vi /etc/profile  #修改记录10个\nHISTSIZE=10\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;12-同步系统时间\&#34;&gt;12、同步系统时间&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime  #设置Shanghai时区\n[root@localhost ~]# ntpdate cn.pool.ntp.org ；hwclock–w  #同步时间并写入blos硬件时间\n[root@localhost ~]# crontab –e     #设置任务计划每天零点同步一次\n0 0 * * * /usr/sbin/ntpdate cn.pool.ntp.org ; hwclock -w\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;13-内核参数优化\&#34;&gt;13、内核参数优化&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;[root@localhost ~]# vi /etc/sysctl.conf    #末尾添加如下参数\nnet.ipv4.tcp_syncookies = 1            #1是开启SYN Cookies，当出现SYN等待队列溢出时，启用Cookies来处，理，可防范少量SYN攻击，默认是0关闭\nnet.ipv4.tcp_tw_reuse = 1              #1是开启重用，允许讲TIME_AIT sockets重新用于新的TCP连接，默认是0关闭\nnet.ipv4.tcp_tw_recycle = 1            #TCP失败重传次数，默认是15，减少次数可释放内核资源\nnet.ipv4.ip_local_port_range = 4096 65000  #应用程序可使用的端口范围\nnet.ipv4.tcp_max_tw_buckets = 5000     #系统同时保持TIME_WAIT套接字的最大数量，如果超出这个数字，TIME_WATI套接字将立刻被清除并打印警告信息，默认180000\nnet.ipv4.tcp_max_syn_backlog = 4096    #进入SYN宝的最大请求队列，默认是1024\nnet.core.netdev_max_backlog =  10240   #允许送到队列的数据包最大设备队列，默认300\nnet.core.somaxconn = 2048              #listen挂起请求的最大数量，默认128\nnet.core.wmem_default = 8388608        #发送缓存区大小的缺省值\nnet.core.rmem_default = 8388608        #接受套接字缓冲区大小的缺省值（以字节为单位）\nnet.core.rmem_max = 16777216           #最大接收缓冲区大小的最大值\nnet.core.wmem_max = 16777216           #发送缓冲区大小的最大值\nnet.ipv4.tcp_synack_retries = 2        #SYN-ACK握手状态重试次数，默认5\nnet.ipv4.tcp_syn_retries = 2           #向外SYN握手重试次数，默认4\nnet.ipv4.tcp_tw_recycle = 1            #开启TCP连接中TIME_WAIT sockets的快速回收，默认是0关闭\nnet.ipv4.tcp_max_orphans = 3276800     #系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上，如果超出这个数字，孤儿连接将立即复位并打印警告信息\nnet.ipv4.tcp_mem = 94500000 915000000 927000000\nnet.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力；\nnet.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段；\nnet.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。内存单位是页，可根据物理内存大小进行调整，如果内存足够大的话，可适当往上调。上述内存单位是页，而不是字节。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;至此CentOS 6.5_x64最小化安装系统基本优化调整完毕，需要重启下系统。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;centos-safety-reinforcement-and-performance-optimization&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;**说明：**经常玩Linux系统的朋友多多少少也知道些系统参数优化和怎样增强系统安全性，系统默认的一些参数都是比较保守的，所以我们可以通过调整系统参数来提高系统内存、CPU、内核资源的占用，通过禁用不必要的服务、端口，来提高系统的安全性，更好的发挥系统的可用性。通过自己对Linux了解，对系统调优做了如下小结：&lt;br&gt;\n**操作系统：**CentOS 6.5_x64最小化安装&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;CentOS 6.5安全加固及性能优化&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;ZeuyX_BRhQO&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ZeuyX_BRhQO/&#34;},{&#34;name&#34;:&#34;安全加固&#34;,&#34;slug&#34;:&#34;OU9qaw7qn0A&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/OU9qaw7qn0A/&#34;},{&#34;name&#34;:&#34;性能优化&#34;,&#34;slug&#34;:&#34;ld_7FCOmywQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/ld_7FCOmywQ/&#34;}],&#34;date&#34;:&#34;2016-11-30 21:36:22&#34;,&#34;dateFormat&#34;:&#34;2016-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/centos-safety-reinforcement-and-performance-optimization/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:362000,&#34;words&#34;:1317,&#34;minutes&#34;:7},&#34;description&#34;:&#34;**说明：**经常玩Linux系统的朋友多多少少也知道些系统参数优化和怎样增强系统安全性，系统默认的一些参数都是比较保守的，所以我们可以通过调整系统参数来提高系统内存、CPU、内核资源的占用，通过禁用不必要的服务、端口，来提高系统的安全性，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-1-%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%AE%BE%E7%BD%AE\&#34;&gt;&lt;!-- more --&gt;&lt;br&gt;\n1、主机名设置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%85%B3%E9%97%ADselinux\&#34;&gt;2、关闭SELinux&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E6%B8%85%E7%A9%BA%E9%98%B2%E7%81%AB%E5%A2%99%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%A7%84%E5%88%99\&#34;&gt;3、清空防火墙并设置规则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E5%BC%80%E5%90%AF%E7%9B%B8%E5%BA%94%E7%AB%AF%E5%8F%A34-%E6%B7%BB%E5%8A%A0%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%B9%B6%E8%BF%9B%E8%A1%8Csudo%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86\&#34;&gt;根据需求开启相应端口&lt;br&gt;\n4、添加普通用户并进行sudo授权管理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E7%A6%81%E7%94%A8root%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95\&#34;&gt;5、禁用root远程登录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E5%85%B3%E9%97%AD%E4%B8%8D%E5%BF%85%E8%A6%81%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1\&#34;&gt;6、关闭不必要开机自启动服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E5%88%A0%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7\&#34;&gt;7、删除不必要的系统用户&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-%E5%85%B3%E9%97%AD%E9%87%8D%E5%90%AFctl-alt-delete%E7%BB%84%E5%90%88%E9%94%AE\&#34;&gt;8、关闭重启ctl-alt-delete组合键&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-%E8%B0%83%E6%95%B4%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%A4%A7%E5%B0%8F\&#34;&gt;9、调整文件描述符大小&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-%E4%BF%AE%E6%94%B9history%E8%AE%B0%E5%BD%95\&#34;&gt;11、修改history记录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12-%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4\&#34;&gt;12、同步系统时间&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#13-%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96\&#34;&gt;13、内核参数优化&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在开始之前我们需要准备一些库文件。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# yum install zlib-devel openssl-devel gcc-c++ gcc bison cmake ncurses-devel -y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一定要安装这些包， LZ之前没有安装就开始编译MySQL，踩了好多坑， 后来上网一查才发现需要这些文件和管理工具才行。因此一定要安装。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;strong&gt;还有如果大家编译过程中出错, 请一定要执行:&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# rm -f CMakeCache.txt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;之后再继续安装。&lt;br&gt;\n安装好之后我们来添加MySQL数据库需要的账户和目录：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# groupadd -r mysql\n[root@imarkofu ~]# useradd -g mysql -r -s /sbin/nologin mysql\n[root@imarkofu ~]# id mysql #确认用户\n[root@imarkofu ~]# mkdir /var/data/mysql -p #存放数据库文件\n[root@imarkofu ~]# chown mysql:mysql /var/data -R\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下载MySQL源码包：&lt;a href=\&#34;http://pan.baidu.com/s/1c0fdgdE\&#34;&gt;mysql-5.5.40.tar.gz&lt;/a&gt;&lt;br&gt;\n下载后上传到服务器&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# tar -xvf mysql-5.5.40.tar.gz -C /usr/local/src/\n[root@imarkofu ~]# cd /usr/local/src/mysql-5.5.40\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;cmake编译MySQL的一些常用选项：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;------------------------------------------------------------\ncmake mysql 编译安装:\n./configure -&amp;gt; cmake .\n./configure --help -&amp;gt; cmake -LH -&amp;gt; ccmake .\n------------------------------------------------------------\n指定安装文件的安装路径常用选项\n-DCMAKE_INSTALL_PREFIX=/usr/local/mysql\n-DMYSQL_DATADIR=/data/mysql\n-DSYSCONFDIR=/etc\n------------------------------------------------------------\n默认编译的存储引擎包括: csv, myisma, myisammrg, heap. 若要安装其他存储引擎,可以使用类似如下的编译选项\n-DWITH_INNOBASE_STORAGE_ENGINE=1\n-DWITH_ARCHIVE_STORAGE_ENGINE=1\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1\n------------------------------------------------------------\n若要明确指出不编译某存储引擎, 可以使用类似如下的选项:\n-DWITHOUT_&amp;lt;ENGINE&amp;gt;_STORAGE_ENGINE=1\n例如:\n-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1\n-DWITHOUT_FEDERATED_STORAGE_ENGINE=1\n------------------------------------------------------------\n若要编译进其他功能, 如SSl等, 可使用类似如下选项来实现编译时使用某库文件或者, 或者不使用某库文件.\n-DWITH_READLINE=1\n-DWITH_SSL=system\n-DWITH_ZLIB=system\n-DWITH_LIBWRAP=0\n------------------------------------------------------------\n其他常用选项:\n-DMYSQL_TCP_PORT=3306\n-MYDQL_UNIX_ADDR=/tmp/mysql.sock\n-DENABLED_LOCAL_INFILE=1\n-DEXTRA_CHARSETS=all\n-DDEFAULT_CHARSET=utf8\n-DDEFAULT_COLLATION=utf8_general_ci\n-DWITH_DEBUG=0\n-DENABLE_PROFILING=1\n------------------------------------------------------------\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;开始编译&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql-5.5.40 \\\n-DMYSQL_DATADIR=/var/data/mysql \\ #数据库目录\n-DSYSCONFDIR=/etc \\ #配置文件目录\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\ #启用InnoDB存储引擎\n-DWITH_ARCHIVE_STORAGE_ENGINE=1 \\ #启用ARCHIVE存储引擎\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ #启用黑洞存储引擎\n-DWITH_READLINE=1 \\\n-DWITH_SSL=system \\ #启用SSL协议\n-DWITH_ZLIB=system \\ #启用Zlib压缩\n-DWITH_LIBWRAP=0 \\\n-DDEFAULT_CHARSET=utf8 \\ #设置字符集utf8\n-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\\n-DDEFAULT_COLLATION=utf8_general_ci\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果出现以下信息，那么恭喜你第一阶段的配置顺利完成了&lt;br&gt;\n过程中如果出现错误也不要害怕， 因为你长经验的时刻就要来了， 通常是因为缺少了什么依赖的包而出现的问题， 你可以把你的错误信息铁道Google或者百度中去搜索。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;....(此处省略一万字)\n-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS\n-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS - Success\n-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC\n-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC - Success\n-- Check size of pthread_t\n-- Check size of pthread_t - done\n-- Performing Test HAVE_PEERCRED\n-- Performing Test HAVE_PEERCRED - Success\n-- Library mysqlclient depends on OSLIBS -lpthread;z;m;rt;/usr/lib64/libssl.so;/usr/lib64/libcrypto.so;dl\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /usr/local/mysql-5.5.40\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;继续&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# make\n....(此处省略一万字)\nScanning dependencies of target udf_example\n[100%] Building C object sql/CMakeFiles/udf_example.dir/udf_example.c.o\nLinking C shared module udf_example.so\n[100%] Built target udf_example\nScanning dependencies of target my_safe_process\n[100%] Building CXX object mysql-test/lib/My/SafeProcess/CMakeFiles/my_safe_process.dir/safe_process.cc.o\nLinking CXX executable my_safe_process\n[100%] Built target my_safe_process\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果没有报错，继续&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# make install\n....(此处省略一万字)\n-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_upgrade.1\n-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlslap.1\n-- Installing: /usr/local/mysql-5.5.40/man/man1/replace.1\n-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql.1\n-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_setpermission.1\n-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_secure_installation.1\n-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlimport.1\n-- Installing: /usr/local/mysql-5.5.40/man/man8/mysqld.8\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;全部安装ok之后我们来配置下文档的权限&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# chown :mysql /usr/local/mysql-5.5.40 -R\n[root@imarkofu mysql-5.5.40]# cd /usr/local/mysql-5.5.40/\n[root@imarkofu mysql-5.5.40]# chmod +x scripts/mysql_install_db\n[root@imarkofu mysql-5.5.40]# scripts/mysql_install_db --user=mysql --datadir=/var/data/mysql/ #执行初始化脚本\n....(此处省略一万字)\n./bin/mysqladmin -u root password &#39;new-password&#39;\n./bin/mysqladmin -u root -h imarkofu password &#39;new-password&#39;\n \nAlternatively you can run:\n./bin/mysql_secure_installation\n \nwhich will also give you the option of removing the test\ndatabases and anonymous user created by default.  This is\nstrongly recommended for production servers.\n \nSee the manual for more instructions.\n \nYou can start the MySQL daemon with:\ncd . ; ./bin/mysqld_safe &amp;amp;\n \nYou can test the MySQL daemon with mysql-test-run.pl\ncd ./mysql-test ; perl mysql-test-run.pl\n \nPlease report any problems at http://bugs.mysql.com/\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果你获得的信息和上面一样的话, 恭喜你, 你又离成功近了一步&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# ls /var/data/mysql/ #看一下是否生成了文件\nmysql  performance_schema  test\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果是这样那么继续&lt;br&gt;\n创建服务脚本&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld \n[root@imarkofu mysql-5.5.40]# chmod +x /etc/rc.d/init.d/mysqld #添加mysqld执行权限\n[root@imarkofu mysql-5.5.40]# chkconfig --add mysqld #添加开机启动\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;创建配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# mv /etc/my.cnf{,.bak}\n[root@imarkofu mysql-5.5.40]# cp support-files/my-large.cnf /etc/my.cnf\n[root@imarkofu mysql-5.5.40]# vim /etc/my.cnf\n\n#找到如下部分\n[mysqld]\nport            = 3306\nsocket          = /tmp/mysql.sock\nskip-external-locking\nkey_buffer_size = 256M\nmax_allowed_packet = 1M\ntable_open_cache = 256\nsort_buffer_size = 1M\nread_buffer_size = 1M\nread_rnd_buffer_size = 4M\nmyisam_sort_buffer_size = 64M\nthread_cache_size = 8\nquery_cache_size= 16M\n# Try number of CPU&#39;s*2 for thread_concurrency\nthread_concurrency = 8\ndatadir= /var/data/mysql #添加次行内容, 就是数据库文件存放路径\n:wq\n#保存退出\n\n[root@imarkofu mysql-5.5.40]# vim /etc/profile.d/mysql.sh\nexport PATH=/usr/local/mysql-5.5.40/bin:$PATH #添加此行\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;好了，尝试着启动MySQL服务&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# service mysqld start\nStarting MySQL..                                           [  OK  ]\n[root@imarkofu mysql-5.5.40]#\n[root@imarkofu mysql-5.5.40]# ss -tnl| grep :3306 \nLISTEN     0      50                        *:3306                     *:*    \n#发现正常监听 3306端口\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;距离胜利越来越近了&lt;br&gt;\n然后配置MySQL管理员密码进行初始化&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# mysql #使用客户端登录\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 1\nServer version: 5.5.40-log Source distribution\nCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\nmysql&amp;gt; \n#查看一下默认存在的用户\nmysql&amp;gt; select user,password,host from mysql.user; \n+------+----------+-----------+\n| user | password | host      |\n+------+----------+-----------+\n| root |          | localhost |\n| root |          | imarkofu  |\n| root |          | 127.0.0.1 |\n| root |          | ::1       |\n|      |          | localhost |\n|      |          | imarkofu  |\n+------+----------+-----------+\n6 rows in set (0.00 sec)\nmysql&amp;gt; \n\n#删除默认存在的账户, 要求用户只能从本地服务器访问数据库\nmysql&amp;gt; delete from mysql.user where host!=&#39;localhost&#39;; \nQuery OK, 4 rows affected (0.00 sec)\n\n#修改root管理员账号密码\nmysql&amp;gt; update mysql.user set password=PASSWORD(&#39;p@ssw0rd&#39;) where user=&#39;root&#39;; \nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n \n#更新数据库\nmysql&amp;gt; FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.00 sec)\n \n#看一下修改后的结果\nmysql&amp;gt; select user,password,host from mysql.user;\n+------+-------------------------------------------+-----------+\n| user | password                                  | host      |\n+------+-------------------------------------------+-----------+\n| root | *D7E39C3AF517EC9EF7086223B036E0B4F22821F8 | localhost |\n|      |                                           | localhost |\n+------+-------------------------------------------+-----------+\n2 rows in set (0.00 sec)\nmysql&amp;gt; \\q\nBye\n[root@imarkofu mysql-5.5.40]#\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后就可以使用新密码登陆了&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# mysql -u root -h localhost -p\nEnter password: #输入刚才设置的密码\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 4\nServer version: 5.5.40-log Source distribution\nCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\nmysql&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;好了MySQL到此 就安装成功了&lt;br&gt;\n对了，忘记了导入开发的库文件了， ok 很快就好&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu mysql-5.5.40]# ln -sv /usr/local/mysql/include/ /usr/include/mysql #软连接到系统库中\n[root@imarkofu mysql-5.5.40]# vim /etc/ld.so.conf.d/mysql.conf #编辑这个文件, 并且添加如下路径\n/usr/local/mysql-5.5.40/lib\n[root@imarkofu mysql-5.5.40]# ldconfig #重新加载库文件\n[root@imarkofu mysql-5.5.40]# ldconfig -p | grep mysql #让我们来检查下是不是加载好了\n    libmysqlclient_r.so.16 (libc6,x86-64) =&amp;gt; /usr/lib64/mysql/libmysqlclient_r.so.16\n    libmysqlclient.so.18 (libc6,x86-64) =&amp;gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so.18\n    libmysqlclient.so.16 (libc6,x86-64) =&amp;gt; /usr/lib64/mysql/libmysqlclient.so.16\n    libmysqlclient.so (libc6,x86-64) =&amp;gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;至此，MySQL5.5.40 编译安装完成&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;centos-compile-and-install-MySQL&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;在开始之前我们需要准备一些库文件。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@imarkofu ~]# yum install zlib-devel openssl-devel gcc-c++ gcc bison cmake ncurses-devel -y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一定要安装这些包， LZ之前没有安装就开始编译MySQL，踩了好多坑， 后来上网一查才发现需要这些文件和管理工具才行。因此一定要安装。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;centos 6.5 编译安装 mysql 5.5.40&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;数据库&#34;,&#34;slug&#34;:&#34;QQpdoTi9OSb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/QQpdoTi9OSb/&#34;},{&#34;name&#34;:&#34;编译安装&#34;,&#34;slug&#34;:&#34;RBiFvVZmwpt&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/RBiFvVZmwpt/&#34;}],&#34;date&#34;:&#34;2016-11-30 21:14:20&#34;,&#34;dateFormat&#34;:&#34;2016-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/centos-compile-and-install-MySQL/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:596000,&#34;words&#34;:1960,&#34;minutes&#34;:10},&#34;description&#34;:&#34;在开始之前我们需要准备一些库文件。\n[root@imarkofu ~]# yum install zlib-devel openssl-devel gcc-c++ gcc bison cmake ncurses-devel -y\n\n一定要安...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;现在的CMS系统、博客系统、BBS等都喜欢使用标签tag作交叉链接，因此我也尝鲜用了下。但用了后发现我想查询某个tag的文章列表时速度很慢，达到5秒之久！百思不解(后来终于解决)，我的表结构是下面这样的，文章只有690篇。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;文章表article(id,title,content)&lt;br&gt;\n标签表tag(tid,tag_name)&lt;br&gt;\n标签文章中间表article_tag(id,tag_id,article_id)&lt;br&gt;\n其中有个标签的tid是135，我帮查询标签tid是135的文章列表&lt;br&gt;\n用以下语句时发现速度好慢,我文章才690篇&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;select id,title from article where id in(select article_id from article_tag where tag_id=135)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;其中这条速度很快：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;select article_id from article_tag where tag_id=135&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;查询结果是五篇文章，id为428,429,430,431,432&lt;br&gt;\n我用写死的方式用下面sql来查文章也很快&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;select id,title from article where id in(428,429,430,431,432)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;我在SqlServer中好像不会这样慢，不知MySQL怎样写好点，也想不出慢在哪里。&lt;br&gt;\n后来我找到了解决方法：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;select id,title from article where id in(select article_id from (select article_id from article_tag where tag_id=135) as tbt)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;其它解决方法：（举例）&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = &#39;82306839&#39;);&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;为了节省篇幅，省略了输出内容，下同。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;67 rows in set (12.00 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;只有67行数据返回，却花了12秒，而系统中可能同时会有很多这样的查询，系统肯定扛不住。用desc看一下(注：explain也可)&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mysql&amp;gt;desc select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = &#39;82306839&#39;);&lt;br&gt;\n+----+--------------------+------------------+--------+-----------------+-------+---------+------------+---------+--------------------------+&lt;br&gt;\n| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |&lt;br&gt;\n+----+--------------------+------------------+--------+-----------------+-------+---------+------------+---------+--------------------------+&lt;br&gt;\n| 1 | PRIMARY | abc_number_prop | ALL | NULL | NULL | NULL | NULL | 2679838 | Using where |&lt;br&gt;\n| 2 | DEPENDENT SUBQUERY | abc_number_phone | eq_ref | phone,number_id | phone | 70 | const,func | 1 | Using where; Using index |&lt;br&gt;\n+----+--------------------+------------------+--------+-----------------+-------+---------+------------+---------+--------------------------+&lt;br&gt;\n2 rows in set (0.00 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;从上面的信息可以看出，在执行此查询时会扫描两百多万行，难道是没有创建索引吗，看一下&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mysql&amp;gt;show index from abc_number_phone;&lt;br&gt;\n+------------------+------------+-------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;\n| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |&lt;br&gt;\n+------------------+------------+-------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;\n| abc_number_phone | 0 | PRIMARY | 1 | number_phone_id | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_phone | 0 | phone | 1 | phone | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_phone | 0 | phone | 2 | number_id | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_phone | 1 | number_id | 1 | number_id | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_phone | 1 | created_by | 1 | created_by | A | 36879 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_phone | 1 | modified_by | 1 | modified_by | A | 36879 | NULL | NULL | YES | BTREE | | |&lt;br&gt;\n+------------------+------------+-------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;\n6 rows in set (0.06 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mysql&amp;gt;show index from abc_number_prop;&lt;br&gt;\n+-----------------+------------+-------------+--------------+----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;\n| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |&lt;br&gt;\n+-----------------+------------+-------------+--------------+----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;\n| abc_number_prop | 0 | PRIMARY | 1 | number_prop_id | A | 311268 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_prop | 1 | number_id | 1 | number_id | A | 311268 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_prop | 1 | created_by | 1 | created_by | A | 311268 | NULL | NULL | | BTREE | | |&lt;br&gt;\n| abc_number_prop | 1 | modified_by | 1 | modified_by | A | 311268 | NULL | NULL | YES | BTREE | | |&lt;br&gt;\n+-----------------+------------+-------------+--------------+----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;br&gt;\n4 rows in set (0.15 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;从上面的输出可以看出，这两张表在number_id字段上创建了索引的。&lt;br&gt;\n看看子查询本身有没有问题。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mysql&amp;gt;desc select number_id from abc_number_phone where phone = &#39;82306839&#39;;&lt;br&gt;\n+----+-------------+------------------+------+---------------+-------+---------+-------+------+--------------------------+&lt;br&gt;\n| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |&lt;br&gt;\n+----+-------------+------------------+------+---------------+-------+---------+-------+------+--------------------------+&lt;br&gt;\n| 1 | SIMPLE | abc_number_phone | ref | phone | phone | 66 | const | 6 | Using where; Using index |&lt;br&gt;\n+----+-------------+------------------+------+---------------+-------+---------+-------+------+--------------------------+&lt;br&gt;\n1 row in set (0.00 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;没有问题，只需要扫描几行数据，索引起作用了。查询出来看看&lt;br&gt;\nmysql&amp;gt;select number_id from abc_number_phone where phone = &#39;82306839&#39;;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;+-----------+&lt;br&gt;\n| number_id |&lt;br&gt;\n+-----------+&lt;br&gt;\n| 8585 |&lt;br&gt;\n| 10720 |&lt;br&gt;\n| 148644 |&lt;br&gt;\n| 151307 |&lt;br&gt;\n| 170691 |&lt;br&gt;\n| 221897 |&lt;br&gt;\n+-----------+&lt;br&gt;\n6 rows in set (0.00 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;直接把子查询得到的数据放到上面的查询中&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mysql&amp;gt; select * from abc_number_prop where number_id in (8585, 10720, 148644, 151307, 170691, 221897);&lt;br&gt;\n67 rows in set (0.03 sec)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;速度也快，看来MySQL在处理子查询的时候是不够好。我在MySQL 5.1.42 和 MySQL 5.5.19 都进行了尝试，都有这个问题。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;optimize-mysql-in-subqueries&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;现在的CMS系统、博客系统、BBS等都喜欢使用标签tag作交叉链接，因此我也尝鲜用了下。但用了后发现我想查询某个tag的文章列表时速度很慢，达到5秒之久！百思不解(后来终于解决)，我的表结构是下面这样的，文章只有690篇。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mysql in 子查询 效率慢 优化&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;IrVH3x6Yv1n&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/IrVH3x6Yv1n/&#34;},{&#34;name&#34;:&#34;数据库&#34;,&#34;slug&#34;:&#34;QQpdoTi9OSb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/QQpdoTi9OSb/&#34;},{&#34;name&#34;:&#34;in&#34;,&#34;slug&#34;:&#34;Dxa9gMzRAnf&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Dxa9gMzRAnf/&#34;},{&#34;name&#34;:&#34;子查询&#34;,&#34;slug&#34;:&#34;DKaj0b8CDEH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/DKaj0b8CDEH/&#34;}],&#34;date&#34;:&#34;2016-11-30 20:48:02&#34;,&#34;dateFormat&#34;:&#34;2016-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/optimize-mysql-in-subqueries/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:239000,&#34;words&#34;:835,&#34;minutes&#34;:4},&#34;description&#34;:&#34;现在的CMS系统、博客系统、BBS等都喜欢使用标签tag作交叉链接，因此我也尝鲜用了下。但用了后发现我想查询某个tag的文章列表时速度很慢，达到5秒之久！百思不解(后来终于解决)，我的表结构是下面这样的，文章只有690篇。\n\n文章表arti...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;JS获取当前对象大小属性以及屏幕分辨率属性等&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;\nfunction getInfo(){ \n    var s = &amp;quot;&amp;quot;;   \n    s += &amp;quot; 网页可见区域宽：&amp;quot;+ document.body.clientWidth+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页可见区域高：&amp;quot;+ document.body.clientHeight+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页可见区域宽：&amp;quot;+ document.body.offsetWidth + &amp;quot; (包括边线和滚动条的宽)&amp;quot;+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页可见区域高：&amp;quot;+ document.body.offsetHeight + &amp;quot; (包括边线的宽)&amp;quot;+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页正文全文宽：&amp;quot;+ document.body.scrollWidth+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页正文全文高：&amp;quot;+ document.body.scrollHeight+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页被卷去的高(ff)：&amp;quot;+ document.body.scrollTop+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页被卷去的高(ie)：&amp;quot;+ document.documentElement.scrollTop+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页被卷去的左：&amp;quot;+ document.body.scrollLeft+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页正文部分上：&amp;quot;+ window.screenTop+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 网页正文部分左：&amp;quot;+ window.screenLeft+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 屏幕分辨率的高：&amp;quot;+ window.screen.height+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 屏幕分辨率的宽：&amp;quot;+ window.screen.width+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 屏幕可用工作区高度：&amp;quot;+ window.screen.availHeight+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 屏幕可用工作区宽度：&amp;quot;+ window.screen.availWidth+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 你的屏幕设置是 &amp;quot;+ window.screen.colorDepth +&amp;quot; 位彩色&amp;quot;+&amp;quot;\\n&amp;quot;;    \n    s += &amp;quot; 你的屏幕设置 &amp;quot;+ window.screen.deviceXDPI +&amp;quot; 像素/英寸&amp;quot;+&amp;quot;\\n&amp;quot;;    \n    alert (s);\n}\ngetInfo();\n&amp;lt;/script&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;gets-the-screen-properties-by-JS&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;JS获取当前对象大小属性以及屏幕分辨率属性等&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;JS获取当前对象大小属性以及屏幕分辨率属性等&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;UUye3d0PyM8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/UUye3d0PyM8/&#34;},{&#34;name&#34;:&#34;前端&#34;,&#34;slug&#34;:&#34;z3EcXXuuO8u&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/z3EcXXuuO8u/&#34;}],&#34;date&#34;:&#34;2016-11-30 20:39:48&#34;,&#34;dateFormat&#34;:&#34;2016-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/gets-the-screen-properties-by-JS/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:101000,&#34;words&#34;:347,&#34;minutes&#34;:2},&#34;description&#34;:&#34;JS获取当前对象大小属性以及屏幕分辨率属性等\n\n&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;\nfunction getInfo(){ \n    var s = &amp;quot;&amp;quot;;  ...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;redis 2.4的conf文件的中文翻译，大致参考。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code&gt;# Redis示例配置文件\n\n# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：\n#\n# 1k =&amp;gt; 1000 bytes\n# 1kb =&amp;gt; 1024 bytes\n# 1m =&amp;gt; 1000000 bytes\n# 1mb =&amp;gt; 1024*1024 bytes\n# 1g =&amp;gt; 1000000000 bytes\n# 1gb =&amp;gt; 1024*1024*1024 bytes\n#\n# 单位是大小写不敏感的，所以1GB 1Gb 1gB的写法都是完全一样的。\n\n# Redis默认是不作为守护进程来运行的。你可以把这个设置为&amp;quot;yes&amp;quot;让它作为守护进程来运行。\n# 注意，当作为守护进程的时候，Redis会把进程ID写到 /var/run/redis.pid\ndaemonize no\n\n# 当以守护进程方式运行的时候，Redis会把进程ID默认写到 /var/run/redis.pid。你可以在这里修改路径。\npidfile /var/run/redis.pid\n\n# 接受连接的特定端口，默认是6379。\n# 如果端口设置为0，Redis就不会监听TCP套接字。\nport 6379\n\n# 如果你想的话，你可以绑定单一接口；如果这里没单独设置，那么所有接口的连接都会被监听。\n#\n# bind 127.0.0.1\n\n# 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果你不指定的话，Redis就不会通过unix套接字来监听。\n#\n# unixsocket /tmp/redis.sock\n# unixsocketperm 755\n\n#一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)\ntimeout 0\n\n# 设置服务器调试等级。\n# 可能值：\n# debug （很多信息，对开发/测试有用）\n# verbose （很多精简的有用信息，但是不像debug等级那么多）\n# notice （适量的信息，基本上是你生产环境中需要的程度）\n# warning （只有很重要/严重的信息会记录下来）\nloglevel verbose\n\n# 指明日志文件名。也可以使用&amp;quot;stdout&amp;quot;来强制让Redis把日志信息写到标准输出上。\n# 注意：如果Redis以守护进程方式运行，而你设置日志显示到标准输出的话，那么日志会发送到 /dev/null\nlogfile stdout\n\n# 要使用系统日志记录器很简单，只要设置 &amp;quot;syslog-enabled&amp;quot; 为 &amp;quot;yes&amp;quot; 就可以了。\n# 然后根据需要设置其他一些syslog参数就可以了。\n# syslog-enabled no\n\n# 指明syslog身份\n# syslog-ident redis\n\n# 指明syslog的设备。必须是一个用户或者是 LOCAL0 ~ LOCAL7 之一。\n# syslog-facility local0\n\n# 设置数据库个数。默认数据库是 DB 0，你可以通过SELECT &amp;lt;dbid&amp;gt; WHERE dbid（0～&#39;databases&#39; - 1）来为每个连接使用不同的数据库。\ndatabases 16\n\n################################ 快照 #################################\n\n#\n# 把数据库存到磁盘上:\n#\n#   save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;\n#   \n#   会在指定秒数和数据变化次数之后把数据库写到磁盘上。\n#\n#   下面的例子将会进行把数据写入磁盘的操作:\n#   900秒（15分钟）之后，且至少1次变更\n#   300秒（5分钟）之后，且至少10次变更\n#   60秒之后，且至少10000次变更\n#\n#   注意：你要想不写磁盘的话就把所有 &amp;quot;save&amp;quot; 设置注释掉就行了。\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象。\n# 默认设置为 &amp;quot;yes&amp;quot;，所以几乎总是生效的。\n# 如果你想节省CPU的话你可以把这个设置为 &amp;quot;no&amp;quot;，但是如果你有可压缩的key的话，那数据文件就会更大了。\nrdbcompression yes\n\n# 数据库的文件名\ndbfilename dump.rdb\n\n# 工作目录\n#\n# 数据库会写到这个目录下，文件名就是上面的 &amp;quot;dbfilename&amp;quot; 的值。\n# \n# 累加文件也放这里。\n# \n# 注意你这里指定的必须是目录，不是文件名。\ndir ./\n\n################################# 同步 #################################\n\n#\n# 主从同步。通过 slaveof 配置来实现Redis实例的备份。\n# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。\n#\n# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;\n\n# 如果master设置了密码（通过下面的 &amp;quot;requirepass&amp;quot; 选项来配置），那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。\n#\n# masterauth &amp;lt;master-password&amp;gt;\n\n# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：\n#\n# 1) 如果 slave-serve-stale-data 设置为 &amp;quot;yes&amp;quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。\n# 2) 如果 slave-serve-stale-data 设置为 &amp;quot;no&amp;quot;，slave会回复&amp;quot;正在从master同步（SYNC with master in progress）&amp;quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。\n#\nslave-serve-stale-data yes\n\n# slave根据指定的时间间隔向服务器发送ping请求。\n# 时间间隔可以通过 repl_ping_slave_period 来设置。\n# 默认10秒。\n#\n# repl-ping-slave-period 10\n\n# 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。\n# 默认值60秒。\n#\n# 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。\n#\n# repl-timeout 60\n\n################################## 安全 ###################################\n\n# 要求客户端在处理任何命令时都要验证身份和密码。\n# 这在你信不过来访者时很有用。\n#\n# 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证（例如：它们运行在自己的服务器上。）\n# \n# 警告：因为Redis太快了，所以居心不良的人可以每秒尝试150k的密码来试图破解密码。\n# 这意味着你需要一个高强度的密码，否则破解太容易了。\n#\n# requirepass foobared\n\n# 命令重命名\n#\n# 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法做坏事了。\n#\n# 例如:\n#\n# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n#\n# 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令：\n#\n# rename-command CONFIG &amp;quot;&amp;quot;\n\n################################### 限制 ####################################\n\n#\n# 设置最多同时连接客户端数量。\n# 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。\n# 特殊值&amp;quot;0&amp;quot;表示没有限制。\n# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&amp;quot;达到最大用户数上限（max number of clients reached）&amp;quot;\n#\n# maxclients 128\n\n# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。\n#\n# 如果因为删除策略问题Redis无法删除key，或者策略设置为 &amp;quot;noeviction&amp;quot;，Redis会回复需要更多内存的错误信息给命令。\n# 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。\n#\n# 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &amp;quot;noeviction&amp;quot; 策略）的时候，这个选项还是满有用的。\n#\n# 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。\n# 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。\n#\n# 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。\n# （如果策略设置为&amp;quot;noeviction&amp;quot;的话就不无所谓了）\n#\n# maxmemory &amp;lt;bytes&amp;gt;\n\n# 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选：\n# \n# volatile-lru -&amp;gt; 根据LRU算法生成的过期时间来删除。\n# allkeys-lru -&amp;gt; 根据LRU算法删除任何key。\n# volatile-random -&amp;gt; 根据过期设置来随机删除key。\n# allkeys-&amp;gt;random -&amp;gt; 无差别随机删。\n# volatile-ttl -&amp;gt; 根据最近过期时间来删除（辅以TTL）\n# noeviction -&amp;gt; 谁也不删，直接在写操作时返回错误。\n# \n# 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。\n#\n#       这里涉及的命令：set setnx setex append\n#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd\n#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby\n#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby\n#       getset mset msetnx exec sort\n#\n# 默认值如下：\n#\n# maxmemory-policy volatile-lru\n\n# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样例做测试。\n# 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。\n#\n# maxmemory-samples 3\n\n############################## 纯累加模式 ###############################\n\n# 默认情况下，Redis是异步的把数据导出到磁盘上。这种情况下，当Redis挂掉的时候，最新的数据就丢了。\n# 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。\n# 每次启动时Redis都会把这个文件的数据读入内存里。\n#\n# 注意，异步导出的数据库文件和纯累加文件可以并存（你得把上面所有&amp;quot;save&amp;quot;设置都注释掉，关掉导出机制）。\n# 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。\n#\n# 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。\n\nappendonly no\n\n# 纯累加文件名字（默认：&amp;quot;appendonly.aof&amp;quot;）\n# appendfilename appendonly.aof\n\n# fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。\n# 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。\n#\n# Redis支持三种不同的模式：\n#\n# no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。\n# always：每次写操作都立刻写入到aof文件。慢，但是最安全。\n# everysec：每秒写一次。折衷方案。\n#\n# 默认的 &amp;quot;everysec&amp;quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。\n# 如果你真的理解了这个意味着什么，那么设置&amp;quot;no&amp;quot;可以获得更好的性能表现（如果丢数据的话，则只能拿到一个不是很新的快照）；\n# 或者相反的，你选择 &amp;quot;always&amp;quot; 来牺牲速度确保数据安全、完整。\n#\n# 如果拿不准，就用 &amp;quot;everysec&amp;quot;\n\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n# 如果AOF的同步策略设置成 &amp;quot;always&amp;quot; 或者 &amp;quot;everysec&amp;quot;，那么后台的存储进程（后台存储或写入AOF日志）会产生很多磁盘I/O开销。\n# 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。\n# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。\n#\n# 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。\n# \n# 这就意味着如果有子进程在进行保存操作，那么Redis就处于&amp;quot;不可同步&amp;quot;的状态。\n# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）\n# \n# 如果你有延迟的问题那就把这个设为 &amp;quot;yes&amp;quot;，否则就保持 &amp;quot;no&amp;quot;，这是保存持久数据的最安全的方式。\nno-appendfsync-on-rewrite no\n\n# 自动重写AOF文件\n#\n# 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。\n# \n# 工作原理：Redis记住上次重写时AOF日志的大小（或者重启后没有写操作的话，那就直接用此时的AOF文件），\n#           基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。\n#\n# 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。\n#\n# 指定百分比为0会禁用AOF自动重写特性。\n\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n################################## 慢查询日志 ###################################\n\n# Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。\n# 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间（这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景）\n# \n# 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。\n# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。\n#\n# 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。\nslowlog-log-slower-than 10000\n\n# 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。（译者注：日志居然是在内存里的Orz）\nslowlog-max-len 128\n\n################################ 虚拟内存 ###############################\n\n### 警告！虚拟内存在Redis 2.4是反对的。\n### 非常不鼓励使用虚拟内存！！\n\n# 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。\n# 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。\n#\n# 要使用虚拟内存，只要把 &amp;quot;vm-enabled&amp;quot; 设置为 &amp;quot;yes&amp;quot;，并根据需要设置下面三个虚拟内存参数就可以了。\n\nvm-enabled no\n# vm-enabled yes\n\n# 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。\n#\n# 最好的保存交换文件（被随机访问）的介质是固态硬盘（SSD）。\n#\n# *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。\n# 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。\nvm-swap-file /tmp/redis.swap\n\n# &amp;quot;vm-max-memory&amp;quot; 配置虚拟内存可用的最大内存容量。\n# 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。\n#\n# &amp;quot;vm-max-memory&amp;quot; 设置为0表示系统会用掉所有可用内存。\n# 这默认值不咋地，只是把你能用的内存全用掉了，留点余量会更好。\n# 例如，设置为剩余内存的60%-80%。\nvm-max-memory 0\n\n# Redis交换文件是分成多个数据页的。\n# 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。\n# 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。\n# 如果数据页太小，那用于存储的交换空间就会更少（假定你设置相同的数据页数量）\n#\n# 如果你使用很多小对象，建议分页尺寸为64或32个字节。\n# 如果你使用很多大对象，那就用大一些的尺寸。\n# 如果不确定，那就用默认值 :)\nvm-page-size 32\n\n# 交换文件里数据页总数。\n# 根据内存中分页表（已用/未用的数据页分布情况），磁盘上每8个数据页会消耗内存里1个字节。\n#\n# 交换区容量 = vm-page-size * vm-pages\n#\n# 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。\n#\n# 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。\nvm-pages 134217728\n\n# 同时可运行的虚拟内存I/O线程数。\n# 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。\n# 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。\n#\n# 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。\nvm-max-threads 4\n\n############################### 高级配置 ###############################\n\n# 当有大量数据时，适合用哈希编码（需要更多的内存），元素数量上限不能超过给定限制。\n# 你可以通过下面的选项来设定这些限制：\nhash-max-zipmap-entries 512\nhash-max-zipmap-value 64\n\n# 与哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。\n# 这种方式只有在符合下面限制的时候才可以用：\nlist-max-ziplist-entries 512\nlist-max-ziplist-value 64\n\n# 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。\n# 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。\nset-max-intset-entries 512\n\n# 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。\n# 这种编码只适合长度和元素都符合下面限制的有序序列：\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\n\n# 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。\n# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；\n# 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。\n# \n# 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。\n#\n# 建议：\n# 如果你对延迟比较在意的话就用 &amp;quot;activerehashing no&amp;quot;，每个请求延迟2毫秒不太好嘛。\n# 如果你不太在意延迟而希望尽快释放内存的话就设置 &amp;quot;activerehashing yes&amp;quot;。\nactiverehashing yes\n\n################################## 包含 ###################################\n\n# 包含一个或多个其他配置文件。\n# 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。\n# 包含文件特性允许你引人其他配置文件，所以好好利用吧。\n#\n# include /path/to/local.conf\n# include /path/to/other.conf\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;translation-redid-conf&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;redis 2.4的conf文件的中文翻译，大致参考。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Redis的redis.conf中文版（基于2.4）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;redis&#34;,&#34;slug&#34;:&#34;Lr24llxuRn6&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Lr24llxuRn6/&#34;},{&#34;name&#34;:&#34;nosql&#34;,&#34;slug&#34;:&#34;NGdMMFzzkUc&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/NGdMMFzzkUc/&#34;}],&#34;date&#34;:&#34;2016-11-29 23:33:58&#34;,&#34;dateFormat&#34;:&#34;2016-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/translation-redid-conf/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;18 min read&#34;,&#34;time&#34;:1067000,&#34;words&#34;:4788,&#34;minutes&#34;:18},&#34;description&#34;:&#34;redis 2.4的conf文件的中文翻译，大致参考。\n\n# Redis示例配置文件\n\n# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：\n#\n# 1k =&amp;gt; 1000 bytes\n# 1kb ...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；&lt;br&gt;\nLinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；&lt;br&gt;\nTreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;strong&gt;用例代码：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.HashSet;  \nimport java.util.LinkedHashSet;  \nimport java.util.TreeSet;  \n  \n/**  \n * @description 几个set的比较  \n *    HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；  \n *    LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；  \n *    TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。  \n * @author gbwl_cgl  \n *  \n */  \npublic class SetDemo {  \n  \n    public static void main(String[] args) {  \n  \n        HashSet&amp;lt;String&amp;gt; hs = new HashSet&amp;lt;String&amp;gt;();  \n        hs.add(&amp;quot;B&amp;quot;);  \n        hs.add(&amp;quot;A&amp;quot;);  \n        hs.add(&amp;quot;D&amp;quot;);  \n        hs.add(&amp;quot;E&amp;quot;);  \n        hs.add(&amp;quot;C&amp;quot;);  \n        hs.add(&amp;quot;F&amp;quot;);  \n        System.out.println(&amp;quot;HashSet 顺序:\\n&amp;quot;+hs);  \n          \n        LinkedHashSet&amp;lt;String&amp;gt; lhs = new LinkedHashSet&amp;lt;String&amp;gt;();  \n        lhs.add(&amp;quot;B&amp;quot;);  \n        lhs.add(&amp;quot;A&amp;quot;);  \n        lhs.add(&amp;quot;D&amp;quot;);  \n        lhs.add(&amp;quot;E&amp;quot;);  \n        lhs.add(&amp;quot;C&amp;quot;);  \n        lhs.add(&amp;quot;F&amp;quot;);  \n        System.out.println(&amp;quot;LinkedHashSet 顺序:\\n&amp;quot;+lhs);  \n          \n        TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;String&amp;gt;();  \n        ts.add(&amp;quot;B&amp;quot;);  \n        ts.add(&amp;quot;A&amp;quot;);  \n        ts.add(&amp;quot;D&amp;quot;);  \n        ts.add(&amp;quot;E&amp;quot;);  \n        ts.add(&amp;quot;C&amp;quot;);  \n        ts.add(&amp;quot;F&amp;quot;);  \n        System.out.println(&amp;quot;TreeSet 顺序:\\n&amp;quot;+ts);  \n    }  \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;输出效果：&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;HashSet 顺序:&lt;br&gt;\n[D, E, F, A, B, C]&lt;br&gt;\nLinkedHashSet 顺序:&lt;br&gt;\n[B, A, D, E, C, F]&lt;br&gt;\nTreeSet 顺序:&lt;br&gt;\n[A, B, C, D, E, F]&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;the-difference-of-HashSet-LinkedHashSet-TreeSet&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；&lt;br&gt;\nLinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；&lt;br&gt;\nTreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;HashSet、LinkedHashSet、TreeSet使用区别&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;集合&#34;,&#34;slug&#34;:&#34;rFbCt-bAuvF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/rFbCt-bAuvF/&#34;}],&#34;date&#34;:&#34;2016-11-29 23:26:04&#34;,&#34;dateFormat&#34;:&#34;2016-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/the-difference-of-HashSet-LinkedHashSet-TreeSet/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:120000,&#34;words&#34;:429,&#34;minutes&#34;:3},&#34;description&#34;:&#34;HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；\nLinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；\nTreeSet：提供一个使用树结构存储Set接口...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;代码演示List&amp;lt;--&amp;gt;数组、List&amp;lt;--&amp;gt;Set、数组&amp;lt;--&amp;gt;Set、Map将键转化为Set、Map将值转化为Set、Map将值转化为List等集合常用转化操作。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @Title: CollectionConversion.java&amp;lt;br&amp;gt;\n * @package: com.imarkofu.demo&amp;lt;br&amp;gt;\n * @Description:集合转换&amp;lt;br&amp;gt;\n * @author gbwl&amp;lt;br&amp;gt;\n * @date 2015年5月11日 下午3:57:01&amp;lt;br&amp;gt;\n */\npublic class CollectionConversion {\n\n\tpublic static void main(String[] args) {\n\t\t// List--&amp;gt;数组\n\t\tList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();\n\t\tlist.add(&amp;quot;蹇伟&amp;quot;);\n\t\tlist.add(&amp;quot;Jerval&amp;quot;);\n\t\tlist.add(&amp;quot;杰威&amp;quot;);\n\t\tObject[] objects = list.toArray();// 返回Object数组\n\t\tSystem.out.println(&amp;quot;objects:&amp;quot; + Arrays.toString(objects));\n\t\tString[] strings1 = new String[list.size()];\n\t\tlist.toArray(strings1);// 将转化后的数组放入已经创建好的对象中\n\t\tSystem.out.println(&amp;quot;strings1:&amp;quot; + Arrays.toString(strings1));\n\t\tString[] strings2 = list.toArray(new String[0]);// 将转化后的数组赋给新对象\n\t\tSystem.out.println(&amp;quot;strings2:&amp;quot; + Arrays.toString(strings2));\n\t\t// 数组--&amp;gt;List\n\t\tString[] ss = { &amp;quot;JJ&amp;quot;, &amp;quot;KK&amp;quot; };\n\t\tList&amp;lt;String&amp;gt; list1 = Arrays.asList(ss);\n\t\tList&amp;lt;String&amp;gt; list2 = Arrays.asList(&amp;quot;AAA&amp;quot;, &amp;quot;BBB&amp;quot;);\n\t\tSystem.out.println(list1);\n\t\tSystem.out.println(list2);\n\t\t// List--&amp;gt;Set\n\t\tList&amp;lt;String&amp;gt; list3 = new ArrayList&amp;lt;String&amp;gt;(new HashSet&amp;lt;String&amp;gt;());\n\t\t// Set--&amp;gt;List\n\t\tSet&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;(new ArrayList&amp;lt;String&amp;gt;());\n\t\t// 数组--&amp;gt;Set\n\t\tString[] strs = { &amp;quot;AA&amp;quot;, &amp;quot;BB&amp;quot; };\n\t\tSet&amp;lt;String&amp;gt; set2 = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(strs));\n\t\tSystem.out.println(set2);\n\t\t// Set--&amp;gt;数组\n\t\tSet&amp;lt;String&amp;gt; set3 = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&amp;quot;PP&amp;quot;, &amp;quot;OO&amp;quot;));\n\t\tString[] strSet = new String[set3.size()];\n\t\tset3.toArray(strSet);\n\t\tSystem.out.println(Arrays.toString(strSet));\n\t\t// Map操作\n\t\tMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();\n\t\tmap.put(&amp;quot;YYY&amp;quot;, &amp;quot;UUU&amp;quot;);\n\t\tmap.put(&amp;quot;RRR&amp;quot;, &amp;quot;TTT&amp;quot;);\n\t\t// 将键转化为Set\n\t\tSet&amp;lt;String&amp;gt; mapKeySet = map.keySet();\n\t\t// 将值转化为Set\n\t\tSet&amp;lt;String&amp;gt; mapValuesSet = new HashSet&amp;lt;String&amp;gt;(map.values());\n\t\t// 将值转化为List\n\t\tList&amp;lt;String&amp;gt; mapValuesList = new ArrayList&amp;lt;String&amp;gt;(map.values());\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-collection-transformation&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;代码演示List&amp;lt;--&amp;gt;数组、List&amp;lt;--&amp;gt;Set、数组&amp;lt;--&amp;gt;Set、Map将键转化为Set、Map将值转化为Set、Map将值转化为List等集合常用转化操作。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Java集合间的相互转换&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;Cl0XnUa_Cdl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/Cl0XnUa_Cdl/&#34;},{&#34;name&#34;:&#34;集合&#34;,&#34;slug&#34;:&#34;rFbCt-bAuvF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/rFbCt-bAuvF/&#34;}],&#34;date&#34;:&#34;2016-11-29 23:17:27&#34;,&#34;dateFormat&#34;:&#34;2016-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/java-collection-transformation/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:153000,&#34;words&#34;:457,&#34;minutes&#34;:3},&#34;description&#34;:&#34;代码演示List&amp;lt;--&amp;gt;数组、List&amp;lt;--&amp;gt;Set、数组&amp;lt;--&amp;gt;Set、Map将键转化为Set、Map将值转化为Set、Map将值转化为List等集合常用转化操作。\n\nimport java.util....&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;我一向以为，curl只是一个编程用的函数库。&lt;br&gt;\n最近才发现，这个命令本身，就是一个无比有用的网站开发工具，请看我整理的它的用法。&lt;br&gt;\ncurl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。&lt;/p&gt;\n&lt;h1 id=\&#34;-more-curl的选项功能\&#34;&gt;&lt;!--more--&gt;&lt;br&gt;\ncurl的选项功能&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;不带任何参数时curl将返回指定url中的数据并打印在屏幕上\n  -u 使用用户名和密码登陆。如curl -uname:passwd URL\n  -b/--cookie  &amp;lt;name=data&amp;gt;   向服务器提交cookie，若无=则name视为文件名，例如：curl -b cookie.txt www.imarkofu.com\n  -o out  将指定curl返回保存为out文件，内容从html/jpg到各种MIME类型文件。如curl -o page.html URL\n  -d &amp;lt;key=value&amp;gt;  向服务器POST表单数据 例如：curl -d &amp;quot;pageSize=8&amp;amp;pageNo=5&amp;quot; http://www.imarkofu.com/load.do\n  -A/--user-agent  &amp;lt;ua&amp;gt;  指定发送请求的用户代理，例如：curl -A My-Agent/1.0.0 www.imarkofu.com\n  -x  ip:port 指定使用的http代理，例如：curl -x 192.168.1.1:8080 www.imarkofu.com\n  -D head.txt  将服务器的返回的header保存为文件，头部的cookie也可被保存，例如：curl -D header.txt www.imarkofu.com\n  -L 当页面有跳转的时候，输出跳转到的页面\n  -I  header信息  当有跳转时，可以通过 curl -L -I URL|grep Location 来确定跳转到的新url地址\n  -c &amp;lt;file&amp;gt; 保存服务器的cookie文件\n  -e url  设置引用头的值\n  -T localfile  向服务器PUT文件 例如：curl -T xxx.doc  www.imarkofu.com/upload.do\n  -F &amp;lt;key=value&amp;gt; 向服务器POST表单，例如：curl -F &amp;quot;web=@index.html;type=text/html&amp;quot; url.com\n  -E cert.pem  指定本地证书\n  -H &amp;lt;header:value&amp;gt;  为HTTP请求设置任意header及值。如curl -H &amp;quot;Connection:keep-alive&amp;quot; http://www.imarkofu.com\n  -X/--request method 用户定义的HTTP请求方法名如 curl -X GET www.imarkofu.com\n  -compressed 采用压缩方式接收返回数据\n  -connect-timeout `&amp;lt;`s`&amp;gt;` 设置超时时间\n   -v 详细输出，包含请求和响应的首部\n  --retry num\n  --retry timeo 指定重试的次数和间隔\n  --tcp-nodelay 打开TCP_NODELAY选项  不进行捎带确认\n  -O  按服务器上的名称保存下载的文件\n  -r/--range  from-to 下载指定range内的数据\n  -C 在保存文件时进行续传\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;curl的常见使用\&#34;&gt;curl的常见使用&lt;/h1&gt;\n&lt;h2 id=\&#34;curl查看web站点rt\&#34;&gt;curl查看web站点rt&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;curl -o /dev/null -s -w %{time_namelookup}::%{time_connect}::%{time_starttransfer}::%{time_total}::%{speed_download}&amp;quot;\\n&amp;quot; &amp;quot;http://www.taobao.com&amp;quot;  \n0.014::0.015::0.018::0.019::1516256.00\n  -s：去掉所有状态\n  -w：按照后面的格式写出rt\ntime_namelookup：DNS 解析域名[www.taobao.com]的时间 \ntime_commect：client和server端建立TCP 连接的时间\ntime_starttransfer：从client发出请求；到web的server 响应第一个字节的时间\ntime_total：client发出请求；到web的server发送会所有的相应数据的时间\nspeed_download：下载速度  单位 byte/s\n\n0.014: DNS 服务器解析www.taobao.com 的时间单位是s\n0.015: client发出请求到server建立TCP的时间，里面包括DNS解析的时间  \n0.018: client发出请求到server响应发出第一个字节开始的时间，包括前面的2个时间  \n0.019: client发出请求到server把响应的数据全部发送给client,并关闭connect的时间  \n1516256.00 ：下载数据的速度  \n  \n1. 建立TCP连接到server返回client第一个字节的时间：0.018s - 0.015s = 0.003s  \n2. server把响应数据发送给client的时间：0.019s - 0.018 = 0.01s  \n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;curl-command-usage-guide&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;我一向以为，curl只是一个编程用的函数库。&lt;br&gt;\n最近才发现，这个命令本身，就是一个无比有用的网站开发工具，请看我整理的它的用法。&lt;br&gt;\ncurl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;curl命令使用指南&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;linux&#34;,&#34;slug&#34;:&#34;uP-eMausMK8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/uP-eMausMK8/&#34;},{&#34;name&#34;:&#34;curl&#34;,&#34;slug&#34;:&#34;33hTwgiaIWw&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imarkofu.github.io/tag/33hTwgiaIWw/&#34;}],&#34;date&#34;:&#34;2016-11-29 17:07:52&#34;,&#34;dateFormat&#34;:&#34;2016-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imarkofu.github.io/post/curl-command-usage-guide/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:225000,&#34;words&#34;:878,&#34;minutes&#34;:4},&#34;description&#34;:&#34;我一向以为，curl只是一个编程用的函数库。\n最近才发现，这个命令本身，就是一个无比有用的网站开发工具，请看我整理的它的用法。\ncurl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。\n\nc...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#-more-curl%E7%9A%84%E9%80%89%E9%A1%B9%E5%8A%9F%E8%83%BD\&#34;&gt;&lt;!--more--&gt;&lt;br&gt;\ncurl的选项功能&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#curl%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8\&#34;&gt;curl的常见使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#curl%E6%9F%A5%E7%9C%8Bweb%E7%AB%99%E7%82%B9rt\&#34;&gt;curl查看web站点rt&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->


</html>